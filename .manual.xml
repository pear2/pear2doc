<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE set PUBLIC "-//OASIS//DTD DocBook XML V5.0//EN" "./docbook/docbook-xml/docbook.dtd" [
<!-- We use xhtml entities all over the place --><!ENTITY % xhtml-lat1 SYSTEM "./entities/ISO/xhtml1-lat1.ent">
<!ENTITY % xhtml-symbol SYSTEM "./entities/ISO/xhtml1-symbol.ent">
<!ENTITY % xhtml-special SYSTEM "./entities/ISO/xhtml1-special.ent">
<!ENTITY % isopub SYSTEM "./docbook/docbook-xml/ent/isopub.ent">
<!-- isolat2 is for the polish translations
     we should remove it once it's utf-8 --><!ENTITY % isolat2 SYSTEM "./docbook/docbook-xml/ent/isolat2.ent">
<!--
     File xhtml1-lat1.ent produced by the XSL script entities.xsl
     from input data in unicode.xml.

     Please report any errors to David Carlisle
     via the public W3C list www-math@w3.org.

     The numeric character values assigned to each entity
     (should) match the Unicode assignments in Unicode 4.0.

--><!-- 
     Version: $Id: xhtml1-lat1.ent 267119 2008-10-09 15:18:14Z cweiske $

       
       System identifier: http://www.w3.org/2003/entities/xhtml1/xhtml1-lat1.ent

     The system identifier may be changed to suit local requirements.

     Typical invocation:

       <!ENTITY % xhtml1-lat1 SYSTEM
         "http://www.w3.org/2003/entities/xhtml1/xhtml1-lat1.ent"
       >
       %xhtml1-lat1;

--><!ENTITY Aacute "&#x000C1;">
<!--LATIN CAPITAL LETTER A WITH ACUTE --><!ENTITY aacute "&#x000E1;">
<!--LATIN SMALL LETTER A WITH ACUTE --><!ENTITY Acirc "&#x000C2;">
<!--LATIN CAPITAL LETTER A WITH CIRCUMFLEX --><!ENTITY acirc "&#x000E2;">
<!--LATIN SMALL LETTER A WITH CIRCUMFLEX --><!ENTITY acute "&#x000B4;">
<!--ACUTE ACCENT --><!ENTITY AElig "&#x000C6;">
<!--LATIN CAPITAL LETTER AE --><!ENTITY aelig "&#x000E6;">
<!--LATIN SMALL LETTER AE --><!ENTITY Agrave "&#x000C0;">
<!--LATIN CAPITAL LETTER A WITH GRAVE --><!ENTITY agrave "&#x000E0;">
<!--LATIN SMALL LETTER A WITH GRAVE --><!ENTITY Aring "&#x000C5;">
<!--LATIN CAPITAL LETTER A WITH RING ABOVE --><!ENTITY aring "&#x000E5;">
<!--LATIN SMALL LETTER A WITH RING ABOVE --><!ENTITY Atilde "&#x000C3;">
<!--LATIN CAPITAL LETTER A WITH TILDE --><!ENTITY atilde "&#x000E3;">
<!--LATIN SMALL LETTER A WITH TILDE --><!ENTITY Auml "&#x000C4;">
<!--LATIN CAPITAL LETTER A WITH DIAERESIS --><!ENTITY auml "&#x000E4;">
<!--LATIN SMALL LETTER A WITH DIAERESIS --><!ENTITY brvbar "&#x000A6;">
<!--BROKEN BAR --><!ENTITY Ccedil "&#x000C7;">
<!--LATIN CAPITAL LETTER C WITH CEDILLA --><!ENTITY ccedil "&#x000E7;">
<!--LATIN SMALL LETTER C WITH CEDILLA --><!ENTITY cedil "&#x000B8;">
<!--CEDILLA --><!ENTITY cent "&#x000A2;">
<!--CENT SIGN --><!ENTITY copy "&#x000A9;">
<!--COPYRIGHT SIGN --><!ENTITY curren "&#x000A4;">
<!--CURRENCY SIGN --><!ENTITY deg "&#x000B0;">
<!--DEGREE SIGN --><!ENTITY divide "&#x000F7;">
<!--DIVISION SIGN --><!ENTITY Eacute "&#x000C9;">
<!--LATIN CAPITAL LETTER E WITH ACUTE --><!ENTITY eacute "&#x000E9;">
<!--LATIN SMALL LETTER E WITH ACUTE --><!ENTITY Ecirc "&#x000CA;">
<!--LATIN CAPITAL LETTER E WITH CIRCUMFLEX --><!ENTITY ecirc "&#x000EA;">
<!--LATIN SMALL LETTER E WITH CIRCUMFLEX --><!ENTITY Egrave "&#x000C8;">
<!--LATIN CAPITAL LETTER E WITH GRAVE --><!ENTITY egrave "&#x000E8;">
<!--LATIN SMALL LETTER E WITH GRAVE --><!ENTITY ETH "&#x000D0;">
<!--LATIN CAPITAL LETTER ETH --><!ENTITY eth "&#x000F0;">
<!--LATIN SMALL LETTER ETH --><!ENTITY Euml "&#x000CB;">
<!--LATIN CAPITAL LETTER E WITH DIAERESIS --><!ENTITY euml "&#x000EB;">
<!--LATIN SMALL LETTER E WITH DIAERESIS --><!ENTITY frac12 "&#x000BD;">
<!--VULGAR FRACTION ONE HALF --><!ENTITY frac14 "&#x000BC;">
<!--VULGAR FRACTION ONE QUARTER --><!ENTITY frac34 "&#x000BE;">
<!--VULGAR FRACTION THREE QUARTERS --><!ENTITY Iacute "&#x000CD;">
<!--LATIN CAPITAL LETTER I WITH ACUTE --><!ENTITY iacute "&#x000ED;">
<!--LATIN SMALL LETTER I WITH ACUTE --><!ENTITY Icirc "&#x000CE;">
<!--LATIN CAPITAL LETTER I WITH CIRCUMFLEX --><!ENTITY icirc "&#x000EE;">
<!--LATIN SMALL LETTER I WITH CIRCUMFLEX --><!ENTITY iexcl "&#x000A1;">
<!--INVERTED EXCLAMATION MARK --><!ENTITY Igrave "&#x000CC;">
<!--LATIN CAPITAL LETTER I WITH GRAVE --><!ENTITY igrave "&#x000EC;">
<!--LATIN SMALL LETTER I WITH GRAVE --><!ENTITY iquest "&#x000BF;">
<!--INVERTED QUESTION MARK --><!ENTITY Iuml "&#x000CF;">
<!--LATIN CAPITAL LETTER I WITH DIAERESIS --><!ENTITY iuml "&#x000EF;">
<!--LATIN SMALL LETTER I WITH DIAERESIS --><!ENTITY laquo "&#x000AB;">
<!--LEFT-POINTING DOUBLE ANGLE QUOTATION MARK --><!ENTITY macr "&#x000AF;">
<!--MACRON --><!ENTITY micro "&#x000B5;">
<!--MICRO SIGN --><!ENTITY middot "&#x000B7;">
<!--MIDDLE DOT --><!ENTITY nbsp "&#x000A0;">
<!--NO-BREAK SPACE --><!ENTITY not "&#x000AC;">
<!--NOT SIGN --><!ENTITY Ntilde "&#x000D1;">
<!--LATIN CAPITAL LETTER N WITH TILDE --><!ENTITY ntilde "&#x000F1;">
<!--LATIN SMALL LETTER N WITH TILDE --><!ENTITY Oacute "&#x000D3;">
<!--LATIN CAPITAL LETTER O WITH ACUTE --><!ENTITY oacute "&#x000F3;">
<!--LATIN SMALL LETTER O WITH ACUTE --><!ENTITY Ocirc "&#x000D4;">
<!--LATIN CAPITAL LETTER O WITH CIRCUMFLEX --><!ENTITY ocirc "&#x000F4;">
<!--LATIN SMALL LETTER O WITH CIRCUMFLEX --><!ENTITY Ograve "&#x000D2;">
<!--LATIN CAPITAL LETTER O WITH GRAVE --><!ENTITY ograve "&#x000F2;">
<!--LATIN SMALL LETTER O WITH GRAVE --><!ENTITY ordf "&#x000AA;">
<!--FEMININE ORDINAL INDICATOR --><!ENTITY ordm "&#x000BA;">
<!--MASCULINE ORDINAL INDICATOR --><!ENTITY Oslash "&#x000D8;">
<!--LATIN CAPITAL LETTER O WITH STROKE --><!ENTITY oslash "&#x000F8;">
<!--LATIN SMALL LETTER O WITH STROKE --><!ENTITY Otilde "&#x000D5;">
<!--LATIN CAPITAL LETTER O WITH TILDE --><!ENTITY otilde "&#x000F5;">
<!--LATIN SMALL LETTER O WITH TILDE --><!ENTITY Ouml "&#x000D6;">
<!--LATIN CAPITAL LETTER O WITH DIAERESIS --><!ENTITY ouml "&#x000F6;">
<!--LATIN SMALL LETTER O WITH DIAERESIS --><!ENTITY para "&#x000B6;">
<!--PILCROW SIGN --><!ENTITY plusmn "&#x000B1;">
<!--PLUS-MINUS SIGN --><!ENTITY pound "&#x000A3;">
<!--POUND SIGN --><!ENTITY raquo "&#x000BB;">
<!--RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK --><!ENTITY reg "&#x000AE;">
<!--REGISTERED SIGN --><!ENTITY sect "&#x000A7;">
<!--SECTION SIGN --><!ENTITY shy "&#x000AD;">
<!--SOFT HYPHEN --><!ENTITY sup1 "&#x000B9;">
<!--SUPERSCRIPT ONE --><!ENTITY sup2 "&#x000B2;">
<!--SUPERSCRIPT TWO --><!ENTITY sup3 "&#x000B3;">
<!--SUPERSCRIPT THREE --><!ENTITY szlig "&#x000DF;">
<!--LATIN SMALL LETTER SHARP S --><!ENTITY THORN "&#x000DE;">
<!--LATIN CAPITAL LETTER THORN --><!ENTITY thorn "&#x000FE;">
<!--LATIN SMALL LETTER THORN --><!ENTITY times "&#x000D7;">
<!--MULTIPLICATION SIGN --><!ENTITY Uacute "&#x000DA;">
<!--LATIN CAPITAL LETTER U WITH ACUTE --><!ENTITY uacute "&#x000FA;">
<!--LATIN SMALL LETTER U WITH ACUTE --><!ENTITY Ucirc "&#x000DB;">
<!--LATIN CAPITAL LETTER U WITH CIRCUMFLEX --><!ENTITY ucirc "&#x000FB;">
<!--LATIN SMALL LETTER U WITH CIRCUMFLEX --><!ENTITY Ugrave "&#x000D9;">
<!--LATIN CAPITAL LETTER U WITH GRAVE --><!ENTITY ugrave "&#x000F9;">
<!--LATIN SMALL LETTER U WITH GRAVE --><!ENTITY uml "&#x000A8;">
<!--DIAERESIS --><!ENTITY Uuml "&#x000DC;">
<!--LATIN CAPITAL LETTER U WITH DIAERESIS --><!ENTITY uuml "&#x000FC;">
<!--LATIN SMALL LETTER U WITH DIAERESIS --><!ENTITY Yacute "&#x000DD;">
<!--LATIN CAPITAL LETTER Y WITH ACUTE --><!ENTITY yacute "&#x000FD;">
<!--LATIN SMALL LETTER Y WITH ACUTE --><!ENTITY yen "&#x000A5;">
<!--YEN SIGN --><!ENTITY yuml "&#x000FF;">
<!--LATIN SMALL LETTER Y WITH DIAERESIS --><!--
     File xhtml1-symbol.ent produced by the XSL script entities.xsl
     from input data in unicode.xml.

     Please report any errors to David Carlisle
     via the public W3C list www-math@w3.org.

     The numeric character values assigned to each entity
     (should) match the Unicode assignments in Unicode 4.0.

--><!-- 
     Version: $Id: xhtml1-symbol.ent 267119 2008-10-09 15:18:14Z cweiske $

       
       System identifier: http://www.w3.org/2003/entities/xhtml1/xhtml1-symbol.ent

     The system identifier may be changed to suit local requirements.

     Typical invocation:

       <!ENTITY % xhtml1-symbol SYSTEM
         "http://www.w3.org/2003/entities/xhtml1/xhtml1-symbol.ent"
       >
       %xhtml1-symbol;

--><!ENTITY alefsym "&#x02135;">
<!--ALEF SYMBOL --><!ENTITY Alpha "&#x00391;">
<!--GREEK CAPITAL LETTER ALPHA --><!ENTITY alpha "&#x003B1;">
<!--GREEK SMALL LETTER ALPHA --><!ENTITY and "&#x02227;">
<!--LOGICAL AND --><!ENTITY ang "&#x02220;">
<!--ANGLE --><!ENTITY asymp "&#x02248;">
<!--ALMOST EQUAL TO --><!ENTITY Beta "&#x00392;">
<!--GREEK CAPITAL LETTER BETA --><!ENTITY beta "&#x003B2;">
<!--GREEK SMALL LETTER BETA --><!ENTITY bull "&#x02022;">
<!--BULLET --><!ENTITY cap "&#x02229;">
<!--INTERSECTION --><!ENTITY Chi "&#x003A7;">
<!--GREEK CAPITAL LETTER CHI --><!ENTITY chi "&#x003C7;">
<!--GREEK SMALL LETTER CHI --><!ENTITY clubs "&#x02663;">
<!--BLACK CLUB SUIT --><!ENTITY cong "&#x02245;">
<!--APPROXIMATELY EQUAL TO --><!ENTITY crarr "&#x021B5;">
<!--DOWNWARDS ARROW WITH CORNER LEFTWARDS --><!ENTITY cup "&#x0222A;">
<!--UNION --><!ENTITY dArr "&#x021D3;">
<!--DOWNWARDS DOUBLE ARROW --><!ENTITY darr "&#x02193;">
<!--DOWNWARDS ARROW --><!ENTITY Delta "&#x00394;">
<!--GREEK CAPITAL LETTER DELTA --><!ENTITY delta "&#x003B4;">
<!--GREEK SMALL LETTER DELTA --><!ENTITY diams "&#x02666;">
<!--BLACK DIAMOND SUIT --><!ENTITY empty "&#x02205;">
<!--EMPTY SET --><!ENTITY Epsilon "&#x00395;">
<!--GREEK CAPITAL LETTER EPSILON --><!ENTITY epsilon "&#x003B5;">
<!--GREEK SMALL LETTER EPSILON --><!ENTITY equiv "&#x02261;">
<!--IDENTICAL TO --><!ENTITY Eta "&#x00397;">
<!--GREEK CAPITAL LETTER ETA --><!ENTITY eta "&#x003B7;">
<!--GREEK SMALL LETTER ETA --><!ENTITY exist "&#x02203;">
<!--THERE EXISTS --><!ENTITY fnof "&#x00192;">
<!--LATIN SMALL LETTER F WITH HOOK --><!ENTITY forall "&#x02200;">
<!--FOR ALL --><!ENTITY frasl "&#x02044;">
<!--FRACTION SLASH --><!ENTITY Gamma "&#x00393;">
<!--GREEK CAPITAL LETTER GAMMA --><!ENTITY gamma "&#x003B3;">
<!--GREEK SMALL LETTER GAMMA --><!ENTITY ge "&#x02265;">
<!--GREATER-THAN OR EQUAL TO --><!ENTITY hArr "&#x021D4;">
<!--LEFT RIGHT DOUBLE ARROW --><!ENTITY harr "&#x02194;">
<!--LEFT RIGHT ARROW --><!ENTITY hearts "&#x02665;">
<!--BLACK HEART SUIT --><!ENTITY hellip "&#x02026;">
<!--HORIZONTAL ELLIPSIS --><!ENTITY image "&#x02111;">
<!--BLACK-LETTER CAPITAL I --><!ENTITY infin "&#x0221E;">
<!--INFINITY --><!ENTITY int "&#x0222B;">
<!--INTEGRAL --><!ENTITY Iota "&#x00399;">
<!--GREEK CAPITAL LETTER IOTA --><!ENTITY iota "&#x003B9;">
<!--GREEK SMALL LETTER IOTA --><!ENTITY isin "&#x02208;">
<!--ELEMENT OF --><!ENTITY Kappa "&#x0039A;">
<!--GREEK CAPITAL LETTER KAPPA --><!ENTITY kappa "&#x003BA;">
<!--GREEK SMALL LETTER KAPPA --><!ENTITY Lambda "&#x0039B;">
<!--GREEK CAPITAL LETTER LAMDA --><!ENTITY lambda "&#x003BB;">
<!--GREEK SMALL LETTER LAMDA --><!ENTITY lang "&#x02329;">
<!--LEFT-POINTING ANGLE BRACKET --><!ENTITY lArr "&#x021D0;">
<!--LEFTWARDS DOUBLE ARROW --><!ENTITY larr "&#x02190;">
<!--LEFTWARDS ARROW --><!ENTITY lceil "&#x02308;">
<!--LEFT CEILING --><!ENTITY le "&#x02264;">
<!--LESS-THAN OR EQUAL TO --><!ENTITY lfloor "&#x0230A;">
<!--LEFT FLOOR --><!ENTITY lowast "&#x02217;">
<!--ASTERISK OPERATOR --><!ENTITY loz "&#x025CA;">
<!--LOZENGE --><!ENTITY minus "&#x02212;">
<!--MINUS SIGN --><!ENTITY Mu "&#x0039C;">
<!--GREEK CAPITAL LETTER MU --><!ENTITY mu "&#x003BC;">
<!--GREEK SMALL LETTER MU --><!ENTITY nabla "&#x02207;">
<!--NABLA --><!ENTITY ne "&#x02260;">
<!--NOT EQUAL TO --><!ENTITY ni "&#x0220B;">
<!--CONTAINS AS MEMBER --><!ENTITY notin "&#x02209;">
<!--NOT AN ELEMENT OF --><!ENTITY nsub "&#x02284;">
<!--NOT A SUBSET OF --><!ENTITY Nu "&#x0039D;">
<!--GREEK CAPITAL LETTER NU --><!ENTITY nu "&#x003BD;">
<!--GREEK SMALL LETTER NU --><!ENTITY oline "&#x0203E;">
<!--OVERLINE --><!ENTITY Omega "&#x003A9;">
<!--GREEK CAPITAL LETTER OMEGA --><!ENTITY omega "&#x003C9;">
<!--GREEK SMALL LETTER OMEGA --><!ENTITY Omicron "&#x0039F;">
<!--GREEK CAPITAL LETTER OMICRON --><!ENTITY omicron "&#x003BF;">
<!--GREEK SMALL LETTER OMICRON --><!ENTITY oplus "&#x02295;">
<!--CIRCLED PLUS --><!ENTITY or "&#x02228;">
<!--LOGICAL OR --><!ENTITY otimes "&#x02297;">
<!--CIRCLED TIMES --><!ENTITY part "&#x02202;">
<!--PARTIAL DIFFERENTIAL --><!ENTITY perp "&#x022A5;">
<!--UP TACK --><!ENTITY Phi "&#x003A6;">
<!--GREEK CAPITAL LETTER PHI --><!ENTITY phi "&#x003D5;">
<!--GREEK PHI SYMBOL --><!ENTITY Pi "&#x003A0;">
<!--GREEK CAPITAL LETTER PI --><!ENTITY pi "&#x003C0;">
<!--GREEK SMALL LETTER PI --><!ENTITY piv "&#x003D6;">
<!--GREEK PI SYMBOL --><!ENTITY Prime "&#x02033;">
<!--DOUBLE PRIME --><!ENTITY prime "&#x02032;">
<!--PRIME --><!ENTITY prod "&#x0220F;">
<!--N-ARY PRODUCT --><!ENTITY prop "&#x0221D;">
<!--PROPORTIONAL TO --><!ENTITY Psi "&#x003A8;">
<!--GREEK CAPITAL LETTER PSI --><!ENTITY psi "&#x003C8;">
<!--GREEK SMALL LETTER PSI --><!ENTITY radic "&#x0221A;">
<!--SQUARE ROOT --><!ENTITY rang "&#x0232A;">
<!--RIGHT-POINTING ANGLE BRACKET --><!ENTITY rArr "&#x021D2;">
<!--RIGHTWARDS DOUBLE ARROW --><!ENTITY rarr "&#x02192;">
<!--RIGHTWARDS ARROW --><!ENTITY rceil "&#x02309;">
<!--RIGHT CEILING --><!ENTITY real "&#x0211C;">
<!--BLACK-LETTER CAPITAL R --><!ENTITY rfloor "&#x0230B;">
<!--RIGHT FLOOR --><!ENTITY Rho "&#x003A1;">
<!--GREEK CAPITAL LETTER RHO --><!ENTITY rho "&#x003C1;">
<!--GREEK SMALL LETTER RHO --><!ENTITY sdot "&#x022C5;">
<!--DOT OPERATOR --><!ENTITY Sigma "&#x003A3;">
<!--GREEK CAPITAL LETTER SIGMA --><!ENTITY sigma "&#x003C3;">
<!--GREEK SMALL LETTER SIGMA --><!ENTITY sigmaf "&#x003C2;">
<!--GREEK SMALL LETTER FINAL SIGMA --><!ENTITY sim "&#x0223C;">
<!--TILDE OPERATOR --><!ENTITY spades "&#x02660;">
<!--BLACK SPADE SUIT --><!ENTITY sub "&#x02282;">
<!--SUBSET OF --><!ENTITY sube "&#x02286;">
<!--SUBSET OF OR EQUAL TO --><!ENTITY sum "&#x02211;">
<!--N-ARY SUMMATION --><!ENTITY sup "&#x02283;">
<!--SUPERSET OF --><!ENTITY supe "&#x02287;">
<!--SUPERSET OF OR EQUAL TO --><!ENTITY Tau "&#x003A4;">
<!--GREEK CAPITAL LETTER TAU --><!ENTITY tau "&#x003C4;">
<!--GREEK SMALL LETTER TAU --><!ENTITY there4 "&#x02234;">
<!--THEREFORE --><!ENTITY Theta "&#x00398;">
<!--GREEK CAPITAL LETTER THETA --><!ENTITY theta "&#x003B8;">
<!--GREEK SMALL LETTER THETA --><!ENTITY thetasym "&#x003D1;">
<!--GREEK THETA SYMBOL --><!ENTITY trade "&#x02122;">
<!--TRADE MARK SIGN --><!ENTITY uArr "&#x021D1;">
<!--UPWARDS DOUBLE ARROW --><!ENTITY uarr "&#x02191;">
<!--UPWARDS ARROW --><!ENTITY upsih "&#x003D2;">
<!--GREEK UPSILON WITH HOOK SYMBOL --><!ENTITY Upsilon "&#x003A5;">
<!--GREEK CAPITAL LETTER UPSILON --><!ENTITY upsilon "&#x003C5;">
<!--GREEK SMALL LETTER UPSILON --><!ENTITY weierp "&#x02118;">
<!--SCRIPT CAPITAL P --><!ENTITY Xi "&#x0039E;">
<!--GREEK CAPITAL LETTER XI --><!ENTITY xi "&#x003BE;">
<!--GREEK SMALL LETTER XI --><!ENTITY Zeta "&#x00396;">
<!--GREEK CAPITAL LETTER ZETA --><!ENTITY zeta "&#x003B6;">
<!--GREEK SMALL LETTER ZETA --><!--
     File xhtml1-special.ent produced by the XSL script entities.xsl
     from input data in unicode.xml.

     Please report any errors to David Carlisle
     via the public W3C list www-math@w3.org.

     The numeric character values assigned to each entity
     (should) match the Unicode assignments in Unicode 4.0.

--><!-- 
     Version: $Id: xhtml1-special.ent 267119 2008-10-09 15:18:14Z cweiske $

       
       System identifier: http://www.w3.org/2003/entities/xhtml1/xhtml1-special.ent

     The system identifier may be changed to suit local requirements.

     Typical invocation:

       <!ENTITY % xhtml1-special SYSTEM
         "http://www.w3.org/2003/entities/xhtml1/xhtml1-special.ent"
       >
       %xhtml1-special;

--><!ENTITY bdquo "&#x0201E;">
<!--DOUBLE LOW-9 QUOTATION MARK --><!ENTITY circ "&#x002C6;">
<!--MODIFIER LETTER CIRCUMFLEX ACCENT --><!ENTITY Dagger "&#x02021;">
<!--DOUBLE DAGGER --><!ENTITY dagger "&#x02020;">
<!--DAGGER --><!ENTITY emsp "&#x02003;">
<!--EM SPACE --><!ENTITY ensp "&#x02002;">
<!--EN SPACE --><!ENTITY euro "&#x020AC;">
<!--EURO SIGN --><!ENTITY gt "&#x0003E;">
<!--GREATER-THAN SIGN --><!ENTITY ldquo "&#x0201C;">
<!--LEFT DOUBLE QUOTATION MARK --><!ENTITY lrm "&#x0200E;">
<!--LEFT-TO-RIGHT MARK --><!ENTITY lsaquo "&#x02039;">
<!--SINGLE LEFT-POINTING ANGLE QUOTATION MARK --><!ENTITY lsquo "&#x02018;">
<!--LEFT SINGLE QUOTATION MARK --><!ENTITY lt "&#38;#60;">
<!--LESS-THAN SIGN --><!ENTITY mdash "&#x02014;">
<!--EM DASH --><!ENTITY ndash "&#x02013;">
<!--EN DASH --><!ENTITY OElig "&#x00152;">
<!--LATIN CAPITAL LIGATURE OE --><!ENTITY oelig "&#x00153;">
<!--LATIN SMALL LIGATURE OE --><!ENTITY permil "&#x02030;">
<!--PER MILLE SIGN --><!ENTITY quot "&#x00022;">
<!--QUOTATION MARK --><!ENTITY rdquo "&#x0201D;">
<!--RIGHT DOUBLE QUOTATION MARK --><!ENTITY rlm "&#x0200F;">
<!--RIGHT-TO-LEFT MARK --><!ENTITY rsaquo "&#x0203A;">
<!--SINGLE RIGHT-POINTING ANGLE QUOTATION MARK --><!ENTITY rsquo "&#x02019;">
<!--RIGHT SINGLE QUOTATION MARK --><!ENTITY sbquo "&#x0201A;">
<!--SINGLE LOW-9 QUOTATION MARK --><!ENTITY Scaron "&#x00160;">
<!--LATIN CAPITAL LETTER S WITH CARON --><!ENTITY scaron "&#x00161;">
<!--LATIN SMALL LETTER S WITH CARON --><!ENTITY thinsp "&#x02009;">
<!--THIN SPACE --><!ENTITY tilde "&#x002DC;">
<!--SMALL TILDE --><!ENTITY Yuml "&#x00178;">
<!--LATIN CAPITAL LETTER Y WITH DIAERESIS --><!ENTITY zwj "&#x0200D;">
<!--ZERO WIDTH JOINER --><!ENTITY zwnj "&#x0200C;">
<!--ZERO WIDTH NON-JOINER --><!--
     File isopub.ent produced by the XSL script entities.xsl
     from input data in unicode.xml.

     Please report any errors to David Carlisle
     via the public W3C list www-math@w3.org.

     The numeric character values assigned to each entity
     (should) match the Unicode assignments in Unicode 4.0.

     Entity names in this file are derived from files carrying the
     following notice:

     (C) International Organization for Standardization 1986
     Permission to copy in any form is granted for use with
     conforming SGML systems and applications as defined in
     ISO 8879, provided this notice is included in all copies.

--><!-- 
     Version: $Id: isopub.ent 267121 2008-10-09 15:59:16Z saltybeagle $

       Public identifier: ISO 8879:1986//ENTITIES Publishing//EN//XML
       System identifier: http://www.w3.org/2003/entities/iso8879/isopub.ent

     The public identifier should always be used verbatim.
     The system identifier may be changed to suit local requirements.

     Typical invocation:

       <!ENTITY % isopub PUBLIC
         "ISO 8879:1986//ENTITIES Publishing//EN//XML"
         "http://www.w3.org/2003/entities/iso8879/isopub.ent"
       >
       %isopub;

--><!ENTITY blank "&#x02423;">
<!--OPEN BOX --><!ENTITY blk12 "&#x02592;">
<!--MEDIUM SHADE --><!ENTITY blk14 "&#x02591;">
<!--LIGHT SHADE --><!ENTITY blk34 "&#x02593;">
<!--DARK SHADE --><!ENTITY block "&#x02588;">
<!--FULL BLOCK --><!--BULLET --><!ENTITY caret "&#x02041;">
<!--CARET INSERTION POINT --><!ENTITY check "&#x02713;">
<!--CHECK MARK --><!ENTITY cir "&#x025CB;">
<!--WHITE CIRCLE --><!--BLACK CLUB SUIT --><!ENTITY copysr "&#x02117;">
<!--SOUND RECORDING COPYRIGHT --><!ENTITY cross "&#x02717;">
<!--BALLOT X --><!--DOUBLE DAGGER --><!--DAGGER --><!ENTITY dash "&#x02010;">
<!--HYPHEN --><!--BLACK DIAMOND SUIT --><!ENTITY dlcrop "&#x0230D;">
<!--BOTTOM LEFT CROP --><!ENTITY drcrop "&#x0230C;">
<!--BOTTOM RIGHT CROP --><!ENTITY dtri "&#x025BF;">
<!--WHITE DOWN-POINTING SMALL TRIANGLE --><!ENTITY dtrif "&#x025BE;">
<!--BLACK DOWN-POINTING SMALL TRIANGLE --><!--EM SPACE --><!ENTITY emsp13 "&#x02004;">
<!--THREE-PER-EM SPACE --><!ENTITY emsp14 "&#x02005;">
<!--FOUR-PER-EM SPACE --><!--EN SPACE --><!ENTITY female "&#x02640;">
<!--FEMALE SIGN --><!ENTITY ffilig "&#x0FB03;">
<!--LATIN SMALL LIGATURE FFI --><!ENTITY fflig "&#x0FB00;">
<!--LATIN SMALL LIGATURE FF --><!ENTITY ffllig "&#x0FB04;">
<!--LATIN SMALL LIGATURE FFL --><!ENTITY filig "&#x0FB01;">
<!--LATIN SMALL LIGATURE FI --><!ENTITY flat "&#x0266D;">
<!--MUSIC FLAT SIGN --><!ENTITY fllig "&#x0FB02;">
<!--LATIN SMALL LIGATURE FL --><!ENTITY frac13 "&#x02153;">
<!--VULGAR FRACTION ONE THIRD --><!ENTITY frac15 "&#x02155;">
<!--VULGAR FRACTION ONE FIFTH --><!ENTITY frac16 "&#x02159;">
<!--VULGAR FRACTION ONE SIXTH --><!ENTITY frac23 "&#x02154;">
<!--VULGAR FRACTION TWO THIRDS --><!ENTITY frac25 "&#x02156;">
<!--VULGAR FRACTION TWO FIFTHS --><!ENTITY frac35 "&#x02157;">
<!--VULGAR FRACTION THREE FIFTHS --><!ENTITY frac45 "&#x02158;">
<!--VULGAR FRACTION FOUR FIFTHS --><!ENTITY frac56 "&#x0215A;">
<!--VULGAR FRACTION FIVE SIXTHS --><!ENTITY hairsp "&#x0200A;">
<!--HAIR SPACE --><!--BLACK HEART SUIT --><!--HORIZONTAL ELLIPSIS --><!ENTITY hybull "&#x02043;">
<!--HYPHEN BULLET --><!ENTITY incare "&#x02105;">
<!--CARE OF --><!ENTITY ldquor "&#x0201E;">
<!--DOUBLE LOW-9 QUOTATION MARK --><!ENTITY lhblk "&#x02584;">
<!--LOWER HALF BLOCK --><!--LOZENGE --><!ENTITY lozf "&#x029EB;">
<!--BLACK LOZENGE --><!ENTITY lsquor "&#x0201A;">
<!--SINGLE LOW-9 QUOTATION MARK --><!ENTITY ltri "&#x025C3;">
<!--WHITE LEFT-POINTING SMALL TRIANGLE --><!ENTITY ltrif "&#x025C2;">
<!--BLACK LEFT-POINTING SMALL TRIANGLE --><!ENTITY male "&#x02642;">
<!--MALE SIGN --><!ENTITY malt "&#x02720;">
<!--MALTESE CROSS --><!ENTITY marker "&#x025AE;">
<!--BLACK VERTICAL RECTANGLE --><!--EM DASH --><!ENTITY mldr "&#x02026;">
<!--HORIZONTAL ELLIPSIS --><!ENTITY natur "&#x0266E;">
<!--MUSIC NATURAL SIGN --><!--EN DASH --><!ENTITY nldr "&#x02025;">
<!--TWO DOT LEADER --><!ENTITY numsp "&#x02007;">
<!--FIGURE SPACE --><!ENTITY phone "&#x0260E;">
<!--BLACK TELEPHONE --><!ENTITY puncsp "&#x02008;">
<!--PUNCTUATION SPACE --><!ENTITY rdquor "&#x0201D;">
<!--RIGHT DOUBLE QUOTATION MARK --><!ENTITY rect "&#x025AD;">
<!--WHITE RECTANGLE --><!ENTITY rsquor "&#x02019;">
<!--RIGHT SINGLE QUOTATION MARK --><!ENTITY rtri "&#x025B9;">
<!--WHITE RIGHT-POINTING SMALL TRIANGLE --><!ENTITY rtrif "&#x025B8;">
<!--BLACK RIGHT-POINTING SMALL TRIANGLE --><!ENTITY rx "&#x0211E;">
<!--PRESCRIPTION TAKE --><!ENTITY sext "&#x02736;">
<!--SIX POINTED BLACK STAR --><!ENTITY sharp "&#x0266F;">
<!--MUSIC SHARP SIGN --><!--BLACK SPADE SUIT --><!ENTITY squ "&#x025A1;">
<!--WHITE SQUARE --><!ENTITY squf "&#x025AA;">
<!--BLACK SMALL SQUARE --><!ENTITY star "&#x02606;">
<!--WHITE STAR --><!ENTITY starf "&#x02605;">
<!--BLACK STAR --><!ENTITY target "&#x02316;">
<!--POSITION INDICATOR --><!ENTITY telrec "&#x02315;">
<!--TELEPHONE RECORDER --><!--THIN SPACE --><!ENTITY uhblk "&#x02580;">
<!--UPPER HALF BLOCK --><!ENTITY ulcrop "&#x0230F;">
<!--TOP LEFT CROP --><!ENTITY urcrop "&#x0230E;">
<!--TOP RIGHT CROP --><!ENTITY utri "&#x025B5;">
<!--WHITE UP-POINTING SMALL TRIANGLE --><!ENTITY utrif "&#x025B4;">
<!--BLACK UP-POINTING SMALL TRIANGLE --><!ENTITY vellip "&#x022EE;">
<!--VERTICAL ELLIPSIS --><!--
     File isolat2.ent produced by the XSL script entities.xsl
     from input data in unicode.xml.

     Please report any errors to David Carlisle
     via the public W3C list www-math@w3.org.

     The numeric character values assigned to each entity
     (should) match the Unicode assignments in Unicode 4.0.

     Entity names in this file are derived from files carrying the
     following notice:

     (C) International Organization for Standardization 1986
     Permission to copy in any form is granted for use with
     conforming SGML systems and applications as defined in
     ISO 8879, provided this notice is included in all copies.

--><!-- 
     Version: $Id: isolat2.ent 267121 2008-10-09 15:59:16Z saltybeagle $

       Public identifier: ISO 8879:1986//ENTITIES Added Latin 2//EN//XML
       System identifier: http://www.w3.org/2003/entities/iso8879/isolat2.ent

     The public identifier should always be used verbatim.
     The system identifier may be changed to suit local requirements.

     Typical invocation:

       <!ENTITY % isolat2 PUBLIC
         "ISO 8879:1986//ENTITIES Added Latin 2//EN//XML"
         "http://www.w3.org/2003/entities/iso8879/isolat2.ent"
       >
       %isolat2;

--><!ENTITY Abreve "&#x00102;">
<!--LATIN CAPITAL LETTER A WITH BREVE --><!ENTITY abreve "&#x00103;">
<!--LATIN SMALL LETTER A WITH BREVE --><!ENTITY Amacr "&#x00100;">
<!--LATIN CAPITAL LETTER A WITH MACRON --><!ENTITY amacr "&#x00101;">
<!--LATIN SMALL LETTER A WITH MACRON --><!ENTITY Aogon "&#x00104;">
<!--LATIN CAPITAL LETTER A WITH OGONEK --><!ENTITY aogon "&#x00105;">
<!--LATIN SMALL LETTER A WITH OGONEK --><!ENTITY Cacute "&#x00106;">
<!--LATIN CAPITAL LETTER C WITH ACUTE --><!ENTITY cacute "&#x00107;">
<!--LATIN SMALL LETTER C WITH ACUTE --><!ENTITY Ccaron "&#x0010C;">
<!--LATIN CAPITAL LETTER C WITH CARON --><!ENTITY ccaron "&#x0010D;">
<!--LATIN SMALL LETTER C WITH CARON --><!ENTITY Ccirc "&#x00108;">
<!--LATIN CAPITAL LETTER C WITH CIRCUMFLEX --><!ENTITY ccirc "&#x00109;">
<!--LATIN SMALL LETTER C WITH CIRCUMFLEX --><!ENTITY Cdot "&#x0010A;">
<!--LATIN CAPITAL LETTER C WITH DOT ABOVE --><!ENTITY cdot "&#x0010B;">
<!--LATIN SMALL LETTER C WITH DOT ABOVE --><!ENTITY Dcaron "&#x0010E;">
<!--LATIN CAPITAL LETTER D WITH CARON --><!ENTITY dcaron "&#x0010F;">
<!--LATIN SMALL LETTER D WITH CARON --><!ENTITY Dstrok "&#x00110;">
<!--LATIN CAPITAL LETTER D WITH STROKE --><!ENTITY dstrok "&#x00111;">
<!--LATIN SMALL LETTER D WITH STROKE --><!ENTITY Ecaron "&#x0011A;">
<!--LATIN CAPITAL LETTER E WITH CARON --><!ENTITY ecaron "&#x0011B;">
<!--LATIN SMALL LETTER E WITH CARON --><!ENTITY Edot "&#x00116;">
<!--LATIN CAPITAL LETTER E WITH DOT ABOVE --><!ENTITY edot "&#x00117;">
<!--LATIN SMALL LETTER E WITH DOT ABOVE --><!ENTITY Emacr "&#x00112;">
<!--LATIN CAPITAL LETTER E WITH MACRON --><!ENTITY emacr "&#x00113;">
<!--LATIN SMALL LETTER E WITH MACRON --><!ENTITY ENG "&#x0014A;">
<!--LATIN CAPITAL LETTER ENG --><!ENTITY eng "&#x0014B;">
<!--LATIN SMALL LETTER ENG --><!ENTITY Eogon "&#x00118;">
<!--LATIN CAPITAL LETTER E WITH OGONEK --><!ENTITY eogon "&#x00119;">
<!--LATIN SMALL LETTER E WITH OGONEK --><!ENTITY gacute "&#x001F5;">
<!--LATIN SMALL LETTER G WITH ACUTE --><!ENTITY Gbreve "&#x0011E;">
<!--LATIN CAPITAL LETTER G WITH BREVE --><!ENTITY gbreve "&#x0011F;">
<!--LATIN SMALL LETTER G WITH BREVE --><!ENTITY Gcedil "&#x00122;">
<!--LATIN CAPITAL LETTER G WITH CEDILLA --><!ENTITY Gcirc "&#x0011C;">
<!--LATIN CAPITAL LETTER G WITH CIRCUMFLEX --><!ENTITY gcirc "&#x0011D;">
<!--LATIN SMALL LETTER G WITH CIRCUMFLEX --><!ENTITY Gdot "&#x00120;">
<!--LATIN CAPITAL LETTER G WITH DOT ABOVE --><!ENTITY gdot "&#x00121;">
<!--LATIN SMALL LETTER G WITH DOT ABOVE --><!ENTITY Hcirc "&#x00124;">
<!--LATIN CAPITAL LETTER H WITH CIRCUMFLEX --><!ENTITY hcirc "&#x00125;">
<!--LATIN SMALL LETTER H WITH CIRCUMFLEX --><!ENTITY Hstrok "&#x00126;">
<!--LATIN CAPITAL LETTER H WITH STROKE --><!ENTITY hstrok "&#x00127;">
<!--LATIN SMALL LETTER H WITH STROKE --><!ENTITY Idot "&#x00130;">
<!--LATIN CAPITAL LETTER I WITH DOT ABOVE --><!ENTITY IJlig "&#x00132;">
<!--LATIN CAPITAL LIGATURE IJ --><!ENTITY ijlig "&#x00133;">
<!--LATIN SMALL LIGATURE IJ --><!ENTITY Imacr "&#x0012A;">
<!--LATIN CAPITAL LETTER I WITH MACRON --><!ENTITY imacr "&#x0012B;">
<!--LATIN SMALL LETTER I WITH MACRON --><!ENTITY inodot "&#x00131;">
<!--LATIN SMALL LETTER DOTLESS I --><!ENTITY Iogon "&#x0012E;">
<!--LATIN CAPITAL LETTER I WITH OGONEK --><!ENTITY iogon "&#x0012F;">
<!--LATIN SMALL LETTER I WITH OGONEK --><!ENTITY Itilde "&#x00128;">
<!--LATIN CAPITAL LETTER I WITH TILDE --><!ENTITY itilde "&#x00129;">
<!--LATIN SMALL LETTER I WITH TILDE --><!ENTITY Jcirc "&#x00134;">
<!--LATIN CAPITAL LETTER J WITH CIRCUMFLEX --><!ENTITY jcirc "&#x00135;">
<!--LATIN SMALL LETTER J WITH CIRCUMFLEX --><!ENTITY Kcedil "&#x00136;">
<!--LATIN CAPITAL LETTER K WITH CEDILLA --><!ENTITY kcedil "&#x00137;">
<!--LATIN SMALL LETTER K WITH CEDILLA --><!ENTITY kgreen "&#x00138;">
<!--LATIN SMALL LETTER KRA --><!ENTITY Lacute "&#x00139;">
<!--LATIN CAPITAL LETTER L WITH ACUTE --><!ENTITY lacute "&#x0013A;">
<!--LATIN SMALL LETTER L WITH ACUTE --><!ENTITY Lcaron "&#x0013D;">
<!--LATIN CAPITAL LETTER L WITH CARON --><!ENTITY lcaron "&#x0013E;">
<!--LATIN SMALL LETTER L WITH CARON --><!ENTITY Lcedil "&#x0013B;">
<!--LATIN CAPITAL LETTER L WITH CEDILLA --><!ENTITY lcedil "&#x0013C;">
<!--LATIN SMALL LETTER L WITH CEDILLA --><!ENTITY Lmidot "&#x0013F;">
<!--LATIN CAPITAL LETTER L WITH MIDDLE DOT --><!ENTITY lmidot "&#x00140;">
<!--LATIN SMALL LETTER L WITH MIDDLE DOT --><!ENTITY Lstrok "&#x00141;">
<!--LATIN CAPITAL LETTER L WITH STROKE --><!ENTITY lstrok "&#x00142;">
<!--LATIN SMALL LETTER L WITH STROKE --><!ENTITY Nacute "&#x00143;">
<!--LATIN CAPITAL LETTER N WITH ACUTE --><!ENTITY nacute "&#x00144;">
<!--LATIN SMALL LETTER N WITH ACUTE --><!ENTITY napos "&#x00149;">
<!--LATIN SMALL LETTER N PRECEDED BY APOSTROPHE --><!ENTITY Ncaron "&#x00147;">
<!--LATIN CAPITAL LETTER N WITH CARON --><!ENTITY ncaron "&#x00148;">
<!--LATIN SMALL LETTER N WITH CARON --><!ENTITY Ncedil "&#x00145;">
<!--LATIN CAPITAL LETTER N WITH CEDILLA --><!ENTITY ncedil "&#x00146;">
<!--LATIN SMALL LETTER N WITH CEDILLA --><!ENTITY Odblac "&#x00150;">
<!--LATIN CAPITAL LETTER O WITH DOUBLE ACUTE --><!ENTITY odblac "&#x00151;">
<!--LATIN SMALL LETTER O WITH DOUBLE ACUTE --><!--LATIN CAPITAL LIGATURE OE --><!--LATIN SMALL LIGATURE OE --><!ENTITY Omacr "&#x0014C;">
<!--LATIN CAPITAL LETTER O WITH MACRON --><!ENTITY omacr "&#x0014D;">
<!--LATIN SMALL LETTER O WITH MACRON --><!ENTITY Racute "&#x00154;">
<!--LATIN CAPITAL LETTER R WITH ACUTE --><!ENTITY racute "&#x00155;">
<!--LATIN SMALL LETTER R WITH ACUTE --><!ENTITY Rcaron "&#x00158;">
<!--LATIN CAPITAL LETTER R WITH CARON --><!ENTITY rcaron "&#x00159;">
<!--LATIN SMALL LETTER R WITH CARON --><!ENTITY Rcedil "&#x00156;">
<!--LATIN CAPITAL LETTER R WITH CEDILLA --><!ENTITY rcedil "&#x00157;">
<!--LATIN SMALL LETTER R WITH CEDILLA --><!ENTITY Sacute "&#x0015A;">
<!--LATIN CAPITAL LETTER S WITH ACUTE --><!ENTITY sacute "&#x0015B;">
<!--LATIN SMALL LETTER S WITH ACUTE --><!--LATIN CAPITAL LETTER S WITH CARON --><!--LATIN SMALL LETTER S WITH CARON --><!ENTITY Scedil "&#x0015E;">
<!--LATIN CAPITAL LETTER S WITH CEDILLA --><!ENTITY scedil "&#x0015F;">
<!--LATIN SMALL LETTER S WITH CEDILLA --><!ENTITY Scirc "&#x0015C;">
<!--LATIN CAPITAL LETTER S WITH CIRCUMFLEX --><!ENTITY scirc "&#x0015D;">
<!--LATIN SMALL LETTER S WITH CIRCUMFLEX --><!ENTITY Tcaron "&#x00164;">
<!--LATIN CAPITAL LETTER T WITH CARON --><!ENTITY tcaron "&#x00165;">
<!--LATIN SMALL LETTER T WITH CARON --><!ENTITY Tcedil "&#x00162;">
<!--LATIN CAPITAL LETTER T WITH CEDILLA --><!ENTITY tcedil "&#x00163;">
<!--LATIN SMALL LETTER T WITH CEDILLA --><!ENTITY Tstrok "&#x00166;">
<!--LATIN CAPITAL LETTER T WITH STROKE --><!ENTITY tstrok "&#x00167;">
<!--LATIN SMALL LETTER T WITH STROKE --><!ENTITY Ubreve "&#x0016C;">
<!--LATIN CAPITAL LETTER U WITH BREVE --><!ENTITY ubreve "&#x0016D;">
<!--LATIN SMALL LETTER U WITH BREVE --><!ENTITY Udblac "&#x00170;">
<!--LATIN CAPITAL LETTER U WITH DOUBLE ACUTE --><!ENTITY udblac "&#x00171;">
<!--LATIN SMALL LETTER U WITH DOUBLE ACUTE --><!ENTITY Umacr "&#x0016A;">
<!--LATIN CAPITAL LETTER U WITH MACRON --><!ENTITY umacr "&#x0016B;">
<!--LATIN SMALL LETTER U WITH MACRON --><!ENTITY Uogon "&#x00172;">
<!--LATIN CAPITAL LETTER U WITH OGONEK --><!ENTITY uogon "&#x00173;">
<!--LATIN SMALL LETTER U WITH OGONEK --><!ENTITY Uring "&#x0016E;">
<!--LATIN CAPITAL LETTER U WITH RING ABOVE --><!ENTITY uring "&#x0016F;">
<!--LATIN SMALL LETTER U WITH RING ABOVE --><!ENTITY Utilde "&#x00168;">
<!--LATIN CAPITAL LETTER U WITH TILDE --><!ENTITY utilde "&#x00169;">
<!--LATIN SMALL LETTER U WITH TILDE --><!ENTITY Wcirc "&#x00174;">
<!--LATIN CAPITAL LETTER W WITH CIRCUMFLEX --><!ENTITY wcirc "&#x00175;">
<!--LATIN SMALL LETTER W WITH CIRCUMFLEX --><!ENTITY Ycirc "&#x00176;">
<!--LATIN CAPITAL LETTER Y WITH CIRCUMFLEX --><!ENTITY ycirc "&#x00177;">
<!--LATIN SMALL LETTER Y WITH CIRCUMFLEX --><!--LATIN CAPITAL LETTER Y WITH DIAERESIS --><!ENTITY Zacute "&#x00179;">
<!--LATIN CAPITAL LETTER Z WITH ACUTE --><!ENTITY zacute "&#x0017A;">
<!--LATIN SMALL LETTER Z WITH ACUTE --><!ENTITY Zcaron "&#x0017D;">
<!--LATIN CAPITAL LETTER Z WITH CARON --><!ENTITY zcaron "&#x0017E;">
<!--LATIN SMALL LETTER Z WITH CARON --><!ENTITY Zdot "&#x0017B;">
<!--LATIN CAPITAL LETTER Z WITH DOT ABOVE --><!ENTITY zdot "&#x0017C;">
<!--LATIN SMALL LETTER Z WITH DOT ABOVE --><!ENTITY dollar "$">
<!ENTITY % language-defs SYSTEM "./en/language-defs.ent">
<!ENTITY % language-snippets SYSTEM "./en/language-snippets.ent">
<!ENTITY % shortcuts-defs SYSTEM "./entities/shortcuts-defs.ent">
<!-- $Revision: 283280 $ --><!ENTITY PEARManual "PEAR Manual">
<!ENTITY Translatedby "Translated by">
<!ENTITY Date "Date:">
<!ENTITY AboutPEAR "About PEAR and PEAR2">
<!ENTITY CodingStandards "Coding Standards">
<!ENTITY Pyrus "Using Pyrus, the PEAR Installer for PHP 5.3+">
<!ENTITY DevelopersGuide "PEAR Developer Guide">
<!ENTITY Channels "Channels: distributing your packages">
<!ENTITY UsersGuide "User Guide">
<!ENTITY NewMaintainersGuide "Becoming a PEAR developer: how to get involved">
<!ENTITY ChangesInPear14 "PEAR Installer: customizing the installer itself">
<!ENTITY Features "Features">
<!ENTITY PEAR "PEAR: the PHP Extension and Application Repository">
<!ENTITY PEAR2Packages "PEAR2 Packages">
<!ENTITY Core "PEAR Installer: Core components (Installer API, error handling)">
<!ENTITY Contributing "Contributing to PEAR">
<!-- $Revision: 289292 $ --><!ENTITY warn.experimental '<warning xmlns="http://docbook.org/ns/docbook"><simpara>This module is
<emphasis>EXPERIMENTAL</emphasis>. That means that the behaviour of these
functions, these function names, in concreto ANYTHING documented here can
change in a future release of this package WITHOUT NOTICE. Be warned, and
use this module at your own risk.</simpara></warning>'>
<!ENTITY warn.experimental.func '<warning xmlns="http://docbook.org/ns/docbook"><simpara>This function is
<emphasis>EXPERIMENTAL</emphasis>. That means, that the behaviour of this
function, the function name, in concreto ANYTHING documented here can
change in a future release of this package WITHOUT NOTICE. Be warned, and
use this function at your own risk.</simpara></warning>'>
<!ENTITY warn.undocumented.func '<warning xmlns="http://docbook.org/ns/docbook"><simpara>This function is
currently not documented.</simpara></warning>'>
<!ENTITY warn.undocumented.method '<warning xmlns="http://docbook.org/ns/docbook"><simpara>This method is
currently not documented.</simpara></warning>'>
<!ENTITY tip.ob-capture '<tip xmlns="http://docbook.org/ns/docbook"><simpara>As with anything that outputs its
result directly to the browser, you can use the 
<ulink url="&url.php.lookup;outcontrol">output-control functions</ulink> to
capture the output of this function, and save it - for example - in a
<type>string</type>.</simpara></tip>'>
<!ENTITY return.success "Returns &true; on success, &false; on failure.">
<!ENTITY return.success-pearerror 'Returns &true; on success,
<classname xmlns="http://docbook.org/ns/docbook">PEAR_Error</classname> on failure.'>
<!ENTITY return.falseproblem '<warning xmlns="http://docbook.org/ns/docbook"><simpara>This function may return
&false;, but may also return a value evaluating to &false; in a simple if
statement. Please use <ulink url="&url.php.lookup;operators.comparison">
the === operator</ulink> for testing the return value of this function.
</simpara></warning>'>
<!ENTITY link.coding-standards 'PEAR <link linkend="standards" xmlns="http://docbook.org/ns/docbook">coding
standards</link>'>
<!ENTITY note.canstatic '<simpara xmlns="http://docbook.org/ns/docbook">This function can be called
statically.</simpara>'>
<!ENTITY note.shouldstatic '<simpara xmlns="http://docbook.org/ns/docbook">This function should be called
statically.</simpara>'>
<!ENTITY note.notstatic '<simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>'>
<!ENTITY note.deprecated '<warning xmlns="http://docbook.org/ns/docbook"><para>This function is
<emphasis>deprecated</emphasis>. That means that future versions of
this package may not support it anymore.</para></warning>'>
<!ENTITY title.desc '<title xmlns="http://docbook.org/ns/docbook">Description</title>'>
<!ENTITY title.param '<title xmlns="http://docbook.org/ns/docbook">Parameter</title>'>
<!ENTITY title.deprecated '<title xmlns="http://docbook.org/ns/docbook">Deprecated</title>'>
<!ENTITY title.returns '<title xmlns="http://docbook.org/ns/docbook">Return value</title>'>
<!ENTITY title.throws '<title xmlns="http://docbook.org/ns/docbook">Throws</title>'>
<!ENTITY title.throws.errortable "Possible PEAR_Error values">
<!ENTITY title.note '<title xmlns="http://docbook.org/ns/docbook">Note</title>'>
<!ENTITY title.example '<title xmlns="http://docbook.org/ns/docbook">Example</title>'>
<!ENTITY title.see '<title xmlns="http://docbook.org/ns/docbook">See</title>'>
<!ENTITY title.since '<title xmlns="http://docbook.org/ns/docbook">Since</title>'>
<!ENTITY title.constants "Constants">
<!ENTITY type.array '<type xmlns="http://docbook.org/ns/docbook">array</type>'>
<!ENTITY type.bool '<type xmlns="http://docbook.org/ns/docbook">boolean</type>'>
<!ENTITY type.callback '<type xmlns="http://docbook.org/ns/docbook">callback</type>'>
<!ENTITY type.float '<type xmlns="http://docbook.org/ns/docbook">float</type>'>
<!ENTITY type.int '<type xmlns="http://docbook.org/ns/docbook">integer</type>'>
<!ENTITY type.integer '<type xmlns="http://docbook.org/ns/docbook">integer</type>'>
<!ENTITY type.mixed '<type xmlns="http://docbook.org/ns/docbook">mixed</type>'>
<!ENTITY type.object '<type xmlns="http://docbook.org/ns/docbook">object</type>'>
<!ENTITY type.res '<type xmlns="http://docbook.org/ns/docbook">resource</type>'>
<!ENTITY type.resource '<type xmlns="http://docbook.org/ns/docbook">resource</type>'>
<!ENTITY type.string '<type xmlns="http://docbook.org/ns/docbook">string</type>'>
<!ENTITY type.void '<type xmlns="http://docbook.org/ns/docbook">void</type>'>
<!ENTITY purpose.preconstants "predefined constants">
<!ENTITY pdevrel "(package developer related)">
<!ENTITY notdocumented '<para xmlns="http://docbook.org/ns/docbook">This package is not documented yet.</para>'>
<!ENTITY noexceptions '<para xmlns="http://docbook.org/ns/docbook">No exceptions thrown.</para>'>
<!-- $Revision: 289284 $ --><!ENTITY class.pear '<link linkend="core.pear.pear" xmlns="http://docbook.org/ns/docbook"><classname>PEAR</classname></link>'>
<!ENTITY class.pear-error '<link linkend="core.pear.pear-error" xmlns="http://docbook.org/ns/docbook"><classname>PEAR_Error</classname></link>'>
<!ENTITY class.pear-exception '<link linkend="core.pear.pear-exception" xmlns="http://docbook.org/ns/docbook"><classname>PEAR_Exception</classname></link>'>
<!ENTITY blankpagehack "">
<!--<chapter><title/><simpara/></chapter>'>--><!-- All global entities for the XML files --><!ENTITY % global.entities SYSTEM "./entities/global.ent">
<!-- These are language independent --><!ENTITY % frontpage.entities SYSTEM "./en/contributors.ent">
<!ENTITY % build.version SYSTEM "entities/version.ent">
<!ENTITY % global.chapters SYSTEM "chapters.ent">
<!ENTITY authors.list SYSTEM "authors.xml">
<!-- -*- SGML -*-

 $Id: global.ent 309385 2011-03-18 14:40:26Z saltybeagle $

 Contains global "macros" for all the XML documents.

 --><!ENTITY url.amazon "http://www.amazon.com/">
<!ENTITY url.astyle "http://astyle.sourceforge.net/">
<!ENTITY url.cacert "http://www.cacert.org/">
<!ENTITY url.cacert.mozilla "http://www.cacert.org/index.php?id=3">
<!ENTITY url.cacert.ie "http://www.cacert.org/index.php?id=17">
<!ENTITY url.chiara "http://pear.chiaraquartet.net">
<!ENTITY url.corba.universe "http://universe-phpext.sourceforge.net/">
<!ENTITY url.cvs.book "http://cvsbook.red-bean.com/">
<!ENTITY url.debian.apt "http://www.debian.org/doc/manuals/apt-howto/">
<!ENTITY url.delicious "http://delicious.com/">
<!ENTITY url.docbook.book "http://www.docbook.org/">
<!ENTITY url.docbook.book.read "http://www.docbook.org/tdg5/">
<!ENTITY url.docbook.book.reference "http://www.docbook.org/tdg5/en/html/ref-elements.html">
<!ENTITY url.docbook.xml "http://www.oasis-open.org/docbook/xml/">
<!ENTITY url.docbook.schema "http://www.docbook.org/rng/4.3/">
<!ENTITY url.doc.test.build.1 "http://ucommbieber.unl.edu/peardoc/build/en/pear_manual_en/">
<!ENTITY url.doc.test.build.1.log "http://ucommbieber.unl.edu/peardoc/build/build.log">
<!ENTITY url.doc.test.build.2 "http://peardoc.m-takagi.org/">
<!ENTITY url.doc.test.build.3 "http://beni.hallinger.org/peardoc/en/html/">
<!ENTITY url.doc.test.build.3.log "http://beni.hallinger.org/peardoc/build.log">
<!ENTITY url.dsssl "http://wiki.docbook.org/topic/DocBookDssslStylesheets">
<!ENTITY url.ebay "http://www.ebay.com/">
<!ENTITY url.ebay.developer "http://developer.ebay.com/">
<!ENTITY url.ebay.developer.join "http://developer.ebay.com/join/">
<!ENTITY url.ebay.developer.singleusertool "http://developer.ebay.com/tokentool/Credentials.aspx">
<!ENTITY url.ebay.sandbox "http://sandbox.ebay.com/">
<!ENTITY url.ebay.sandbox.register "https://scgi.sandbox.ebay.com/ws/eBayISAPI.dll?RegisterEnterInfo&amp;siteid=0&amp;co_partnerid=2&amp;usage=0&amp;ru=default">
<!ENTITY url.efnet "http://www.efnet.org/">
<!ENTITY url.example "www.example.com">
<!ENTITY url.example.http "http://www.example.com/">
<!ENTITY url.faq.licenses.rasmus "http://news.php.net/php.pear.dev/45245">
<!ENTITY url.faq.licenses.apache1 "http://www.apache.org/licenses/LICENSE-1.1">
<!ENTITY url.faq.licenses.fsf "http://www.fsf.org/licensing/licenses/gpl-faq.html#MereAggregation">
<!ENTITY url.geonames.home "http://www.geonames.org/">
<!ENTITY url.geonames.apidocs "http://www.geonames.org/export/ws-overview.html">
<!ENTITY url.google.code "http://code.google.com/">
<!ENTITY url.google.soapsearch "http://code.google.com/apis/soapsearch/">
<!ENTITY url.gtk2-filedrop.urilist "http://gtk.php.net/manual1/en/tutorials.filednd.urilist.php">
<!ENTITY url.jade "http://www.jclark.com/jade/">
<!ENTITY url.jclark "http://www.jclark.com/bio.htm">
<!ENTITY url.dbstyle "http://wiki.docbook.org/topic/DocBookDssslStylesheets">
<!ENTITY url.nwalsh "http://nwalsh.com/">
<!ENTITY url.imagemagick "http://www.imagemagick.org/">
<!ENTITY url.java "http://java.sun.com/">
<!ENTITY url.java.oo "http://java.sun.com/docs/books/tutorial/java/concepts/">
<!ENTITY url.javadoc "http://java.sun.com/j2se/javadoc/">
<!ENTITY url.junit "http://www.junit.org/">
<!ENTITY url.kde "http://www.kde.org/">
<!ENTITY url.kerberos.info "http://web.mit.edu/kerberos/www/">
<!ENTITY url.kerberos.docs "http://web.mit.edu/kerberos/www/krb5-1.2/krb5-1.2.8/doc/admin_toc.html">
<!ENTITY url.libxml "http://www.xmlsoft.org/">
<!ENTITY url.libxml.xmllint "http://www.xmlsoft.org/xmllint.html">
<!ENTITY url.license.apache "http://www.opensource.org/licenses/apache2.0.php">
<!ENTITY url.license.bsd "http://www.opensource.org/licenses/bsd-license.html">
<!ENTITY url.license.cc "http://creativecommons.org/licenses/">
<!ENTITY url.license.gnu "http://www.gnu.org/licenses/license-list.html">
<!ENTITY url.license.lgpl "http://www.fsf.org/licensing/licenses/lgpl.txt">
<!ENTITY url.license.mit "http://www.opensource.org/licenses/mit-license.php">
<!ENTITY url.license.opensource "http://www.opensource.org/licenses/">
<!ENTITY url.license.php "http://www.php.net/license/">
<!ENTITY url.linelength.paulmjones "http://paul-m-jones.com/?p=276">
<!ENTITY url.macports "http://www.macports.org/">
<!ENTITY url.mysql "http://www.mysql.com/">
<!ENTITY url.mysql.world.download "http://dev.mysql.com/get/Downloads/Manual/world.sql.gz/from/pick">
<!ENTITY url.mysql.world.setup "http://dev.mysql.com/doc/world-setup/en/world-setup.html">
<!ENTITY url.opensource "http://www.opensource.org/">
<!ENTITY url.opl "http://www.opencontent.org/openpub/">
<!ENTITY url.oreilly "http://oreilly.com/">
<!ENTITY url.mac.entropy "http://www.entropy.ch/software/macosx/php/">
<!ENTITY url.man.index "http://unixhelp.ed.ac.uk/alphabetical/index.html">
<!ENTITY url.man.freebsd.index "http://www.freebsd.org/cgi/man.cgi">
<!ENTITY url.maxmind "http://www.maxmind.com/">
<!ENTITY url.maxmind.db.free "http://www.maxmind.com/app/geoip_country">
<!ENTITY url.maxmind.db.nonfree "http://www.maxmind.com/app/products">
<!ENTITY url.pear "http://pear.php.net/">
<!ENTITY url.pear.account "http://pear.php.net/accounts.php">
<!ENTITY url.pear.account.new "http://pear.php.net/account-request.php">
<!ENTITY url.pear.bug "http://pear.php.net/bugs/bug.php?id=">
<!ENTITY url.pear.bugs "http://pear.php.net/bugs/">
<!ENTITY url.pear.channels "http://pear.php.net/channels/">
<!ENTITY url.pear.constitution.results "http://pear.php.net/election/info.php?election=6&amp;results=1">
<!ENTITY url.pear.cvs.peardoc "http://svn.php.net/viewvc/pear/peardoc/trunk/">
<!ENTITY url.pear.developer "http://pear.php.net/user/">
<!ENTITY url.pear.docs.cachelite "http://svn.php.net/viewvc/pear/packages/Cache_Lite/trunk/docs/technical?view=markup">
<!ENTITY url.pear.dtd "http://pear.php.net/dtd/">
<!ENTITY url.pear.dtd.package1 "http://pear.php.net/dtd/package-1.0">
<!ENTITY url.pear.dtd.package1.xsd "http://pear.php.net/dtd/package-1.0.xsd">
<!ENTITY url.pear.dtd.package2 "http://pear.php.net/dtd/package-2.0">
<!ENTITY url.pear.dtd.package2.xsd "http://pear.php.net/dtd/package-2.0.xsd">
<!ENTITY url.pear.dtd.tasks1 "http://pear.php.net/dtd/tasks-1.0">
<!ENTITY url.pear.go "http://pear.php.net/go-pear.phar">
<!ENTITY url.pear.group "http://pear.php.net/group/">
<!ENTITY url.pear.group.licenses "http://pear.php.net/group/docs/20040402-la.php">
<!ENTITY url.pear.group.doc.proposals "http://pear.php.net/group/docs/20040402-la.php">
<!ENTITY url.pear.group.doc.vulnerability "http://pear.php.net/group/docs/20051104-sa.php">
<!ENTITY url.pear.manual "http://pear.php.net/manual/">
<!ENTITY url.pear.manual.installation "http://pear.php.net/manual/en/installation.php">
<!ENTITY url.pear.package "http://pear.php.net/package/">
<!ENTITY url.pear.package.browse "http://pear.php.net/packages.php">
<!ENTITY url.pear.package.new "http://pear.php.net/package-new.php">
<!ENTITY url.pear.package.upload "http://pear.php.net/release-upload.php">
<!ENTITY url.pear.pepr "http://pear.php.net/pepr/">
<!ENTITY url.pear.pepr.edit "http://pear.php.net/pepr/pepr-proposal-edit.php">
<!ENTITY url.pear.pepr.proposal "http://pear.php.net/pepr/pepr-proposal-show.php?id=">
<!ENTITY url.pear.support "http://pear.php.net/support/">
<!ENTITY url.pear.support.lists "http://pear.php.net/support/lists.php">
<!ENTITY url.pear.tasks.xsd "http://pear.php.net/dtd/tasks-1.0.xsd">
<!ENTITY url.pear2.autoload "https://github.com/pear2/PEAR2_Autoload/blob/master/src/PEAR2/Autoload.php">
<!ENTITY url.pecl "http://pecl.php.net/">
<!ENTITY url.phing "http://phing.info/">
<!ENTITY url.phd "http://doc.php.net/phd/">
<!ENTITY url.phd.pearapi "http://doc.php.net/phd/docs/#ext-phd-pearapi">
<!ENTITY url.phpdoc "http://www.phpdoc.de/">
<!ENTITY url.phpdocumentor "http://www.phpdoc.org/">
<!ENTITY url.phplib "http://sourceforge.net/projects/phplib/">
<!ENTITY url.php "http://www.php.net/">
<!ENTITY url.php.anoncvs "http://www.php.net/anoncvs.php">
<!ENTITY url.php.anonsvn "http://www.php.net/svn.php">
<!ENTITY url.php.callback "http://www.php.net/manual/language.pseudo-types.php">
<!ENTITY url.php.manual "http://www.php.net/manual/">
<!ENTITY url.php.manual.about "http://www.php.net/manual/about.php">
<!ENTITY url.php.manual.auto "http://www.php.net/">
<!ENTITY url.php.manual.howto "http://www.php.net/dochowto">
<!ENTITY url.php.manual.peclinstall "http://www.php.net/manual/en/install.pecl.php">
<!ENTITY url.php.mailinglists "http://www.php.net/mailing-lists.php">
<!ENTITY url.php.cvs "http://cvs.php.net/">
<!ENTITY url.php.cvs.pear "http://svn.php.net/viewvc/pear/">
<!ENTITY url.php.cvs.peardoc.authoring "http://svn.php.net/viewvc/pear/peardoc/trunk/en/authoring/">
<!ENTITY url.php.cvs.new "http://www.php.net/cvs-php.php">
<!ENTITY url.php.svn "http://svn.php.net/">
<!ENTITY url.php.gtk "http://gtk.php.net/">
<!ENTITY url.php.bugs "http://bugs.php.net/">
<!ENTITY url.php.bugs.howto "http://bugs.php.net/how-to-report.php">
<!ENTITY url.phpform "http://sourceforge.net/projects/phpform-ext/">
<!ENTITY url.phpunit "http://www.phpunit.de/">
<!ENTITY url.phpunit.get "http://pear.phpunit.de/get/">
<!ENTITY url.publicsuffix "http://publicsuffix.org/">
<!ENTITY url.python.doc.modindex.optparse "http://docs.python.org/library/module-optparse.html">
<!ENTITY url.recaptcha.recaptcha "http://recaptcha.net/apidocs/captcha/">
<!ENTITY url.recaptcha.recaptcha.getapikey "http://recaptcha.net/api/getkey">
<!ENTITY url.recaptcha.recaptcha.options "http://recaptcha.net/apidocs/captcha/client.html">
<!ENTITY url.recaptcha.mailhide "http://recaptcha.net/apidocs/mailhide/">
<!ENTITY url.recaptcha.mailhide.getapikey "http://mailhide.recaptcha.net/apikey">
<!ENTITY url.rest.chanservongooglecode "http://docs.google.com/present/view?id=dgstxrxv_6f48xbz">
<!ENTITY url.rss.info "http://tech.groups.yahoo.com/group/rss-dev/files/specification.html">
<!ENTITY url.simplechannelserver "https://github.com/pear2/PEAR2_SimpleChannelServer">
<!ENTITY url.simplechannelserver.phar "https://github.com/pear2/PEAR2_SimpleChannelServer/blob/master/pearscs.phar?raw=true">
<!ENTITY url.sourceforge "http://sourceforge.net/">
<!ENTITY url.subversion "http://subversion.tigris.org/">
<!ENTITY url.subversion.book "http://svnbook.red-bean.com/">
<!ENTITY url.tabs.vs.spaces "http://www.jwz.org/doc/tabs-vs-spaces.html">
<!ENTITY url.tutorial.config "http://www.devshed.com/c/a/PHP/Configuration-Manipulation-With-PHP-Config/">
<!ENTITY url.usefulinc "http://usefulinc.com/">
<!ENTITY url.usefulinc.xmlrpc.doc "http://phpxmlrpc.sourceforge.net/#interest">
<!ENTITY url.userland "http://www.userland.com/">
<!ENTITY url.xml.parser.tutorial "http://www.schst.net/articles/XML_Parser">
<!ENTITY url.xml.entities.common "http://www.evolt.org/article/A_Simple_Character_Entity_Chart/17/21234/">
<!ENTITY url.xml.entities.all "http://www.oasis-open.org/docbook/xmlcharent/0.1/index.shtml">
<!ENTITY url.xmlrpc "http://www.xmlrpc.com/">
<!ENTITY url.xmlrpc.discuss "http://www.xmlrpc.com/discuss/">
<!ENTITY url.xmlrpc.list "http://tech.groups.yahoo.com/group/xml-rpc/">
<!ENTITY url.xmlrpc.book "http://oreilly.com/catalog/progxmlrpc/">
<!ENTITY url.xmlrpc.spec "http://www.xmlrpc.com/stories/storyReader$7">
<!ENTITY url.yellowpages "http://www.yellowpages.com">
<!ENTITY url.extreme.prog "http://xprogramming.com/">
<!ENTITY url.w3 "http://www.w3.org/">
<!ENTITY url.w3.xml.rec "http://www.w3.org/TR/REC-xml/#syntax">
<!-- These are special reference/search urls
     ex. <ulink url="&url.rfc;4242">RFC 4242</ulink>
         <ulink url="&url.php.lookup;ini-set">ini_set</ulink>
         <ulink url="&url.pear.package.get;imagick">Download Imagick</ulink>
--><!ENTITY url.man "http://unixhelp.ed.ac.uk/CGI/man-cgi?">
<!ENTITY url.man.freebsd "http://www.freebsd.org/cgi/man.cgi?query=">
<!ENTITY url.pear.package.get "http://pear.php.net/get/">
<!ENTITY url.php.lookup "http://www.php.net/manual-lookup.php?pattern=">
<!ENTITY url.rfc "http://www.faqs.org/rfcs/rfc">
<!-- The three special language constants --><!ENTITY true '<constant xmlns="http://docbook.org/ns/docbook">TRUE</constant>'>
<!ENTITY false '<constant xmlns="http://docbook.org/ns/docbook">FALSE</constant>'>
<!ENTITY null '<constant xmlns="http://docbook.org/ns/docbook">NULL</constant>'>
<!-- Some commonly used file entities --><!ENTITY php.ini '<filename xmlns="http://docbook.org/ns/docbook">php.ini</filename>'>
<!ENTITY htaccess '<filename xmlns="http://docbook.org/ns/docbook">.htaccess</filename>'>
<!ENTITY httpd.conf '<filename xmlns="http://docbook.org/ns/docbook">httpd.conf</filename>'>
<!ENTITY email.martin "mj@php.net">
<!ENTITY email.stig "stig@php.net">
<!ENTITY email.hburbach "holger.burbach@gonicus.de">
<!ENTITY email.pear.general "pear-general@lists.php.net">
<!ENTITY email.pear.general-subscribe "pear-general-subscribe@lists.php.net">
<!ENTITY email.pear.webmaster "pear-webmaster@lists.php.net">
<!ENTITY email.pear.core "pear-core@lists.php.net">
<!ENTITY email.pear.dev "pear-dev@lists.php.net">
<!ENTITY email.pear.dev-subscribe "pear-dev-subscribe@lists.php.net">
<!ENTITY email.pear.doc "pear-doc@lists.php.net">
<!ENTITY email.pear.doc-subscribe "pear-doc-subscribe@lists.php.net">
<!ENTITY email.pear.qa "pear-qa@lists.php.net">
<!ENTITY email.pear.qa-subscribe "pear-qa-subscribe@lists.php.net">
<!ENTITY email.pear.group "pear-group@php.net">
<!ENTITY email.apd "apd@mail.communityconnect.com">
<!ENTITY email.php.soap "soap@lists.php.net">
<!ENTITY email.php.general "php-general@lists.php.net">
<!ENTITY link.martin '<ulink url="mailto:&email.martin;" xmlns="http://docbook.org/ns/docbook">Martin Jansen</ulink>'>
<!-- for the developers guide --><!-- For tools setup section --><!ENTITY url.nwalsh.xsl "http://wiki.docbook.org/topic/DocBookXslStylesheets">
<!ENTITY url.autoconf "http://www.gnu.org/software/autoconf/">
<!ENTITY url.autoconf.ftp "ftp://ftp.gnu.org/gnu/autoconf/">
<!ENTITY url.rpm "http://www.rpm.org/">
<!ENTITY url.docbookmirror1 "ftp://ftp.freesoftware.com/pub/sourceware/docbook-tools/docware/SRPMS/">
<!ENTITY url.docbookmirror2 "ftp://sourceware.cygnus.com/pub/docbook-tools/docware/SRPMS/">
<!ENTITY url.win.cygwin "http://www.cygwin.com/">
<!ENTITY url.iso.entities "http://jeroen.a-eskwadraat.nl/iso-entities.zip">
<!ENTITY url.docbook.appa "http://www.oasis-open.org/docbook/documentation/reference/html/appa.html">
<!-- For CVS section --><!ENTITY url.cvs "http://ximbiot.com/cvs/wiki/">
<!-- Auth_RADIUS --><!ENTITY url.auth_radius.pecl "http://pecl.php.net/package/radius">
<!-- LiveUser --><!ENTITY url.liveuser.wiki "http://wiki.pooteeweet.org/LiveUser/">
<!ENTITY url.liveuser.wiki.references "http://wiki.pooteeweet.org/LiveUser/References">
<!ENTITY url.liveuser.wiki.roadmap.client "http://wiki.pooteeweet.org/LiveUser/Client">
<!ENTITY url.liveuser.wiki.roadmap.admin "http://wiki.pooteeweet.org/LiveUser/Admin">
<!ENTITY url.liveuser.phpmag.article1 "http://web.archive.org/web/20071218224817/http://www.php-mag.net/magphpde/magphpde_article/psecom,id,595,nodeid,21.html">
<!ENTITY url.liveuser.wiki.admin.api "http://wiki.pooteeweet.org/LiveUser/AdminFilters">
<!ENTITY url.liveuser.backendmedia.dbschema "http://www.backendmedia.com/LiveUser/liveuser_db_schema.png">
<!ENTITY url.liveuser.jystewart.config "http://jystewart.net/process/archives/2005/07/configuring-liveuser/">
<!ENTITY url.liveuser.jystewart.start "http://jystewart.net/process/archives/2005/08/getting-started-with-liveuser-permissions/">
<!ENTITY url.liveuser.wiki.observer "http://wiki.pooteeweet.org/LiveUser/Observers">
<!ENTITY url.liveuser.gvngroup.be.intro "http://www.gvngroup.be/doc/LiveUser/index.php">
<!ENTITY url.liveuser.gvngroup.be.admin.intro "http://www.gvngroup.be/doc/LiveUser_Admin/index.php">
<!-- MDB2 --><!ENTITY url.mdb2.searchDrivers "http://pear.php.net/search.php?q=mdb2_Driver&amp;in=packages">
<!-- HTML_CSS --><!ENTITY url.maxdesign "http://css.maxdesign.com.au/index.htm">
<!-- HTML_QuickForm --><!ENTITY url.html_quickform.tutorial1 "http://www.midnighthax.com/quickform.php">
<!-- HTML_QuickForm_Renderer_Tableless --><!ENTITY url.html_quickform_renderer_tableless.tutorial1 "http://www.markwiesemann.eu/2006/12/27/howto-adding-explainations-next-to-form-fields-with-tableless-quickform-renderer/">
<!ENTITY url.html_quickform_renderer_tableless.tutorial2 "http://www.markwiesemann.eu/2007/12/23/using-the-tableless-renderer-together-with-html_quickform_controller/">
<!-- HTML_Table --><!ENTITY url.html_table.javascript.sorting "http://www.kryogenix.org/code/browser/sorttable/">
<!ENTITY url.html_table.javascript.sorting2 "http://www.workingwith.me.uk/articles/scripting/standardista_table_sorting">
<!ENTITY url.html_table.api.html_common "http://pear.php.net/package/HTML_Common/docs/latest/HTML_Common/HTML_Common.html">
<!-- Log --><!ENTITY url.log.home "http://www.indelible.org/php/Log/">
<!-- Net_SMTP --><!ENTITY url.net_smtp.home "http://www.indelible.org/php/Net_SMTP/">
<!-- Text_Wiki --><!ENTITY url.text_wiki.wiki "http://pear.reversefold.com/dokuwiki/text_wiki">
<!ENTITY url.qa.cweiske.overview "http://pear.cweiske.de/overview.htm">
<!ENTITY url.qa.coverage "http://pear.cweiske.de/coverage/">
<!ENTITY url.qa.packagestatus "http://pear.cweiske.de/packagestatus/">
<!-- For links to the API documentation generated by phpdocumentor --><!ENTITY phpdocbase.html-page2 "http://pear.php.net/package/HTML_Page2/docs/latest/HTML_Page2/HTML_Page2.html#method">
<!ENTITY phpdocbase.console-color "http://pear.php.net/package/Console_Color/docs/latest/Console_Color/Console_Color.html#method">
<!ENTITY phpdocbase.console-progressbar "http://pear.php.net/package/Console_ProgressBar/docs/latest/Console_ProgressBar/Console_ProgressBar.html#method">
<!ENTITY phpdocbase.datetime-date "http://pear.php.net/package/Date/docs/latest/Date/Date.html">
<!ENTITY phpdocbase.datetime-date.method "http://pear.php.net/package/Date/docs/latest/Date/Date.html#class_methods">
<!ENTITY phpdocbase.datetime-date_span.method "http://pear.php.net/package/Date/docs/latest/Date/Date_Span.html#class_methods">
<!ENTITY phpdocbase.datetime-date_timezone.method "http://pear.php.net/package/Date/docs/latest/Date/Date_TimeZone.html#class_methods">
<!ENTITY phpdocbase.games-chess "http://pear.php.net/package/Games_Chess/docs/latest/Games_Chess/">
<!ENTITY phpdocbase.image-image_transform "http://pear.php.net/package/Image_Transform/docs/latest/Image_Transform/Image_Transform.html#method">
<!ENTITY phpdocbase.crypt-gpg.method "http://pear.php.net/package/Crypt_GPG/docs/latest/Crypt_GPG/Crypt_GPG.html#method">
<!ENTITY phpdocbase.crypt-gpg_signature.method "http://pear.php.net/package/Crypt_GPG/docs/latest/Crypt_GPG/Crypt_GPG_Signature.html#method">
<!ENTITY phpdocbase.services-akismet2.method "http://pear.php.net/package/Services_Akismet2/docs/latest/Services_Akismet2/Services_Akismet2.html#method">
<!ENTITY phpdocbase.services-akismet2_invalidapikeyexception "http://pear.php.net/package/Services_Akismet2/docs/latest/Services_Akismet2/Services_Akismet2_InvalidApiKeyException.html">
<!ENTITY phpdocbase.services-akismet2_comment "http://pear.php.net/package/Services_Akismet2/docs/latest/Services_Akismet2/Services_Akismet2_Comment.html">
<!ENTITY phpdocbase.services-akismet2_comment.method "http://pear.php.net/package/Services_Akismet2/docs/latest/Services_Akismet2/Services_Akismet2_Comment.html#method">
<!-- DON'T TOUCH - AUTOGENERATED BY configure.php --><!ENTITY bookinfo SYSTEM "en/bookinfo.xml">
<!ENTITY copyright SYSTEM "en/copyright.xml">
<!ENTITY preface SYSTEM "en/preface.xml">
<!ENTITY translators SYSTEM "en/translators.xml">
<!ENTITY channels.scs SYSTEM "en/channels/scs.xml">
<!ENTITY channels.whatarethey SYSTEM "en/channels/whatarethey.xml">
<!ENTITY core.pear SYSTEM "en/core/pear.xml">
<!ENTITY core.ppm SYSTEM "en/core/ppm.xml">
<!ENTITY core.rest SYSTEM "en/core/rest.xml">
<!ENTITY pyrus.about SYSTEM "en/pyrus/about.xml">
<!ENTITY pyrus.commands SYSTEM "en/pyrus/commands.xml">
<!ENTITY pyrus.configuration SYSTEM "en/pyrus/configuration.xml">
<!ENTITY pyrus.developers SYSTEM "en/pyrus/developers.xml">
<!ENTITY pyrus.differences SYSTEM "en/pyrus/differences.xml">
<!ENTITY pyrus.extending SYSTEM "en/pyrus/extending.xml">
<!ENTITY pyrus.plugins SYSTEM "en/pyrus/plugins.xml">
<!ENTITY authoring.package.categorie SYSTEM "en/authoring/package/categorie.xml">
<!ENTITY channels.scs.commands SYSTEM "en/channels/scs/commands.xml">
<!ENTITY channels.scs.intro SYSTEM "en/channels/scs/intro.xml">
<!ENTITY core.pear.pear-errorstack SYSTEM "en/core/pear/pear-errorstack.xml">
<!ENTITY core.pear.pear-error SYSTEM "en/core/pear/pear-error.xml">
<!ENTITY core.pear.pear-exception SYSTEM "en/core/pear/pear-exception.xml">
<!ENTITY core.pear.pear SYSTEM "en/core/pear/pear.xml">
<!ENTITY core.pear.system SYSTEM "en/core/pear/system.xml">
<!ENTITY core.ppm.pear-autoloader SYSTEM "en/core/ppm/pear-autoloader.xml">
<!ENTITY core.ppm.pear-builder SYSTEM "en/core/ppm/pear-builder.xml">
<!ENTITY core.ppm.pear-channelfile SYSTEM "en/core/ppm/pear-channelfile.xml">
<!ENTITY core.ppm.pear-command SYSTEM "en/core/ppm/pear-command.xml">
<!ENTITY core.ppm.pear-common SYSTEM "en/core/ppm/pear-common.xml">
<!ENTITY core.ppm.pear-config SYSTEM "en/core/ppm/pear-config.xml">
<!ENTITY core.ppm.pear-dependency2 SYSTEM "en/core/ppm/pear-dependency2.xml">
<!ENTITY core.ppm.pear-dependencydb SYSTEM "en/core/ppm/pear-dependencydb.xml">
<!ENTITY core.ppm.pear-dependency SYSTEM "en/core/ppm/pear-dependency.xml">
<!ENTITY core.ppm.pear-frontend SYSTEM "en/core/ppm/pear-frontend.xml">
<!ENTITY core.ppm.pear-installer SYSTEM "en/core/ppm/pear-installer.xml">
<!ENTITY core.ppm.pear-packagefile SYSTEM "en/core/ppm/pear-packagefile.xml">
<!ENTITY core.ppm.pear-packager SYSTEM "en/core/ppm/pear-packager.xml">
<!ENTITY core.ppm.pear-registry SYSTEM "en/core/ppm/pear-registry.xml">
<!ENTITY core.ppm.pear-remote SYSTEM "en/core/ppm/pear-remote.xml">
<!ENTITY core.ppm.pear-rest SYSTEM "en/core/ppm/pear-rest.xml">
<!ENTITY core.ppm.pear-runtest SYSTEM "en/core/ppm/pear-runtest.xml">
<!ENTITY core.ppm.pear-validate SYSTEM "en/core/ppm/pear-validate.xml">
<!ENTITY core.ppm.pear-xmlparser SYSTEM "en/core/ppm/pear-xmlparser.xml">
<!ENTITY core.rest.channelserversoftware SYSTEM "en/core/rest/channelserversoftware.xml">
<!ENTITY core.rest.directorystructure SYSTEM "en/core/rest/directorystructure.xml">
<!ENTITY core.rest.fileformats SYSTEM "en/core/rest/fileformats.xml">
<!ENTITY core.rest.history SYSTEM "en/core/rest/history.xml">
<!ENTITY core.rest.usecases SYSTEM "en/core/rest/usecases.xml">
<!ENTITY guide.developers.package2 SYSTEM "en/guide/developers/package2.xml">
<!ENTITY guide.developers.packagedef SYSTEM "en/guide/developers/packagedef.xml">
<!ENTITY guide.users.concepts SYSTEM "en/guide/users/concepts.xml">
<!ENTITY guide.users.installation-entities SYSTEM "en/guide/users/installation-entities.xml">
<!ENTITY guide.users.installationpyrus SYSTEM "en/guide/users/installationpyrus.xml">
<!ENTITY pyrus.about.whatis SYSTEM "en/pyrus/about/whatis.xml">
<!ENTITY pyrus.commands.build SYSTEM "en/pyrus/commands/build.xml">
<!ENTITY pyrus.commands.channeladd SYSTEM "en/pyrus/commands/channeladd.xml">
<!ENTITY pyrus.commands.channeldel SYSTEM "en/pyrus/commands/channeldel.xml">
<!ENTITY pyrus.commands.channeldiscover SYSTEM "en/pyrus/commands/channeldiscover.xml">
<!ENTITY pyrus.commands.configshow SYSTEM "en/pyrus/commands/configshow.xml">
<!ENTITY pyrus.commands.download SYSTEM "en/pyrus/commands/download.xml">
<!ENTITY pyrus.commands.generateext SYSTEM "en/pyrus/commands/generateext.xml">
<!ENTITY pyrus.commands.generatepear2 SYSTEM "en/pyrus/commands/generatepear2.xml">
<!ENTITY pyrus.commands.help SYSTEM "en/pyrus/commands/help.xml">
<!ENTITY pyrus.commands.info SYSTEM "en/pyrus/commands/info.xml">
<!ENTITY pyrus.commands.install SYSTEM "en/pyrus/commands/install.xml">
<!ENTITY pyrus.commands.listchannels SYSTEM "en/pyrus/commands/listchannels.xml">
<!ENTITY pyrus.commands.listpackages SYSTEM "en/pyrus/commands/listpackages.xml">
<!ENTITY pyrus.commands.listupgrades SYSTEM "en/pyrus/commands/listupgrades.xml">
<!ENTITY pyrus.commands.make SYSTEM "en/pyrus/commands/make.xml">
<!ENTITY pyrus.commands.mypear SYSTEM "en/pyrus/commands/mypear.xml">
<!ENTITY pyrus.commands.package SYSTEM "en/pyrus/commands/package.xml">
<!ENTITY pyrus.commands.pickle SYSTEM "en/pyrus/commands/pickle.xml">
<!ENTITY pyrus.commands.remotelist SYSTEM "en/pyrus/commands/remotelist.xml">
<!ENTITY pyrus.commands.runphpt SYSTEM "en/pyrus/commands/runphpt.xml">
<!ENTITY pyrus.commands.runscripts SYSTEM "en/pyrus/commands/runscripts.xml">
<!ENTITY pyrus.commands.set SYSTEM "en/pyrus/commands/set.xml">
<!ENTITY pyrus.commands.uninstall SYSTEM "en/pyrus/commands/uninstall.xml">
<!ENTITY pyrus.commands.upgraderegistry SYSTEM "en/pyrus/commands/upgraderegistry.xml">
<!ENTITY pyrus.commands.upgrade SYSTEM "en/pyrus/commands/upgrade.xml">
<!ENTITY pyrus.configuration.system SYSTEM "en/pyrus/configuration/system.xml">
<!ENTITY pyrus.configuration.user SYSTEM "en/pyrus/configuration/user.xml">
<!ENTITY pyrus.developers.pear2 SYSTEM "en/pyrus/developers/pear2.xml">
<!ENTITY pyrus.developers.pear SYSTEM "en/pyrus/developers/pear.xml">
<!ENTITY pyrus.developers.pecl SYSTEM "en/pyrus/developers/pecl.xml">
<!ENTITY pyrus.differences.customcommands SYSTEM "en/pyrus/differences/customcommands.xml">
<!ENTITY pyrus.differences.customroles SYSTEM "en/pyrus/differences/customroles.xml">
<!ENTITY pyrus.differences.customtasks SYSTEM "en/pyrus/differences/customtasks.xml">
<!ENTITY pyrus.differences.frompear SYSTEM "en/pyrus/differences/frompear.xml">
<!ENTITY pyrus.differences.postinstallscripts SYSTEM "en/pyrus/differences/postinstallscripts.xml">
<!ENTITY pyrus.extending.configuration SYSTEM "en/pyrus/extending/configuration.xml">
<!ENTITY pyrus.extending.installation SYSTEM "en/pyrus/extending/installation.xml">
<!ENTITY pyrus.extending.packagefile SYSTEM "en/pyrus/extending/packagefile.xml">
<!ENTITY pyrus.extending.registry SYSTEM "en/pyrus/extending/registry.xml">
<!ENTITY pyrus.plugins.command SYSTEM "en/pyrus/plugins/command.xml">
<!ENTITY pyrus.plugins.role SYSTEM "en/pyrus/plugins/role.xml">
<!ENTITY pyrus.plugins.task SYSTEM "en/pyrus/plugins/task.xml">
<!ENTITY authoring.package.categorie.mypackage SYSTEM "en/authoring/package/categorie/mypackage.xml">
<!ENTITY channels.scs.commands.addcategory SYSTEM "en/channels/scs/commands/addcategory.xml">
<!ENTITY channels.scs.commands.addmaintainer SYSTEM "en/channels/scs/commands/addmaintainer.xml">
<!ENTITY channels.scs.commands.create SYSTEM "en/channels/scs/commands/create.xml">
<!ENTITY channels.scs.commands.release SYSTEM "en/channels/scs/commands/release.xml">
<!ENTITY channels.scs.commands.update SYSTEM "en/channels/scs/commands/update.xml">
<!ENTITY core.pear.pear.constants SYSTEM "en/core/pear/pear/constants.xml">
<!ENTITY core.pear.pear-error.adduserinfo SYSTEM "en/core/pear/pear-error/adduserinfo.xml">
<!ENTITY core.pear.pear-error.getcallback SYSTEM "en/core/pear/pear-error/getcallback.xml">
<!ENTITY core.pear.pear-error.getcode SYSTEM "en/core/pear/pear-error/getcode.xml">
<!ENTITY core.pear.pear-error.getdebuginfo SYSTEM "en/core/pear/pear-error/getdebuginfo.xml">
<!ENTITY core.pear.pear-error.getmessage SYSTEM "en/core/pear/pear-error/getmessage.xml">
<!ENTITY core.pear.pear-error.getmode SYSTEM "en/core/pear/pear-error/getmode.xml">
<!ENTITY core.pear.pear-error.gettype SYSTEM "en/core/pear/pear-error/gettype.xml">
<!ENTITY core.pear.pear-error.getuserinfo SYSTEM "en/core/pear/pear-error/getuserinfo.xml">
<!ENTITY core.pear.pear-error.pear-error SYSTEM "en/core/pear/pear-error/pear-error.xml">
<!ENTITY core.pear.pear-errorstack.constants SYSTEM "en/core/pear/pear-errorstack/constants.xml">
<!ENTITY core.pear.pear-errorstack.geterrormessagetemplate SYSTEM "en/core/pear/pear-errorstack/geterrormessagetemplate.xml">
<!ENTITY core.pear.pear-errorstack.geterrormessage SYSTEM "en/core/pear/pear-errorstack/geterrormessage.xml">
<!ENTITY core.pear.pear-errorstack.geterrors SYSTEM "en/core/pear/pear-errorstack/geterrors.xml">
<!ENTITY core.pear.pear-errorstack.getfileline SYSTEM "en/core/pear/pear-errorstack/getfileline.xml">
<!ENTITY core.pear.pear-errorstack.getmessagecallback SYSTEM "en/core/pear/pear-errorstack/getmessagecallback.xml">
<!ENTITY core.pear.pear-errorstack.haserrors SYSTEM "en/core/pear/pear-errorstack/haserrors.xml">
<!ENTITY core.pear.pear-errorstack.intro SYSTEM "en/core/pear/pear-errorstack/intro.xml">
<!ENTITY core.pear.pear-errorstack.-log SYSTEM "en/core/pear/pear-errorstack/-log.xml">
<!ENTITY core.pear.pear-errorstack.pear-errorstack SYSTEM "en/core/pear/pear-errorstack/pear-errorstack.xml">
<!ENTITY core.pear.pear-errorstack.popcallback SYSTEM "en/core/pear/pear-errorstack/popcallback.xml">
<!ENTITY core.pear.pear-errorstack.pop SYSTEM "en/core/pear/pear-errorstack/pop.xml">
<!ENTITY core.pear.pear-errorstack.pushcallback SYSTEM "en/core/pear/pear-errorstack/pushcallback.xml">
<!ENTITY core.pear.pear-errorstack.push SYSTEM "en/core/pear/pear-errorstack/push.xml">
<!ENTITY core.pear.pear-errorstack.raiseerror SYSTEM "en/core/pear/pear-errorstack/raiseerror.xml">
<!ENTITY core.pear.pear-errorstack.setcontextcallback SYSTEM "en/core/pear/pear-errorstack/setcontextcallback.xml">
<!ENTITY core.pear.pear-errorstack.setdefaultcallback SYSTEM "en/core/pear/pear-errorstack/setdefaultcallback.xml">
<!ENTITY core.pear.pear-errorstack.setdefaultlogger SYSTEM "en/core/pear/pear-errorstack/setdefaultlogger.xml">
<!ENTITY core.pear.pear-errorstack.seterrormessagetemplate SYSTEM "en/core/pear/pear-errorstack/seterrormessagetemplate.xml">
<!ENTITY core.pear.pear-errorstack.setlogger SYSTEM "en/core/pear/pear-errorstack/setlogger.xml">
<!ENTITY core.pear.pear-errorstack.setmessagecallback SYSTEM "en/core/pear/pear-errorstack/setmessagecallback.xml">
<!ENTITY core.pear.pear-errorstack.singleton SYSTEM "en/core/pear/pear-errorstack/singleton.xml">
<!ENTITY core.pear.pear-errorstack.staticgeterrors SYSTEM "en/core/pear/pear-errorstack/staticgeterrors.xml">
<!ENTITY core.pear.pear-errorstack.statichaserrors SYSTEM "en/core/pear/pear-errorstack/statichaserrors.xml">
<!ENTITY core.pear.pear-errorstack.staticpopcallback SYSTEM "en/core/pear/pear-errorstack/staticpopcallback.xml">
<!ENTITY core.pear.pear-errorstack.staticpop SYSTEM "en/core/pear/pear-errorstack/staticpop.xml">
<!ENTITY core.pear.pear-errorstack.staticpushcallback SYSTEM "en/core/pear/pear-errorstack/staticpushcallback.xml">
<!ENTITY core.pear.pear-errorstack.staticpush SYSTEM "en/core/pear/pear-errorstack/staticpush.xml">
<!ENTITY core.pear.pear-error.tostring SYSTEM "en/core/pear/pear-error/tostring.xml">
<!ENTITY core.pear.pear-exception.intro SYSTEM "en/core/pear/pear-exception/intro.xml">
<!ENTITY core.pear.pear.expecterror SYSTEM "en/core/pear/pear/expecterror.xml">
<!ENTITY core.pear.pear.getstaticproperty SYSTEM "en/core/pear/pear/getstaticproperty.xml">
<!ENTITY core.pear.pear.intro SYSTEM "en/core/pear/pear/intro.xml">
<!ENTITY core.pear.pear.iserror SYSTEM "en/core/pear/pear/iserror.xml">
<!ENTITY core.pear.pear.loadextension SYSTEM "en/core/pear/pear/loadextension.xml">
<!ENTITY core.pear.pear.-pear SYSTEM "en/core/pear/pear/-pear.xml">
<!ENTITY core.pear.pear.pear SYSTEM "en/core/pear/pear/pear.xml">
<!ENTITY core.pear.pear.popexpect SYSTEM "en/core/pear/pear/popexpect.xml">
<!ENTITY core.pear.pear.raiseerror SYSTEM "en/core/pear/pear/raiseerror.xml">
<!ENTITY core.pear.pear.registershutdownfunction SYSTEM "en/core/pear/pear/registershutdownfunction.xml">
<!ENTITY core.pear.pear.seterrorhandling SYSTEM "en/core/pear/pear/seterrorhandling.xml">
<!ENTITY core.pear.system.cat SYSTEM "en/core/pear/system/cat.xml">
<!ENTITY core.pear.system.intro SYSTEM "en/core/pear/system/intro.xml">
<!ENTITY core.pear.system.mkdir SYSTEM "en/core/pear/system/mkdir.xml">
<!ENTITY core.pear.system.mktemp SYSTEM "en/core/pear/system/mktemp.xml">
<!ENTITY core.pear.system.rm SYSTEM "en/core/pear/system/rm.xml">
<!ENTITY core.pear.system.tmpdir SYSTEM "en/core/pear/system/tmpdir.xml">
<!ENTITY core.pear.system.which SYSTEM "en/core/pear/system/which.xml">
<!ENTITY core.ppm.pear-autoloader.addaggregateobject SYSTEM "en/core/ppm/pear-autoloader/addaggregateobject.xml">
<!ENTITY core.ppm.pear-autoloader.addautoload SYSTEM "en/core/ppm/pear-autoloader/addautoload.xml">
<!ENTITY core.ppm.pear-autoloader.--call SYSTEM "en/core/ppm/pear-autoloader/--call.xml">
<!ENTITY core.ppm.pear-autoloader.removeaggregateobject SYSTEM "en/core/ppm/pear-autoloader/removeaggregateobject.xml">
<!ENTITY core.ppm.pear-autoloader.removeautoload SYSTEM "en/core/ppm/pear-autoloader/removeautoload.xml">
<!ENTITY core.ppm.pear-builder.build SYSTEM "en/core/ppm/pear-builder/build.xml">
<!ENTITY core.ppm.pear-builder.log SYSTEM "en/core/ppm/pear-builder/log.xml">
<!ENTITY core.ppm.pear-builder.pear-builder SYSTEM "en/core/ppm/pear-builder/pear-builder.xml">
<!ENTITY core.ppm.pear-builder.phpizecallback SYSTEM "en/core/ppm/pear-builder/phpizecallback.xml">
<!ENTITY core.ppm.pear-channelfile.addfunction SYSTEM "en/core/ppm/pear-channelfile/addfunction.xml">
<!ENTITY core.ppm.pear-channelfile.addmirrorfunction SYSTEM "en/core/ppm/pear-channelfile/addmirrorfunction.xml">
<!ENTITY core.ppm.pear-channelfile.addmirror SYSTEM "en/core/ppm/pear-channelfile/addmirror.xml">
<!ENTITY core.ppm.pear-channelfile.constants SYSTEM "en/core/ppm/pear-channelfile/constants.xml">
<!ENTITY core.ppm.pear-channelfile.fromany SYSTEM "en/core/ppm/pear-channelfile/fromany.xml">
<!ENTITY core.ppm.pear-channelfile.fromarray SYSTEM "en/core/ppm/pear-channelfile/fromarray.xml">
<!ENTITY core.ppm.pear-channelfile.fromxmlfile SYSTEM "en/core/ppm/pear-channelfile/fromxmlfile.xml">
<!ENTITY core.ppm.pear-channelfile.fromxmlstring SYSTEM "en/core/ppm/pear-channelfile/fromxmlstring.xml">
<!ENTITY core.ppm.pear-channelfile.getalias SYSTEM "en/core/ppm/pear-channelfile/getalias.xml">
<!ENTITY core.ppm.pear-channelfile.getbaseurl SYSTEM "en/core/ppm/pear-channelfile/getbaseurl.xml">
<!ENTITY core.ppm.pear-channelfile.geterrors SYSTEM "en/core/ppm/pear-channelfile/geterrors.xml">
<!ENTITY core.ppm.pear-channelfile.getfunctions SYSTEM "en/core/ppm/pear-channelfile/getfunctions.xml">
<!ENTITY core.ppm.pear-channelfile.getfunction SYSTEM "en/core/ppm/pear-channelfile/getfunction.xml">
<!ENTITY core.ppm.pear-channelfile.getmirrors SYSTEM "en/core/ppm/pear-channelfile/getmirrors.xml">
<!ENTITY core.ppm.pear-channelfile.getmirror SYSTEM "en/core/ppm/pear-channelfile/getmirror.xml">
<!ENTITY core.ppm.pear-channelfile.getname SYSTEM "en/core/ppm/pear-channelfile/getname.xml">
<!ENTITY core.ppm.pear-channelfile.getpath SYSTEM "en/core/ppm/pear-channelfile/getpath.xml">
<!ENTITY core.ppm.pear-channelfile.getport SYSTEM "en/core/ppm/pear-channelfile/getport.xml">
<!ENTITY core.ppm.pear-channelfile.getserver SYSTEM "en/core/ppm/pear-channelfile/getserver.xml">
<!ENTITY core.ppm.pear-channelfile.getssl SYSTEM "en/core/ppm/pear-channelfile/getssl.xml">
<!ENTITY core.ppm.pear-channelfile.getsummary SYSTEM "en/core/ppm/pear-channelfile/getsummary.xml">
<!ENTITY core.ppm.pear-channelfile.getvalidationobject SYSTEM "en/core/ppm/pear-channelfile/getvalidationobject.xml">
<!ENTITY core.ppm.pear-channelfile.getvalidationpackage SYSTEM "en/core/ppm/pear-channelfile/getvalidationpackage.xml">
<!ENTITY core.ppm.pear-channelfile.isincludeable SYSTEM "en/core/ppm/pear-channelfile/isincludeable.xml">
<!ENTITY core.ppm.pear-channelfile.lastmodified SYSTEM "en/core/ppm/pear-channelfile/lastmodified.xml">
<!ENTITY core.ppm.pear-channelfile.pear-channelfile SYSTEM "en/core/ppm/pear-channelfile/pear-channelfile.xml">
<!ENTITY core.ppm.pear-channelfile.resetfunctions SYSTEM "en/core/ppm/pear-channelfile/resetfunctions.xml">
<!ENTITY core.ppm.pear-channelfile.resetrest SYSTEM "en/core/ppm/pear-channelfile/resetrest.xml">
<!ENTITY core.ppm.pear-channelfile.setalias SYSTEM "en/core/ppm/pear-channelfile/setalias.xml">
<!ENTITY core.ppm.pear-channelfile.setbaseurl SYSTEM "en/core/ppm/pear-channelfile/setbaseurl.xml">
<!ENTITY core.ppm.pear-channelfile.setdefaultpearprotocols SYSTEM "en/core/ppm/pear-channelfile/setdefaultpearprotocols.xml">
<!ENTITY core.ppm.pear-channelfile.setname SYSTEM "en/core/ppm/pear-channelfile/setname.xml">
<!ENTITY core.ppm.pear-channelfile.setpath SYSTEM "en/core/ppm/pear-channelfile/setpath.xml">
<!ENTITY core.ppm.pear-channelfile.setport SYSTEM "en/core/ppm/pear-channelfile/setport.xml">
<!ENTITY core.ppm.pear-channelfile.setserver SYSTEM "en/core/ppm/pear-channelfile/setserver.xml">
<!ENTITY core.ppm.pear-channelfile.setssl SYSTEM "en/core/ppm/pear-channelfile/setssl.xml">
<!ENTITY core.ppm.pear-channelfile.setsummary SYSTEM "en/core/ppm/pear-channelfile/setsummary.xml">
<!ENTITY core.ppm.pear-channelfile.setvalidationpackage SYSTEM "en/core/ppm/pear-channelfile/setvalidationpackage.xml">
<!ENTITY core.ppm.pear-channelfile.supportsrest SYSTEM "en/core/ppm/pear-channelfile/supportsrest.xml">
<!ENTITY core.ppm.pear-channelfile.supports SYSTEM "en/core/ppm/pear-channelfile/supports.xml">
<!ENTITY core.ppm.pear-channelfile.toarray SYSTEM "en/core/ppm/pear-channelfile/toarray.xml">
<!ENTITY core.ppm.pear-channelfile.toxml SYSTEM "en/core/ppm/pear-channelfile/toxml.xml">
<!ENTITY core.ppm.pear-channelfile.validate SYSTEM "en/core/ppm/pear-channelfile/validate.xml">
<!ENTITY core.ppm.pear-channelfile.validchannelserver SYSTEM "en/core/ppm/pear-channelfile/validchannelserver.xml">
<!ENTITY core.ppm.pear-command.factory SYSTEM "en/core/ppm/pear-command/factory.xml">
<!ENTITY core.ppm.pear-command.getcommands SYSTEM "en/core/ppm/pear-command/getcommands.xml">
<!ENTITY core.ppm.pear-command.getdescription SYSTEM "en/core/ppm/pear-command/getdescription.xml">
<!ENTITY core.ppm.pear-command.getgetoptargs SYSTEM "en/core/ppm/pear-command/getgetoptargs.xml">
<!ENTITY core.ppm.pear-command.gethelp SYSTEM "en/core/ppm/pear-command/gethelp.xml">
<!ENTITY core.ppm.pear-command.getshortcuts SYSTEM "en/core/ppm/pear-command/getshortcuts.xml">
<!ENTITY core.ppm.pear-command.registercommands SYSTEM "en/core/ppm/pear-command/registercommands.xml">
<!ENTITY core.ppm.pear-common.addtempfile SYSTEM "en/core/ppm/pear-common/addtempfile.xml">
<!ENTITY core.ppm.pear-common.analyzesourcecode SYSTEM "en/core/ppm/pear-common/analyzesourcecode.xml">
<!ENTITY core.ppm.pear-common.buildprovidesarray SYSTEM "en/core/ppm/pear-common/buildprovidesarray.xml">
<!ENTITY core.ppm.pear-common.downloadhttp SYSTEM "en/core/ppm/pear-common/downloadhttp.xml">
<!ENTITY core.ppm.pear-common.infofromany SYSTEM "en/core/ppm/pear-common/infofromany.xml">
<!ENTITY core.ppm.pear-common.infofromdescriptionfile SYSTEM "en/core/ppm/pear-common/infofromdescriptionfile.xml">
<!ENTITY core.ppm.pear-common.infofromstring SYSTEM "en/core/ppm/pear-common/infofromstring.xml">
<!ENTITY core.ppm.pear-common.infofromtgzfile SYSTEM "en/core/ppm/pear-common/infofromtgzfile.xml">
<!ENTITY core.ppm.pear-common.log SYSTEM "en/core/ppm/pear-common/log.xml">
<!ENTITY core.ppm.pear-common.mkdirhier SYSTEM "en/core/ppm/pear-common/mkdirhier.xml">
<!ENTITY core.ppm.pear-common.mktempdir SYSTEM "en/core/ppm/pear-common/mktempdir.xml">
<!ENTITY core.ppm.pear-common.pear-common SYSTEM "en/core/ppm/pear-common/pear-common.xml">
<!ENTITY core.ppm.pear-common.setfrontendobject SYSTEM "en/core/ppm/pear-common/setfrontendobject.xml">
<!ENTITY core.ppm.pear-common.validatepackageinfo SYSTEM "en/core/ppm/pear-common/validatepackageinfo.xml">
<!ENTITY core.ppm.pear-common.validpackagename SYSTEM "en/core/ppm/pear-common/validpackagename.xml">
<!ENTITY core.ppm.pear-common.xmlfrominfo SYSTEM "en/core/ppm/pear-common/xmlfrominfo.xml">
<!ENTITY core.ppm.pear-config.apiversion SYSTEM "en/core/ppm/pear-config/apiversion.xml">
<!ENTITY core.ppm.pear-config.definedby SYSTEM "en/core/ppm/pear-config/definedby.xml">
<!ENTITY core.ppm.pear-config.deletechannel SYSTEM "en/core/ppm/pear-config/deletechannel.xml">
<!ENTITY core.ppm.pear-config.getconffile SYSTEM "en/core/ppm/pear-config/getconffile.xml">
<!ENTITY core.ppm.pear-config.getdefaultchannel SYSTEM "en/core/ppm/pear-config/getdefaultchannel.xml">
<!ENTITY core.ppm.pear-config.getdocs SYSTEM "en/core/ppm/pear-config/getdocs.xml">
<!ENTITY core.ppm.pear-config.getftp SYSTEM "en/core/ppm/pear-config/getftp.xml">
<!ENTITY core.ppm.pear-config.getgroupkeys SYSTEM "en/core/ppm/pear-config/getgroupkeys.xml">
<!ENTITY core.ppm.pear-config.getgroups SYSTEM "en/core/ppm/pear-config/getgroups.xml">
<!ENTITY core.ppm.pear-config.getgroup SYSTEM "en/core/ppm/pear-config/getgroup.xml">
<!ENTITY core.ppm.pear-config.getkeys SYSTEM "en/core/ppm/pear-config/getkeys.xml">
<!ENTITY core.ppm.pear-config.getlayers SYSTEM "en/core/ppm/pear-config/getlayers.xml">
<!ENTITY core.ppm.pear-config.getprompt SYSTEM "en/core/ppm/pear-config/getprompt.xml">
<!ENTITY core.ppm.pear-config.getregistry SYSTEM "en/core/ppm/pear-config/getregistry.xml">
<!ENTITY core.ppm.pear-config.getremote SYSTEM "en/core/ppm/pear-config/getremote.xml">
<!ENTITY core.ppm.pear-config.getrest SYSTEM "en/core/ppm/pear-config/getrest.xml">
<!ENTITY core.ppm.pear-config.getsetvalues SYSTEM "en/core/ppm/pear-config/getsetvalues.xml">
<!ENTITY core.ppm.pear-config.gettype SYSTEM "en/core/ppm/pear-config/gettype.xml">
<!ENTITY core.ppm.pear-config.get SYSTEM "en/core/ppm/pear-config/get.xml">
<!ENTITY core.ppm.pear-config.isdefinedlayer SYSTEM "en/core/ppm/pear-config/isdefinedlayer.xml">
<!ENTITY core.ppm.pear-config.isdefined SYSTEM "en/core/ppm/pear-config/isdefined.xml">
<!ENTITY core.ppm.pear-config.mergeconfigfile SYSTEM "en/core/ppm/pear-config/mergeconfigfile.xml">
<!ENTITY core.ppm.pear-config.noregistry SYSTEM "en/core/ppm/pear-config/noregistry.xml">
<!ENTITY core.ppm.pear-config.pear-config SYSTEM "en/core/ppm/pear-config/pear-config.xml">
<!ENTITY core.ppm.pear-config.readconfigfile SYSTEM "en/core/ppm/pear-config/readconfigfile.xml">
<!ENTITY core.ppm.pear-config.readftpconfigfile SYSTEM "en/core/ppm/pear-config/readftpconfigfile.xml">
<!ENTITY core.ppm.pear-config.removelayer SYSTEM "en/core/ppm/pear-config/removelayer.xml">
<!ENTITY core.ppm.pear-config.remove SYSTEM "en/core/ppm/pear-config/remove.xml">
<!ENTITY core.ppm.pear-config.setchannels SYSTEM "en/core/ppm/pear-config/setchannels.xml">
<!ENTITY core.ppm.pear-config.setinstallroot SYSTEM "en/core/ppm/pear-config/setinstallroot.xml">
<!ENTITY core.ppm.pear-config.setregistry SYSTEM "en/core/ppm/pear-config/setregistry.xml">
<!ENTITY core.ppm.pear-config.set SYSTEM "en/core/ppm/pear-config/set.xml">
<!ENTITY core.ppm.pear-config.singleton SYSTEM "en/core/ppm/pear-config/singleton.xml">
<!ENTITY core.ppm.pear-config.store SYSTEM "en/core/ppm/pear-config/store.xml">
<!ENTITY core.ppm.pear-config.todefault SYSTEM "en/core/ppm/pear-config/todefault.xml">
<!ENTITY core.ppm.pear-config.validconfiguration SYSTEM "en/core/ppm/pear-config/validconfiguration.xml">
<!ENTITY core.ppm.pear-config.writeconfigfile SYSTEM "en/core/ppm/pear-config/writeconfigfile.xml">
<!ENTITY core.ppm.pear-dependency2.normalizedep SYSTEM "en/core/ppm/pear-dependency2/normalizedep.xml">
<!ENTITY core.ppm.pear-dependency2.pear-dependency2 SYSTEM "en/core/ppm/pear-dependency2/pear-dependency2.xml">
<!ENTITY core.ppm.pear-dependency2.validatearchdependency SYSTEM "en/core/ppm/pear-dependency2/validatearchdependency.xml">
<!ENTITY core.ppm.pear-dependency2.validatedependency1 SYSTEM "en/core/ppm/pear-dependency2/validatedependency1.xml">
<!ENTITY core.ppm.pear-dependency2.validateextensiondependency SYSTEM "en/core/ppm/pear-dependency2/validateextensiondependency.xml">
<!ENTITY core.ppm.pear-dependency2.validateosdependency SYSTEM "en/core/ppm/pear-dependency2/validateosdependency.xml">
<!ENTITY core.ppm.pear-dependency2.validatepackagedependency SYSTEM "en/core/ppm/pear-dependency2/validatepackagedependency.xml">
<!ENTITY core.ppm.pear-dependency2.validatepackageuninstall SYSTEM "en/core/ppm/pear-dependency2/validatepackageuninstall.xml">
<!ENTITY core.ppm.pear-dependency2.validatepackage SYSTEM "en/core/ppm/pear-dependency2/validatepackage.xml">
<!ENTITY core.ppm.pear-dependency2.validatepearinstallerdependency SYSTEM "en/core/ppm/pear-dependency2/validatepearinstallerdependency.xml">
<!ENTITY core.ppm.pear-dependency2.validatephpdependency SYSTEM "en/core/ppm/pear-dependency2/validatephpdependency.xml">
<!ENTITY core.ppm.pear-dependency2.validatesubpackagedependency SYSTEM "en/core/ppm/pear-dependency2/validatesubpackagedependency.xml">
<!ENTITY core.ppm.pear-dependency.callcheckmethod SYSTEM "en/core/ppm/pear-dependency/callcheckmethod.xml">
<!ENTITY core.ppm.pear-dependency.checkextension SYSTEM "en/core/ppm/pear-dependency/checkextension.xml">
<!ENTITY core.ppm.pear-dependency.checkos SYSTEM "en/core/ppm/pear-dependency/checkos.xml">
<!ENTITY core.ppm.pear-dependency.checkpackage SYSTEM "en/core/ppm/pear-dependency/checkpackage.xml">
<!ENTITY core.ppm.pear-dependency.checkphp SYSTEM "en/core/ppm/pear-dependency/checkphp.xml">
<!ENTITY core.ppm.pear-dependency.checkprogram SYSTEM "en/core/ppm/pear-dependency/checkprogram.xml">
<!ENTITY core.ppm.pear-dependency.checksapi SYSTEM "en/core/ppm/pear-dependency/checksapi.xml">
<!ENTITY core.ppm.pear-dependency.checkzend SYSTEM "en/core/ppm/pear-dependency/checkzend.xml">
<!ENTITY core.ppm.pear-dependencydb.assertdepsdb SYSTEM "en/core/ppm/pear-dependencydb/assertdepsdb.xml">
<!ENTITY core.ppm.pear-dependencydb.dependson SYSTEM "en/core/ppm/pear-dependencydb/dependson.xml">
<!ENTITY core.ppm.pear-dependencydb.getdependencies SYSTEM "en/core/ppm/pear-dependencydb/getdependencies.xml">
<!ENTITY core.ppm.pear-dependencydb.getdependentpackagedependencies SYSTEM "en/core/ppm/pear-dependencydb/getdependentpackagedependencies.xml">
<!ENTITY core.ppm.pear-dependencydb.getdependentpackages SYSTEM "en/core/ppm/pear-dependencydb/getdependentpackages.xml">
<!ENTITY core.ppm.pear-dependencydb.haswriteaccess SYSTEM "en/core/ppm/pear-dependencydb/haswriteaccess.xml">
<!ENTITY core.ppm.pear-dependencydb.installpackage SYSTEM "en/core/ppm/pear-dependencydb/installpackage.xml">
<!ENTITY core.ppm.pear-dependencydb.rebuilddb SYSTEM "en/core/ppm/pear-dependencydb/rebuilddb.xml">
<!ENTITY core.ppm.pear-dependencydb.setconfig SYSTEM "en/core/ppm/pear-dependencydb/setconfig.xml">
<!ENTITY core.ppm.pear-dependencydb.singleton SYSTEM "en/core/ppm/pear-dependencydb/singleton.xml">
<!ENTITY core.ppm.pear-dependencydb.uninstallpackage SYSTEM "en/core/ppm/pear-dependencydb/uninstallpackage.xml">
<!ENTITY core.ppm.pear-dependency.pear-dependency SYSTEM "en/core/ppm/pear-dependency/pear-dependency.xml">
<!ENTITY core.ppm.pear-frontend.addtempfile SYSTEM "en/core/ppm/pear-frontend/addtempfile.xml">
<!ENTITY core.ppm.pear-frontend.isincludeable SYSTEM "en/core/ppm/pear-frontend/isincludeable.xml">
<!ENTITY core.ppm.pear-frontend.log SYSTEM "en/core/ppm/pear-frontend/log.xml">
<!ENTITY core.ppm.pear-frontend.setconfig SYSTEM "en/core/ppm/pear-frontend/setconfig.xml">
<!ENTITY core.ppm.pear-frontend.setfrontendclass SYSTEM "en/core/ppm/pear-frontend/setfrontendclass.xml">
<!ENTITY core.ppm.pear-frontend.singleton SYSTEM "en/core/ppm/pear-frontend/singleton.xml">
<!ENTITY core.ppm.pear-installer.install SYSTEM "en/core/ppm/pear-installer/install.xml">
<!ENTITY core.ppm.pear-installer.pear-installer SYSTEM "en/core/ppm/pear-installer/pear-installer.xml">
<!ENTITY core.ppm.pear-packagefile.constants SYSTEM "en/core/ppm/pear-packagefile/constants.xml">
<!ENTITY core.ppm.pear-packagefile.factory SYSTEM "en/core/ppm/pear-packagefile/factory.xml">
<!ENTITY core.ppm.pear-packagefile.fromanyfile SYSTEM "en/core/ppm/pear-packagefile/fromanyfile.xml">
<!ENTITY core.ppm.pear-packagefile.fromarray SYSTEM "en/core/ppm/pear-packagefile/fromarray.xml">
<!ENTITY core.ppm.pear-packagefile.frompackagefile SYSTEM "en/core/ppm/pear-packagefile/frompackagefile.xml">
<!ENTITY core.ppm.pear-packagefile.fromtgzfile SYSTEM "en/core/ppm/pear-packagefile/fromtgzfile.xml">
<!ENTITY core.ppm.pear-packagefile.fromxmlstring SYSTEM "en/core/ppm/pear-packagefile/fromxmlstring.xml">
<!ENTITY core.ppm.pear-packagefile.parserfactory SYSTEM "en/core/ppm/pear-packagefile/parserfactory.xml">
<!ENTITY core.ppm.pear-packagefile.pear-packagefile SYSTEM "en/core/ppm/pear-packagefile/pear-packagefile.xml">
<!ENTITY core.ppm.pear-packagefile.rawreturn SYSTEM "en/core/ppm/pear-packagefile/rawreturn.xml">
<!ENTITY core.ppm.pear-packagefile.setlogger SYSTEM "en/core/ppm/pear-packagefile/setlogger.xml">
<!ENTITY core.ppm.pear-packager.package SYSTEM "en/core/ppm/pear-packager/package.xml">
<!ENTITY core.ppm.pear-packager.pear-packager SYSTEM "en/core/ppm/pear-packager/pear-packager.xml">
<!ENTITY core.ppm.pear-registry.addpackage SYSTEM "en/core/ppm/pear-registry/addpackage.xml">
<!ENTITY core.ppm.pear-registry.checkfilemap SYSTEM "en/core/ppm/pear-registry/checkfilemap.xml">
<!ENTITY core.ppm.pear-registry.deletepackage SYSTEM "en/core/ppm/pear-registry/deletepackage.xml">
<!ENTITY core.ppm.pear-registry.listpackages SYSTEM "en/core/ppm/pear-registry/listpackages.xml">
<!ENTITY core.ppm.pear-registry.packageexists SYSTEM "en/core/ppm/pear-registry/packageexists.xml">
<!ENTITY core.ppm.pear-registry.packageinfo SYSTEM "en/core/ppm/pear-registry/packageinfo.xml">
<!ENTITY core.ppm.pear-registry.pear-registry SYSTEM "en/core/ppm/pear-registry/pear-registry.xml">
<!ENTITY core.ppm.pear-registry.rebuilddepsfile SYSTEM "en/core/ppm/pear-registry/rebuilddepsfile.xml">
<!ENTITY core.ppm.pear-registry.rebuildfilemap SYSTEM "en/core/ppm/pear-registry/rebuildfilemap.xml">
<!ENTITY core.ppm.pear-registry.removepackagedep SYSTEM "en/core/ppm/pear-registry/removepackagedep.xml">
<!ENTITY core.ppm.pear-registry.setpackagedep SYSTEM "en/core/ppm/pear-registry/setpackagedep.xml">
<!ENTITY core.ppm.pear-registry.updatepackage SYSTEM "en/core/ppm/pear-registry/updatepackage.xml">
<!ENTITY core.ppm.pear-remote.call SYSTEM "en/core/ppm/pear-remote/call.xml">
<!ENTITY core.ppm.pear-remote.pear-remote SYSTEM "en/core/ppm/pear-remote/pear-remote.xml">
<!ENTITY core.ppm.pear-rest.downloadhttp SYSTEM "en/core/ppm/pear-rest/downloadhttp.xml">
<!ENTITY core.ppm.pear-rest.getcacheid SYSTEM "en/core/ppm/pear-rest/getcacheid.xml">
<!ENTITY core.ppm.pear-rest.getcache SYSTEM "en/core/ppm/pear-rest/getcache.xml">
<!ENTITY core.ppm.pear-rest.pear-rest SYSTEM "en/core/ppm/pear-rest/pear-rest.xml">
<!ENTITY core.ppm.pear-rest.retrievecachefirst SYSTEM "en/core/ppm/pear-rest/retrievecachefirst.xml">
<!ENTITY core.ppm.pear-rest.retrievedata SYSTEM "en/core/ppm/pear-rest/retrievedata.xml">
<!ENTITY core.ppm.pear-rest.savecache SYSTEM "en/core/ppm/pear-rest/savecache.xml">
<!ENTITY core.ppm.pear-rest.uselocalcache SYSTEM "en/core/ppm/pear-rest/uselocalcache.xml">
<!ENTITY core.ppm.pear-runtest.generate-diff SYSTEM "en/core/ppm/pear-runtest/generate-diff.xml">
<!ENTITY core.ppm.pear-runtest.pear-runtest SYSTEM "en/core/ppm/pear-runtest/pear-runtest.xml">
<!ENTITY core.ppm.pear-runtest.run SYSTEM "en/core/ppm/pear-runtest/run.xml">
<!ENTITY core.ppm.pear-validate.-addfailure SYSTEM "en/core/ppm/pear-validate/-addfailure.xml">
<!ENTITY core.ppm.pear-validate.-addwarning SYSTEM "en/core/ppm/pear-validate/-addwarning.xml">
<!ENTITY core.ppm.pear-validate.constants SYSTEM "en/core/ppm/pear-validate/constants.xml">
<!ENTITY core.ppm.pear-validate.getfailures SYSTEM "en/core/ppm/pear-validate/getfailures.xml">
<!ENTITY core.ppm.pear-validate.getvalidstates SYSTEM "en/core/ppm/pear-validate/getvalidstates.xml">
<!ENTITY core.ppm.pear-validate.setpackagefile SYSTEM "en/core/ppm/pear-validate/setpackagefile.xml">
<!ENTITY core.ppm.pear-validate.validatechangelog SYSTEM "en/core/ppm/pear-validate/validatechangelog.xml">
<!ENTITY core.ppm.pear-validate.validatedate SYSTEM "en/core/ppm/pear-validate/validatedate.xml">
<!ENTITY core.ppm.pear-validate.validatedependencies SYSTEM "en/core/ppm/pear-validate/validatedependencies.xml">
<!ENTITY core.ppm.pear-validate.validatedeps SYSTEM "en/core/ppm/pear-validate/validatedeps.xml">
<!ENTITY core.ppm.pear-validate.validatedescription SYSTEM "en/core/ppm/pear-validate/validatedescription.xml">
<!ENTITY core.ppm.pear-validate.validatefilelist SYSTEM "en/core/ppm/pear-validate/validatefilelist.xml">
<!ENTITY core.ppm.pear-validate.validatelicense SYSTEM "en/core/ppm/pear-validate/validatelicense.xml">
<!ENTITY core.ppm.pear-validate.validatemainfilelist SYSTEM "en/core/ppm/pear-validate/validatemainfilelist.xml">
<!ENTITY core.ppm.pear-validate.validatemaintainers SYSTEM "en/core/ppm/pear-validate/validatemaintainers.xml">
<!ENTITY core.ppm.pear-validate.validatenotes SYSTEM "en/core/ppm/pear-validate/validatenotes.xml">
<!ENTITY core.ppm.pear-validate.validatepackagename SYSTEM "en/core/ppm/pear-validate/validatepackagename.xml">
<!ENTITY core.ppm.pear-validate.validatereleasefilelist SYSTEM "en/core/ppm/pear-validate/validatereleasefilelist.xml">
<!ENTITY core.ppm.pear-validate.validatestability SYSTEM "en/core/ppm/pear-validate/validatestability.xml">
<!ENTITY core.ppm.pear-validate.validatestate SYSTEM "en/core/ppm/pear-validate/validatestate.xml">
<!ENTITY core.ppm.pear-validate.validatesummary SYSTEM "en/core/ppm/pear-validate/validatesummary.xml">
<!ENTITY core.ppm.pear-validate.validatetime SYSTEM "en/core/ppm/pear-validate/validatetime.xml">
<!ENTITY core.ppm.pear-validate.validateversion SYSTEM "en/core/ppm/pear-validate/validateversion.xml">
<!ENTITY core.ppm.pear-validate.validate SYSTEM "en/core/ppm/pear-validate/validate.xml">
<!ENTITY core.ppm.pear-validate.validgroupname SYSTEM "en/core/ppm/pear-validate/validgroupname.xml">
<!ENTITY core.ppm.pear-validate.-validpackagename SYSTEM "en/core/ppm/pear-validate/-validpackagename.xml">
<!ENTITY core.ppm.pear-validate.validpackagename SYSTEM "en/core/ppm/pear-validate/validpackagename.xml">
<!ENTITY core.ppm.pear-validate.validstate SYSTEM "en/core/ppm/pear-validate/validstate.xml">
<!ENTITY core.ppm.pear-validate.validversion SYSTEM "en/core/ppm/pear-validate/validversion.xml">
<!ENTITY core.ppm.pear-xmlparser.getdata SYSTEM "en/core/ppm/pear-xmlparser/getdata.xml">
<!ENTITY core.ppm.pear-xmlparser.parse SYSTEM "en/core/ppm/pear-xmlparser/parse.xml">
<!ENTITY core.ppm.pear-xmlparser.preprocessstupidsaxon SYSTEM "en/core/ppm/pear-xmlparser/preprocessstupidsaxon.xml">
<!ENTITY core.rest.fileformats.c-categoriesxml SYSTEM "en/core/rest/fileformats/c-categoriesxml.xml">
<!ENTITY core.rest.fileformats.c-category-infoxml SYSTEM "en/core/rest/fileformats/c-category-infoxml.xml">
<!ENTITY core.rest.fileformats.c-category-packagesinfoxml SYSTEM "en/core/rest/fileformats/c-category-packagesinfoxml.xml">
<!ENTITY core.rest.fileformats.c-category-packagesxml SYSTEM "en/core/rest/fileformats/c-category-packagesxml.xml">
<!ENTITY core.rest.fileformats.channelxml SYSTEM "en/core/rest/fileformats/channelxml.xml">
<!ENTITY core.rest.fileformats.m-allmaintainersxml SYSTEM "en/core/rest/fileformats/m-allmaintainersxml.xml">
<!ENTITY core.rest.fileformats.m-maintainer-infoxml SYSTEM "en/core/rest/fileformats/m-maintainer-infoxml.xml">
<!ENTITY core.rest.fileformats.p-package-infoxml SYSTEM "en/core/rest/fileformats/p-package-infoxml.xml">
<!ENTITY core.rest.fileformats.p-package-maintainers2xml SYSTEM "en/core/rest/fileformats/p-package-maintainers2xml.xml">
<!ENTITY core.rest.fileformats.p-package-maintainersxml SYSTEM "en/core/rest/fileformats/p-package-maintainersxml.xml">
<!ENTITY core.rest.fileformats.p-packagesxml SYSTEM "en/core/rest/fileformats/p-packagesxml.xml">
<!ENTITY core.rest.fileformats.r-package-012xml SYSTEM "en/core/rest/fileformats/r-package-012xml.xml">
<!ENTITY core.rest.fileformats.r-package-allreleases2xml SYSTEM "en/core/rest/fileformats/r-package-allreleases2xml.xml">
<!ENTITY core.rest.fileformats.r-package-allreleasesxml SYSTEM "en/core/rest/fileformats/r-package-allreleasesxml.xml">
<!ENTITY core.rest.fileformats.r-package-alphatxt SYSTEM "en/core/rest/fileformats/r-package-alphatxt.xml">
<!ENTITY core.rest.fileformats.r-package-betatxt SYSTEM "en/core/rest/fileformats/r-package-betatxt.xml">
<!ENTITY core.rest.fileformats.r-package-deps012txt SYSTEM "en/core/rest/fileformats/r-package-deps012txt.xml">
<!ENTITY core.rest.fileformats.r-package-develtxt SYSTEM "en/core/rest/fileformats/r-package-develtxt.xml">
<!ENTITY core.rest.fileformats.r-package-latesttxt SYSTEM "en/core/rest/fileformats/r-package-latesttxt.xml">
<!ENTITY core.rest.fileformats.r-package-package012xml SYSTEM "en/core/rest/fileformats/r-package-package012xml.xml">
<!ENTITY core.rest.fileformats.r-package-stabletxt SYSTEM "en/core/rest/fileformats/r-package-stabletxt.xml">
<!ENTITY core.rest.fileformats.r-package-v2012xml SYSTEM "en/core/rest/fileformats/r-package-v2012xml.xml">
<!ENTITY core.rest.usecases.addcategory SYSTEM "en/core/rest/usecases/addcategory.xml">
<!ENTITY core.rest.usecases.addpackage SYSTEM "en/core/rest/usecases/addpackage.xml">
<!ENTITY core.rest.usecases.addrelease SYSTEM "en/core/rest/usecases/addrelease.xml">
<!ENTITY guide.developers.package2.channel SYSTEM "en/guide/developers/package2/channel.xml">
<!ENTITY guide.developers.package2.compatible SYSTEM "en/guide/developers/package2/compatible.xml">
<!ENTITY guide.developers.package2.contents SYSTEM "en/guide/developers/package2/contents.xml">
<!ENTITY guide.developers.package2.dependencies SYSTEM "en/guide/developers/package2/dependencies.xml">
<!ENTITY guide.developers.package2.developers SYSTEM "en/guide/developers/package2/developers.xml">
<!ENTITY guide.developers.package2.dir SYSTEM "en/guide/developers/package2/dir.xml">
<!ENTITY guide.developers.package2.extends SYSTEM "en/guide/developers/package2/extends.xml">
<!ENTITY guide.developers.package2.file SYSTEM "en/guide/developers/package2/file.xml">
<!ENTITY guide.developers.package2.license SYSTEM "en/guide/developers/package2/license.xml">
<!ENTITY guide.developers.package2.pecl SYSTEM "en/guide/developers/package2/pecl.xml">
<!ENTITY guide.developers.package2.release SYSTEM "en/guide/developers/package2/release.xml">
<!ENTITY guide.developers.package2.stability SYSTEM "en/guide/developers/package2/stability.xml">
<!ENTITY guide.developers.package2.tasks SYSTEM "en/guide/developers/package2/tasks.xml">
<!ENTITY guide.developers.package2.uri SYSTEM "en/guide/developers/package2/uri.xml">
<!ENTITY guide.developers.package2.usesrole SYSTEM "en/guide/developers/package2/usesrole.xml">
<!ENTITY guide.developers.package2.usestask SYSTEM "en/guide/developers/package2/usestask.xml">
<!ENTITY guide.developers.package2.version SYSTEM "en/guide/developers/package2/version.xml">
<!ENTITY guide.users.concepts.abstractpackage SYSTEM "en/guide/users/concepts/abstractpackage.xml">
<!ENTITY guide.users.concepts.api SYSTEM "en/guide/users/concepts/api.xml">
<!ENTITY guide.users.concepts.channel SYSTEM "en/guide/users/concepts/channel.xml">
<!ENTITY guide.users.concepts.filerole SYSTEM "en/guide/users/concepts/filerole.xml">
<!ENTITY guide.users.concepts.filetasks SYSTEM "en/guide/users/concepts/filetasks.xml">
<!ENTITY guide.users.concepts.maintainer SYSTEM "en/guide/users/concepts/maintainer.xml">
<!ENTITY guide.users.concepts.package SYSTEM "en/guide/users/concepts/package.xml">
<!ENTITY guide.users.concepts.stability SYSTEM "en/guide/users/concepts/stability.xml">
<!ENTITY guide.users.concepts.version SYSTEM "en/guide/users/concepts/version.xml">
<!ENTITY guide.users.installationpyrus.introduction SYSTEM "en/guide/users/installationpyrus/introduction.xml">
<!ENTITY pyrus.configuration.system.bindir SYSTEM "en/pyrus/configuration/system/bindir.xml">
<!ENTITY pyrus.configuration.system.cfgdir SYSTEM "en/pyrus/configuration/system/cfgdir.xml">
<!ENTITY pyrus.configuration.system.datadir SYSTEM "en/pyrus/configuration/system/datadir.xml">
<!ENTITY pyrus.configuration.system.docdir SYSTEM "en/pyrus/configuration/system/docdir.xml">
<!ENTITY pyrus.configuration.system.extdir SYSTEM "en/pyrus/configuration/system/extdir.xml">
<!ENTITY pyrus.configuration.system.phpbin SYSTEM "en/pyrus/configuration/system/phpbin.xml">
<!ENTITY pyrus.configuration.system.phpdir SYSTEM "en/pyrus/configuration/system/phpdir.xml">
<!ENTITY pyrus.configuration.system.phpini SYSTEM "en/pyrus/configuration/system/phpini.xml">
<!ENTITY pyrus.configuration.system.phpprefix SYSTEM "en/pyrus/configuration/system/phpprefix.xml">
<!ENTITY pyrus.configuration.system.phpsuffix SYSTEM "en/pyrus/configuration/system/phpsuffix.xml">
<!ENTITY pyrus.configuration.system.srcdir SYSTEM "en/pyrus/configuration/system/srcdir.xml">
<!ENTITY pyrus.configuration.system.testdir SYSTEM "en/pyrus/configuration/system/testdir.xml">
<!ENTITY pyrus.configuration.system.wwwdir SYSTEM "en/pyrus/configuration/system/wwwdir.xml">
<!ENTITY pyrus.configuration.user.autodiscover SYSTEM "en/pyrus/configuration/user/autodiscover.xml">
<!ENTITY pyrus.configuration.user.cachedir SYSTEM "en/pyrus/configuration/user/cachedir.xml">
<!ENTITY pyrus.configuration.user.cachettl SYSTEM "en/pyrus/configuration/user/cachettl.xml">
<!ENTITY pyrus.configuration.user.defaultchannel SYSTEM "en/pyrus/configuration/user/defaultchannel.xml">
<!ENTITY pyrus.configuration.user.downloaddir SYSTEM "en/pyrus/configuration/user/downloaddir.xml">
<!ENTITY pyrus.configuration.user.handle SYSTEM "en/pyrus/configuration/user/handle.xml">
<!ENTITY pyrus.configuration.user.httpproxy SYSTEM "en/pyrus/configuration/user/httpproxy.xml">
<!ENTITY pyrus.configuration.user.mypearpath SYSTEM "en/pyrus/configuration/user/mypearpath.xml">
<!ENTITY pyrus.configuration.user.opensslcert SYSTEM "en/pyrus/configuration/user/opensslcert.xml">
<!ENTITY pyrus.configuration.user.paranoia SYSTEM "en/pyrus/configuration/user/paranoia.xml">
<!ENTITY pyrus.configuration.user.password SYSTEM "en/pyrus/configuration/user/password.xml">
<!ENTITY pyrus.configuration.user.pluginsdir SYSTEM "en/pyrus/configuration/user/pluginsdir.xml">
<!ENTITY pyrus.configuration.user.preferredmirror SYSTEM "en/pyrus/configuration/user/preferredmirror.xml">
<!ENTITY pyrus.configuration.user.preferredstate SYSTEM "en/pyrus/configuration/user/preferredstate.xml">
<!ENTITY pyrus.configuration.user.tempdir SYSTEM "en/pyrus/configuration/user/tempdir.xml">
<!ENTITY pyrus.configuration.user.umask SYSTEM "en/pyrus/configuration/user/umask.xml">
<!ENTITY pyrus.configuration.user.username SYSTEM "en/pyrus/configuration/user/username.xml">
<!ENTITY pyrus.configuration.user.verbose SYSTEM "en/pyrus/configuration/user/verbose.xml">
<!ENTITY authoring.package.categorie.mypackage.constants SYSTEM "en/authoring/package/categorie/mypackage/constants.xml">
<!ENTITY authoring.package.categorie.mypackage.example SYSTEM "en/authoring/package/categorie/mypackage/example.xml">
<!ENTITY authoring.package.categorie.mypackage.intro SYSTEM "en/authoring/package/categorie/mypackage/intro.xml">
<!ENTITY authoring.package.categorie.mypackage.myclass.myfunction SYSTEM "en/authoring/package/categorie/mypackage/myclass/myfunction.xml">
<!ENTITY authoring.readme.txt "en/authoring/readme.txt">
<!ENTITY peardoc.build-date "2011-06-29">
<!ENTITY peardoc.copyright-year "2011">
<!-- $Revision: 289284 $ --><!--
   This file should only be present in the English doc tree. If you
   copy it over to your translation tree you will be hunted down
   relentlessly! You have been warned! :)
 --><!-- Editors displayed on the manual frontpage --><!ENTITY frontpage.editors '
  <authorgroup xml:id="editors" xmlns="http://docbook.org/ns/docbook">
   <editor>
    <personname>
     <firstname>Daniel</firstname><surname>Convissor</surname></personname>
   </editor>
   <editor>
    <personname>
     <firstname>Martin</firstname><surname>Jansen</surname>
    </personname>
   </editor>
   <editor>
    <personname>
     <firstname>Alexander</firstname><surname>Merz</surname>
    </personname>
   </editor>
  </authorgroup>'>
]>
<set xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:phd="http://www.php.net/ns/phd" version="5.0" xml:id="index" xml:lang="en" phd:toc-depth="2">
 <title>PEAR Manual</title>
 
<!-- $Revision: 1.21 $ -->
<info xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="bookinfo">

  <pubdate>2011-06-29</pubdate>
  
  <authorgroup xmlns="http://docbook.org/ns/docbook" xml:id="editors">
   <editor>
    <personname>
     <firstname>Daniel</firstname><surname>Convissor</surname></personname>
   </editor>
   <editor>
    <personname>
     <firstname>Martin</firstname><surname>Jansen</surname>
    </personname>
   </editor>
   <editor>
    <personname>
     <firstname>Alexander</firstname><surname>Merz</surname>
    </personname>
   </editor>
  </authorgroup>

  <copyright>
   <year>2001-2011</year>
   <holder>The PEAR Documentation Group</holder>
  </copyright>

  <!--
   the legalnotice in here has been moved to preface.xml for rendering and
   layout reasons. It still covers the whole manual.
  -->
 </info>

 <book xml:id="manual" phd:toc-depth="0">
  <title>About the manual</title>
  
<preface xmlns="http://docbook.org/ns/docbook" xmlns:phd="http://www.php.net/ns/phd" version="lillet" xml:id="preface" phd:chunk="false">
 <info>
  <title>Preface</title>
  <abstract>
   <simpara>
    <acronym>PEAR</acronym> is the PHP Extension and Application
    Repository.
   </simpara>
   <!-- FIXME: more info
    place for developers, 400+ packages, mailing lists, cvs, bug tracker,...
   -->
  </abstract>

  
  <legalnotice xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="copyright">
   <title>Copyright</title>
   <simpara>
    Copyright  2001 - 2011 by the PEAR Documentation Group.
    This material may be distributed only subject to the terms and
    conditions set forth in the Open Publication License, v1.0 or
    later (the latest version is presently available at
    <link xlink:href="http://www.opencontent.org/openpub/">http://www.opencontent.org/openpub/</link>).
   </simpara>
   <simpara>
    Distribution of substantively modified versions of this document
    is prohibited without the explicit permission of the copyright
    holder.
   </simpara>
   <simpara>
    Distribution of the work or derivative of the work in any
    standard (paper) book form is prohibited unless prior permission
    is obtained from the copyright holder.
   </simpara>
   <simpara>
    The PEAR Documentation Group consists of all the people that
    have contributed documentation to the PEAR manual.
    Representatives are listed on the front page of this manual.
    In case you would like to contact the group, please write to
    <link xlink:href="mailto:pear-doc@lists.php.net">pear-doc@lists.php.net</link>.
   </simpara>
  </legalnotice>

 </info>



  <section xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="about" phd:chunk="false">
   <info>
    <title>This Manual</title>
   </info>

   <para>
    This manual is written in <acronym>XML</acronym> using a slightly enhanced
    version of the
    <link xlink:href="http://www.oasis-open.org/docbook/xml/">DocBook 5 XML DTD</link>,
    using PHP's very own DocBook rendering system
    <link xlink:href="http://doc.php.net/phd/">PhD</link>.
   </para>
  </section>

  <section xml:id="structure" phd:chunk="false">
   <info>
    <title>The structure of the Manual</title>
   </info>

   <para>
    This guide explains the general structure, layout, and conventions used
    in the PEAR manual.  The manual is divided into six main parts, they
    are:
   </para>
   <para>
    <itemizedlist>
     <listitem>
      <para>
       <link linkend="guide-developers">Developer Guide</link>
      </para>
      <para>
       General information about developing and releasing
       PEAR-Packages.
      </para>
     </listitem>
     <listitem>
      <para>
       <link linkend="developers-core">Core components</link>
      </para>
      <para>
       This section contains documentation about the core PEAR classes.
       These core components are the base to every PEAR class and
       understanding the basics will allow general use of the PEAR library.
       Topics include the <link xmlns="http://docbook.org/ns/docbook" linkend="core.pear.pear"><classname>PEAR</classname></link> base, PEAR administration, error
       handling through use of the <link xmlns="http://docbook.org/ns/docbook" linkend="core.pear.pear-error"><classname>PEAR_Error</classname></link> object, and system
       commands.  These classes are generally shipped with every source
       PHP distribution.
      </para>
     </listitem>
    </itemizedlist>
   </para>
  </section>

  <section xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="authors" phd:chunk="false">
   <info>
    <title>Authors and Contributors</title>
    <titleabbrev>Authors</titleabbrev>
   </info>

   <para>
    The following is a list of people that are helping to maintain this
    documentation. If you would like to contact one of them, please
    write to <link xlink:href="mailto:pear-doc@lists.php.net">pear-doc@lists.php.net</link>.
   </para>

   
<itemizedlist xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="authors.list">

 <listitem>
  <para>
   <author><personname><firstname>Lorenzo</firstname><surname>Alberton</surname></personname></author>
  </para>
 </listitem>

 <listitem>
  <para>
   <author><personname><firstname>Gregory</firstname><surname>Beaver</surname></personname></author>
  </para>
 </listitem>

 <listitem>
  <para>
   <author><personname><firstname>David</firstname><surname>Coallier</surname></personname></author>
  </para>
 </listitem>

 <listitem>
  <para>
   <author><personname><firstname>Daniel</firstname><surname>Convissor</surname></personname></author>
  </para>
 </listitem>

 <listitem>
  <para>
   <author><personname><firstname>David</firstname><surname>Costa</surname></personname></author>
  </para>
 </listitem>

 <listitem>
  <para>
   <author><personname><firstname>Thomas</firstname><surname>V.V. Cox</surname></personname></author>
  </para>
 </listitem>

 <listitem>
  <para>
   <author><personname><firstname>Michael</firstname><surname>Gauthier</surname></personname></author>
  </para>
 </listitem>

 <listitem>
  <para>
   <author><personname><firstname>Christophe</firstname><surname>Gesch</surname></personname></author>
  </para>
 </listitem>

 <listitem>
  <para>
   <author><personname><firstname>Ken</firstname><surname>Guest</surname></personname></author>
  </para>
 </listitem>

 <listitem>
  <para>
   <author><personname><firstname>Martin</firstname><surname>Jansen</surname></personname></author>
  </para>
 </listitem>

 <listitem>
  <para>
   <author><personname><firstname>Alan</firstname><surname>Knowles</surname></personname></author>
  </para>
 </listitem>

 <listitem>
  <para>
   <author><personname><firstname>Clay</firstname><surname>Loveless</surname></personname></author>
  </para>
 </listitem>

 <listitem>
  <para>
   <author><personname><firstname>Alexander</firstname><surname>Merz</surname></personname></author>
  </para>
 </listitem>

 <listitem>
  <para>
   <author><personname><firstname>Stefan</firstname><surname>Neufeind</surname></personname></author>
  </para>
 </listitem>

 <listitem>
  <para>
   <author><personname><firstname>Jon</firstname><surname>Parise</surname></personname></author>
  </para>
 </listitem>

 <listitem>
  <para>
   <author><personname><firstname>Tobias</firstname><surname>Schlitt</surname></personname></author>
  </para>
 </listitem>

 <listitem>
  <para>
   <author><personname><firstname>Stephan</firstname><surname>Schmidt</surname></personname></author>
  </para>
 </listitem>

 <listitem>
  <para>
   <author><personname><firstname>Mika</firstname><surname>Tuupola</surname></personname></author>
  </para>
 </listitem>

 <listitem>
  <para>
   <author><personname><firstname>Michael</firstname><surname>Wallner</surname></personname></author>
  </para>
 </listitem>

 <listitem>
  <para>
   <author><personname><firstname>Christian</firstname><surname>Weiske</surname></personname></author>
  </para>
 </listitem>

 <listitem>
  <para>
   <author><personname><firstname>Mark</firstname><surname>Wiesemann</surname></personname></author>
  </para>
 </listitem>

</itemizedlist>


   <simpara>
    (In alphabetic order.)
   </simpara>
  </section>
 </preface>

 </book>

 <book xml:id="users">
   <title>User Guide</title>

   
<chapter xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="guide.users.concepts">
  <info>
   <title>Basic concepts all PEAR users should understand</title>
   <author><personname><firstname>Gregory</firstname><surname>Beaver</surname></personname></author>
   <date>2009-06-26</date>
  </info>

  <simpara>
   This chapter describes basic concepts that are important for all users of
   Pyrus, the PEAR Installer, or PEAR packages to understand.
  </simpara>

  
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="guide.users.concepts.package">
 <info><title>PEAR Packages</title></info>

 <para>
  The smallest unit that can be managed by Pyrus or the PEAR Installer is
  a <literal>package</literal>.  A package is a collection of files
  that are organized and defined by a meta-information file called
  <link linkend="guide.developers.package2.intro">package.xml</link>.
 </para>
 <para>
  A package also contains meta-information about the collected files, such
  as the name of the package, the <link linkend="guide.users.concepts.channel">channel</link>
  that the package is from, the version of the package, information
  on the developers who created the package, and any external dependencies the
  package has on other packages or installation requirements (such as minimum PHP version).
 </para>
 <para>
  Packages can exist as a collection of files on disk, or can be placed into
  an archive in phar, tar, or zip format and then later installed on another
  system.
 </para>
</section>

  
<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="lillet" xml:id="guide.users.concepts.api">
 <info><title>API (Application Program Interface)</title></info>

 <para>
  A package's API is the publicly documented entry points to the library or
  program within the package.  For example, the classes or methods that are
  to be used with a PEAR package, or the commands for a command-line program
  are all elements of an API.  Another example might be the templating language.
 </para>
 <para>
  Any element of the program that is not intended to be used by the outside
  world, or is not documented, is not considered part of the API, and thus
  should not be relied upon in your programs as it may change in any
  future release.
 </para>
</section>

  
<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="lillet" xml:id="guide.users.concepts.stability">
 <info><title>Package stability</title></info>

 <para>
  Versioning and stability are separate entities for
  <link linkend="guide.users.concepts.package">packages</link>.
  The stability of a package determines how likely the package is to contain bugs
  or to have changes to its <link linkend="guide.users.concepts.api">API</link>.
  A distinction is made between the version/stability of the API and the
  version/stability of the code.
 </para>
 <para>
  This simple chart shows the meaning of a package's stability:
  <table>
   <title>What a package's stability means</title>
   <tgroup cols="3">
    <thead>
     <row>
      <entry>Stability type</entry>
      <entry>Stability</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>Release</entry>
      <entry><literal>devel</literal></entry>
      <entry>
       The package is under development and will change dramatically, both
       adding new features, changing the design, and fixing many bugs.  It may
       not function at all and be more of a proof-of-concept.  There may be
       little to no documentation or unit tests.  Use at your own risk.
      </entry>
     </row>
     <row>
      <entry>Release</entry>
      <entry><literal>alpha</literal></entry>
      <entry>
       The package is ready for testing by hard core users.  Features are
       still being developed, but the program should work.  Subsequent releases
       may have major changes.
      </entry>
     </row>
     <row>
      <entry>Release</entry>
      <entry><literal>beta</literal></entry>
      <entry>
       The package is nearly ready for public release and usage in production.
       Documentation is complete, unit tests are complete, and the API is
       frozen (will not change) unless major problems are found.
      </entry>
     </row>
     <row>
      <entry>Release</entry>
      <entry><literal>stable</literal></entry>
      <entry>
       The package is ready for use in production.
       Documentation is complete, unit tests are complete, and the API is
       frozen completely and will not change.
      </entry>
     </row>
     <row>
      <entry>API</entry>
      <entry><literal>devel</literal></entry>
      <entry>
       The API will change dramatically between releases, and cannot be relied upon.
      </entry>
     </row>
     <row>
      <entry>API</entry>
      <entry><literal>alpha</literal></entry>
      <entry>
       The API is starting to stabilize, but may still have major changes.
      </entry>
     </row>
     <row>
      <entry>API</entry>
      <entry><literal>beta</literal></entry>
      <entry>
       The API will only have changes if major bugs are found.
      </entry>
     </row>
     <row>
      <entry>API</entry>
      <entry><literal>stable</literal></entry>
      <entry>
       The API will not change and can be relied upon.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </para>
 <section xml:id="guide.users.concepts.stability.conventions">
  <para>
   There are a few conventions that should be followed when deciding which
   stability to use for your package.  In general, the API stability should be
   equal to or better than the release stability.
  </para>
  <para>
   Here is a helpful chart of stabilities:
   <table>
    <title>Which stability to use</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Release Stability</entry>
       <entry>API Stability</entry>
       <entry>Scenario</entry>
      </row>
     </thead>
 
     <tbody>
      <row>
       <entry><literal>devel</literal></entry>
       <entry><literal>devel</literal></entry>
       <entry>
        This package is brand new, no documentation, no tests, more of
        a proof-of-concept.  It may not work at all.
       </entry>
      </row>
      <row>
       <entry><literal>alpha</literal></entry>
       <entry><literal>alpha</literal></entry>
       <entry>
        This package has been developed extensively, and is ready for testing
        by the outside world, has some documentation or full documentation
        and tests, but the API or design is subject to dramatic change if
        necessary.  Bugs are likely
       </entry>
      </row>
      <row>
       <entry><literal>alpha</literal></entry>
       <entry><literal>beta</literal></entry>
       <entry>
        This package has a relatively certain API, but may contain bugs, and
        the API may change, but most changes will be small.
       </entry>
      </row>
      <row>
       <entry><literal>beta</literal></entry>
       <entry><literal>beta</literal></entry>
       <entry>
        This package is approaching release, the code is stabilizing as well as
        the API
       </entry>
      </row>
      <row>
       <entry><literal>beta</literal></entry>
       <entry><literal>stable</literal></entry>
       <entry>
        This package is in the release candidate stage, has full documentation
        and tests, as well as a frozen API.  Bugs may still be present in the
        code.
       </entry>
      </row>
      <row>
       <entry><literal>stable</literal></entry>
       <entry><literal>stable</literal></entry>
       <entry>
        This package is ready for use in production, has full documentation
        and tests, and the API can be relied upon as frozen.
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </para>
 </section>
</section>

  
<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="lillet" xml:id="guide.users.concepts.version">
 <info><title>Package version</title></info>

 <para>
  Versioning and stability are separate entities for
  <link linkend="guide.users.concepts.package">packages</link>.
  The version of a package is a numeric string like <literal>1.2.3</literal> that
  is incremented every time a new version of the package is released.
  The stability of a package determines how likely the package is to contain bugs
  or to have changes to its <link linkend="guide.users.concepts.api">API</link>.
 </para>
 <para>
  In addition, PEAR makes a distinction between the
  <link linkend="guide.users.concepts.api">API</link> version and the package
  version.
<!-- disabling this part until it is approved by the man
  This allows fine-grained control for Pyrus users,
  who can request even finer control over the API version to be installed
  by setting the <literal>paranoid</literal> setting higher than the default value.
  This is documented <link linkend="guide.users.concepts.paranoid">here</link>. -->
 </para>
 <section xml:id="guide.users.concepts.version.guidelines">
  <title>Versioning guidelines</title>
  <para>
   There are a few conventions that should be followed when deciding which version
   number or stability to use for your package.  Version numbers should always
   contain three decimals such as <literal>1.2.3</literal>.  This is because of
   the way that PHP's <function>version_compare</function> function calculates
   the difference between versions:
  </para>
  <para>
   <programlisting role="php">
    <![CDATA[
 <?php
 var_dump(version_compare("1.0", "1.0.0")); // int(-1)
 ?>
    ]]>
   </programlisting>
  </para>
  <para>
   The example above shows that in fact version <literal>1.0</literal> is
   considered to be a different version from version <literal>1.0.0</literal>,
   a distinction that is confusing at best for users.  Use of 3 decimals for
   every version will ensure that both your users and PHP will not be confused
   by which of two versions is the same or newer.
  </para>
  <para>
   Package versions can be abstractly referred to as <literal>X.Y.Z</literal>.
   For version <literal>1.2.3</literal>, <literal>X</literal> is <literal>1</literal>,
   <literal>Y</literal> is <literal>2</literal> and <literal>Z</literal> is
   <literal>3</literal>.
  </para>
  <para>
   Generally speaking, it is best if <literal>X</literal> is used to refer to
   major API changes, sweeping addition of new features, or any break of
   backwards compatibility.  The <literal>Y</literal> component should be reserved
   for small to large feature additions, but should never be used for
   breaks of backwards compatibility.  The <literal>Z</literal> component should
   only be used for bugfixes.
  </para>
  <para>
   These three questions can be used to determine how to increase the version
   number:
   <orderedlist>
    <listitem>
     <simpara>
      Breaking backwards compatibility? Yes = increment <literal>X</literal>,
      set <literal>Y</literal> = <literal>Z</literal> = 0
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Adding new features? Yes = increment <literal>Y</literal>, set
      <literal>Z</literal> = 0
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Fixing bugs? Yes = increment <literal>Z</literal>
     </simpara>
    </listitem>
   </orderedlist>
  </para>
  <para>
   Here is a typical life cycle for a package:
   <table>
    <title>A version life cycle for a package</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Release Notes</entry>
       <entry>Release Stability</entry>
       <entry>API Stability</entry>
       <entry>Release Version</entry>
       <entry>API Version</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>Initial release</entry>
       <entry><literal>devel</literal> or <literal>alpha</literal></entry>
       <entry><literal>devel</literal> or <literal>alpha</literal></entry>
       <entry><literal>0.1.0</literal></entry>
       <entry><literal>0.1.0</literal></entry>
      </row>
      <row>
       <entry>Bugs fixed</entry>
       <entry><literal>devel</literal> or <literal>alpha</literal></entry>
       <entry><literal>devel</literal> or <literal>alpha</literal></entry>
       <entry><literal>0.1.1</literal></entry>
       <entry><literal>0.1.0</literal></entry>
      </row>
      <row>
       <entry>More bugs fixed</entry>
       <entry><literal>devel</literal> or <literal>alpha</literal></entry>
       <entry><literal>devel</literal> or <literal>alpha</literal></entry>
       <entry><literal>0.1.2</literal></entry>
       <entry><literal>0.1.0</literal></entry>
      </row>
      <row>
       <entry>API changed, more bugs fixed</entry>
       <entry><literal>devel</literal> or <literal>alpha</literal></entry>
       <entry><literal>devel</literal> or <literal>alpha</literal></entry>
       <entry><literal>0.2.0</literal></entry>
       <entry><literal>0.2.0</literal></entry>
      </row>
      <row>
       <entry>API changed, more bugs fixed</entry>
       <entry><literal>devel</literal> or <literal>alpha</literal></entry>
       <entry><literal>devel</literal> or <literal>alpha</literal></entry>
       <entry><literal>0.3.0</literal></entry>
       <entry><literal>0.3.0</literal></entry>
      </row>
      <row>
       <entry>API changed, documentation started, tests expanding</entry>
       <entry><literal>alpha</literal></entry>
       <entry><literal>alpha</literal></entry>
       <entry><literal>0.4.0</literal></entry>
       <entry><literal>0.4.0</literal></entry>
      </row>
      <row>
       <entry>API stabilizing, documentation nearly finished, tests expanding</entry>
       <entry><literal>alpha</literal></entry>
       <entry><literal>beta</literal></entry>
       <entry><literal>0.5.0</literal></entry>
       <entry><literal>0.4.1</literal></entry>
      </row>
      <row>
       <entry>API stabilizing, code stabilizing, documentation nearly finished, tests expanding</entry>
       <entry><literal>beta</literal></entry>
       <entry><literal>beta</literal></entry>
       <entry><literal>0.5.1</literal></entry>
       <entry><literal>0.4.1</literal></entry>
      </row>
      <row>
       <entry>API problem fixed, code stabilizing, documentation nearly finished, tests expanding</entry>
       <entry><literal>beta</literal></entry>
       <entry><literal>beta</literal></entry>
       <entry><literal>0.6.0</literal></entry>
       <entry><literal>0.5.0</literal></entry>
      </row>
      <row>
       <entry>API stabilized, code stabilizing, documentation nearly finished, tests expanding</entry>
       <entry><literal>beta</literal></entry>
       <entry><literal>stable</literal></entry>
       <entry><literal>0.6.1</literal></entry>
       <entry><literal>1.0.0</literal></entry>
      </row>
      <row>
       <entry>API stabilized, code stabilizing, documentation finished, tests expanding</entry>
       <entry><literal>beta</literal></entry>
       <entry><literal>stable</literal></entry>
       <entry><literal>1.0.0RC1</literal></entry>
       <entry><literal>1.0.0</literal></entry>
      </row>
      <row>
       <entry>API stabilized, code stabilizing, documentation finished, tests full coverage</entry>
       <entry><literal>beta</literal></entry>
       <entry><literal>stable</literal></entry>
       <entry><literal>1.0.0RC2</literal></entry>
       <entry><literal>1.0.0</literal></entry>
      </row>
      <row>
       <entry>code ready for use in production</entry>
       <entry><literal>stable</literal></entry>
       <entry><literal>stable</literal></entry>
       <entry><literal>1.0.0</literal></entry>
       <entry><literal>1.0.0</literal></entry>
      </row>
      <row>
       <entry>bugs fixed</entry>
       <entry><literal>stable</literal></entry>
       <entry><literal>stable</literal></entry>
       <entry><literal>1.0.1</literal></entry>
       <entry><literal>1.0.0</literal></entry>
      </row>
      <row>
       <entry>bugs fixed</entry>
       <entry><literal>stable</literal></entry>
       <entry><literal>stable</literal></entry>
       <entry><literal>1.0.2</literal></entry>
       <entry><literal>1.0.0</literal></entry>
      </row>
      <row>
       <entry>new features added, bugs fixed</entry>
       <entry><literal>stable</literal></entry>
       <entry><literal>stable</literal></entry>
       <entry><literal>1.1.0</literal></entry>
       <entry><literal>1.1.0</literal></entry>
      </row>
      <row>
       <entry>bugs fixed, package enters maintenance mode to develop next generation</entry>
       <entry><literal>stable</literal></entry>
       <entry><literal>stable</literal></entry>
       <entry><literal>1.1.1</literal></entry>
       <entry><literal>1.1.0</literal></entry>
      </row>
<!-- disabling this part until it is actually approved by the man
      <row>
       <entry>new features added, and backwards compatibility broken (PEAR2 only)</entry>
       <entry><literal>alpha</literal></entry>
       <entry><literal>alpha</literal></entry>
       <entry><literal>2.0.0a1</literal></entry>
       <entry><literal>2.0.0a1</literal></entry>
      </row>
      <row>
       <entry>bugs fixed (PEAR2 only)</entry>
       <entry><literal>alpha</literal></entry>
       <entry><literal>alpha</literal></entry>
       <entry><literal>2.0.0a2</literal></entry>
       <entry><literal>2.0.0a1</literal></entry>
      </row>
      <row>
       <entry>bugs fixed, API stabilizing (PEAR2 only)</entry>
       <entry><literal>alpha</literal></entry>
       <entry><literal>beta</literal></entry>
       <entry><literal>2.0.0a3</literal></entry>
       <entry><literal>2.0.0b1</literal></entry>
      </row>
      <row>
       <entry>bugs fixed, API stable (PEAR2 only)</entry>
       <entry><literal>beta</literal></entry>
       <entry><literal>stable</literal></entry>
       <entry><literal>2.0.0b1</literal></entry>
       <entry><literal>2.0.0</literal></entry>
      </row>
      <row>
       <entry>code stabilizing, API stable (PEAR2 only)</entry>
       <entry><literal>beta</literal></entry>
       <entry><literal>stable</literal></entry>
       <entry><literal>2.0.0RC1</literal></entry>
       <entry><literal>2.0.0</literal></entry>
      </row>
      <row>
       <entry>ready for production use (PEAR2 only)</entry>
       <entry><literal>stable</literal></entry>
       <entry><literal>stable</literal></entry>
       <entry><literal>2.0.0</literal></entry>
       <entry><literal>2.0.0</literal></entry>
      </row>-->
     </tbody>
    </tgroup>
   </table>
  </para>
  <para>
   Note that the PEAR coding standards require packages to be renamed when they
   break backwards compatibility.  Thus, a PEAR package can never reach
   version <literal>2.0.0</literal>.
  </para>
 </section>
</section>

  
<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="lillet" xml:id="guide.users.concepts.maintainer">
 <info><title>Maintainers and maintainer roles</title></info>

 <para>
  PEAR and PEAR2 calls its developers <literal>maintainers</literal>, and
  classifies maintainers by their level of contribution to a package, or
  their <literal>role</literal>.  In addition, each maintainer must choose a
  handle which can be used to refer
  to them in package.xml and in bug reports.  A handle is an alphanumeric
  word with all lower-cased letters such as <literal>cellog</literal>
  or <literal>tony2001</literal>.  If you are developing for pear.php.net,
  pear2.php.net or pecl.php.net, this handle is the account name you use
  to log into the website.
 </para>
 <para>
  Developer roles are <literal>lead</literal>, <literal>developer</literal>,
  <literal>contributor</literal> and <literal>helper</literal>.  Only lead
  maintainers have the permission to release a package.  Both lead and
  developer maintainers may create and modify package roadmaps, and
  all developers can directly log into pear.php.net and change the status of
  bugs for the packages that they maintain.
 </para>
 <para>
  For channels outside of pear.php.net, pecl.php.net, and pear2.php.net, these
  handles are still required, and have no special meaning beyond what the channel
  defines them to be.  However, both the Pyrus simple channel server and other
  external channel server implementations require the lead developer of a
  package to perform releases.
 </para>
</section>

  
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="guide.users.concepts.abstractpackage">
 <info><title>Abstract Package Name (for install/uninstall command)</title></info>

 <para>
  There are several different ways of referring to a package that Pyrus and the
  PEAR Installer understand.  Three ways are concrete, in that they refer to
  deterministic entities such as a package.xml file on disk, or a <acronym>URI</acronym>
  (Uniform Resource Identifier) such as <literal>http://pear.php.ne/get/PEAR-1.8.1.tgz</literal>
  that refers to a file on a remote server.
 </para>
 <para>
  <table>
   <title>Ways of specifying a package for installation</title>
   <tgroup cols="3">
    <thead>
     <row>
      <entry>Package type</entry>
      <entry>Local/Remote</entry>
      <entry>Example</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>package.xml</literal> file</entry>
      <entry>Local</entry>
      <entry><userinput>php pyrus.phar install /path/to/package.xml</userinput></entry>
     </row>
     <row>
      <entry>Package release archive</entry>
      <entry>Local</entry>
      <entry><userinput>php pyrus.phar install /path/to/PackageName-1.2.3.tgz</userinput></entry>
     </row>
     <row>
      <entry>Static url</entry>
      <entry>Remote</entry>
      <entry><userinput>php pyrus.phar install http://example.com/PackageName-1.2.3.tgz</userinput></entry>
     </row>
     <row>
      <entry>Abstract package</entry>
      <entry>Remote</entry>
      <entry><userinput>php pyrus.phar install PackageName</userinput></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </para>
 <para>
  The first three ways of specifying a package are concrete: the package name
  always refers to one and only one package.  Abstract packages are more
  flexible, and there are several ways of requesting a package.  Note that
  if the channel is not explicitly requested (as it is in the last example),
  Pyrus or the PEAR Installer prepends the default channel.  The default channel
  is set by the <literal>default_channel</literal> configuration variable, and is
  set to one of <literal>pear.php.net</literal> (pear command), <literal>pecl.php.net</literal>
  (pecl command), or <literal>pear2.php.net</literal> (Pyrus) unless explicitly changed
  by a call to the config-set
  (pear/pecl command) or <link linkend="pyrus.commands.set">set</link> (pyrus)
  command.  A request for
  <literal>PackageName</literal> will be interpreted by the PEAR Installer or Pyrus
  to be a request for package PackageName from the default channel, as if the user had
  requested <literal>pear.php.net/PackageName</literal> (pear command),
  <literal>pecl.php.net/PackageName</literal> (pecl command) or
  <literal>pear2.php.net/PackageName</literal> (pyrus).
  <table>
   <title>Ways of specifying an abstract package</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>Example</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>PackageName-1.2.3</literal></entry>
      <entry>
       This forces Pyrus to download version <literal>1.2.3</literal> of
       package <literal>PackageName</literal>, but will will attempt to download
       a release in one of the following file formats, in this order:
       <orderedlist>
        <listitem><simpara>phar</simpara></listitem>
        <listitem><simpara>tgz (only if zlib extension is enabled)</simpara></listitem>
        <listitem><simpara>tar</simpara></listitem>
        <listitem><simpara>zip</simpara></listitem>
       </orderedlist>
      </entry>
     </row>
     <row>
      <entry><literal>PackageName-alpha</literal></entry>
      <entry>
       This causes Pyrus to download the latest version of
       package <literal>PackageName</literal> that is <literal>alpha</literal>
       stability or better (the hierarchy of stabilities is <literal>devel</literal>,
       <literal>alpha</literal>, <literal>beta</literal>, <literal>stable</literal>).
       After finding a matching version, it will attempt to download a release
       in one of the following file formats, in this order:
       <orderedlist>
        <listitem><simpara>phar</simpara></listitem>
        <listitem><simpara>tgz (only if zlib extension is enabled)</simpara></listitem>
        <listitem><simpara>tar</simpara></listitem>
        <listitem><simpara>zip</simpara></listitem>
       </orderedlist>
      </entry>
     </row>
     <row>
      <entry><literal>PackageName</literal></entry>
      <entry>
       This causes Pyrus to download the latest version of
       package <literal>PackageName</literal> that is <literal>preferred_state</literal>
       (configuration variable)
       stability or better (the hierarchy of stabilities is <literal>devel</literal>,
       <literal>alpha</literal>, <literal>beta</literal>, <literal>stable</literal>).
       After finding a matching version, it will attempt to download a release
       in one of the following file formats, in this order:
       <orderedlist>
        <listitem><simpara>phar</simpara></listitem>
        <listitem><simpara>tgz (only if zlib extension is enabled)</simpara></listitem>
        <listitem><simpara>tar</simpara></listitem>
        <listitem><simpara>zip</simpara></listitem>
       </orderedlist>
       The <literal>preferred_state</literal> configuration variable can be seen
       with the <link linkend="pyrus.commands.configshow">config-show</link>
       command.
      </entry>
     </row>
     <row>
      <entry><literal>PackageName#groupname</literal></entry>
      <entry>
       This causes Pyrus to download and install a release of Pyrus as specified
       above, and it also causes Pyrus to download and install the contents
       of the <literal>groupname</literal> dependency group (dependency groups
       are documented <link linkend="guide.developers.package2.dependencies.groups">here</link>).
       Note that <literal>PackageName</literal> in <literal>PackageName#groupname</literal>
       can be any of the above examples, such as <literal>PackageName-1.2.3#groupname</literal>.
      </entry>
     </row>
     <row>
      <entry><literal>channelname/PackageName</literal></entry>
      <entry>
       This causes Pyrus to download and install a release of
       <literal>PackageName</literal> from the channel <literal>channelname</literal>.
       Another syntax that can be used is <literal>channel://channelname/PackageName</literal>
       which is useful if there is a sub-directory of the current working
       directory named <literal>channelname</literal> and a file or directory
       within it named <literal>PackageName</literal>.  Note that
       in the example above, <literal>PackageName</literal> can be any of the
       previous syntaces such as <literal>channelname/PackageName-1.2.3#groupname</literal>.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </para>
 <section xml:id="guide.users.concepts.abstractpackages.uninstall">
  <title>Abstract Package for installed packages</title>
  <para>
   Note that the <literal>uninstall</literal>, <literal>run-scripts</literal>,
   and other commands that operate on installed packages
   only support a simple
   package name as in <literal>PackageName</literal> or
   <literal>channelname/PackageName</literal>.  Any fancy stuff like
   <literal>pear2.php.net/PackageName-1.2.3#group</literal> is ignored.
  </para>
 </section>
</section>

  
<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="lillet" xml:id="guide.users.concepts.channel">
 <info><title>PEAR Channels</title></info>

 <para>
  A PEAR Channel is a web site that distributes
  <link linkend="guide.users.concepts.package">package</link> archives for remote
  installation by users of Pyrus or the PEAR Installer.  In addition to providing
  the package archives for download, a PEAR Channel must also provide some
  meta-information that the installer can use to locate the package releases and
  determine which is the best release to download.
 </para>
 <para>
  Channels have a file that defines the capabilities of the channel named channel.xml located in its
  document root (for instance,
  <link xlink:href="http://pear.php.net/channel.xml">pear.php.net's channel.xml</link>)
  and some meta-information in <link linkend="core.rest">REST</link> format.
 </para>
 <para>
  A channel can also provide a public frontend for users to browse the contents
  of the channel online, such as
  <link xlink:href="http://pear.php.net/packages.php">PEAR's public frontend</link>.
 </para>
</section>

  
<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="lillet" xml:id="guide.users.concepts.filerole">
 <info><title>File roles</title></info>

 <para>
  Pyrus and The PEAR Installer categorize file types by their <literal>role</literal>.
  A file role is equivalent to the web's concept of <literal>MIME type</literal>,
  a concept that allows web browsers to determine how a file should be displayed
  or processed.  A file role allows Pyrus and the PEAR Installer to determine
  where a file should be installed, the conditions under which the role can be
  used, and even whether the file should be installed at all.  A file may only
  have one role in a package.
 </para>
 <para>
  Generally speaking, each file role has its own installation location.  For
  example, <literal>php</literal> files (files whose file role is
  <literal>php</literal>) are installed into the location specified by the
  <literal>php_dir</literal> configuration variable, <literal>data</literal>
  files (files whose file role is <literal>data</literal>) are installed into
  the location specified by the <literal>data_dir</literal> configuration
  variable.  Some file roles do not have a direct mapping of role name
  to configuration variable, such as Pyrus's <literal>customcommand</literal>
  file role.  This file role is installed into the location specified by the
  <literal>data_dir</literal> configuration variable.
 </para>
 <para>
  File roles also control how package.xml attributes are handled.  The
  <literal>php</literal> file role installs files into the exact
  relative path as specified in package.xml.  The <literal>data</literal>
  file role always installs files into a subdirectory containing the package name
  for PEAR packages, and both the channel and package name for packages designed
  to be installed by Pyrus.
 </para>
 <para>
  Here is an example of the same file path in package.mxl as <literal>php</literal>
  role and as <literal>data</literal> role.  All examples assume this is a
  package named <literal>PackageName</literal> in the <literal>pear2.php.net</literal>
  channel.
 </para>
 <programlisting role="xml">
  <![CDATA[
  <contents>
   <dir name="\">
    <dir name="base">
     <file name="foo" role="php">
    </dir>
   </dir>
  </contents>
  ]]>
 </programlisting>
 <para>
  This installs as <literal>base/foo</literal> in the location specified
  by <literal>php_dir</literal>.
 </para>
 <programlisting role="xml">
  <![CDATA[
  <contents>
   <dir name="\">
    <dir name="base">
     <file name="foo" role="data">
    </dir>
   </dir>
  </contents>
  ]]>
 </programlisting>
 <para>
  For PEAR Installer packages, this installs as <literal>PackageName/base/foo</literal>
  in the location specified by <literal>php_dir</literal>.  For Pyrus packages,
  this installs as <literal>pear2.php.net/PackageName/base/foo</literal>.
 </para>
 <section xml:id="guide.users.concepts.filerole.baseinstalldir">
  <title>How the baseinstalldir attribute is handled by different file roles</title>
  <para>
   The <literal>baseinstalldir</literal> (base installation directory) attribute
   is a tool that can be used to install a file into a different directory than
   its location in the source repository.
  </para>
  <para>
   As an example, the path in the subversion repository to the file
   <literal>PEAR2\Foo.php</literal> is at
   <literal>Foo.php</literal>.  To inform the installer to install this
   package into the <literal>PEAR2</literal> directory, we would use a baseinstalldir
   attribute:
  </para>
  <programlisting role="xml">
   <![CDATA[
   <contents>
    <dir name="\">
     <file name="Foo.php" role="php" baseinstalldir="PEAR2">
    </dir>
   </contents>
   ]]>
  </programlisting>
  <para>
   The attribute can also be used on <literal>&lt;dir&gt;</literal> tags to apply
   the base installation directory to all files within the directory:
  </para>
  <programlisting role="xml">
   <![CDATA[
   <contents>
    <dir name="\" baseinstalldir="PEAR2">
     <file name="Foo.php" role="php">
    </dir>
   </contents>
   ]]>
  </programlisting>
  <para>
   The <literal>baseinstalldir</literal> role can also be used to inform
   the PEAR Installer or Pyrus to strip all relative paths by using
   <literal>/</literal> as the base installation directory.  Here is an
   example from the PEAR package:
  </para>
  <programlisting role="xml">
   <![CDATA[
   <dir name="scripts" baseinstalldir="/">
    <file name="pear.bat" role="script"/>
   ]]>
  </programlisting>
  <para>
   This file would be installed as <literal>scripts/pear.bat</literal>, but
   the <literal>baseinstalldir</literal> attribute of <literal>/</literal>
   informs the installer to instead install it to <literal>pear.bat</literal>.
  </para>
  <para>
   Each file role reacts differently to the <literal>baseinstalldir</literal>
   attribute.  Packages designed to be installed by the PEAR Installer also
   handle them differently from packages designed for installation by Pyrus.
   The <literal>php</literal>, <literal>script</literal> and <literal>www</literal>
   file roles react the
   same way as documented above.  In packages designed for the PEAR Installer,
   the other file roles do not honor the
   <literal>baseinstalldir</literal> attribute, meaning they ignore it.  For
   example:
  </para>
  <programlisting role="xml">
   <![CDATA[
   <contents>
    <dir name="\" baseinstalldir="PEAR2">
     <file name="Foo.dat" role="data">
    </dir>
   </contents>
   ]]>
  </programlisting>
  <para>
   installs <literal>Foo.dat</literal> into the <literal>PackageName/Foo.dat</literal>
   directory.  The same XML in a package designed for installation by Pyrus
   will install the file into <literal>pear2.php.net/PackageName/PEAR2/Foo.dat</literal>.
  </para>
 </section>
</section>

  
<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="lillet" xml:id="guide.users.concepts.filetasks">
 <info><title>File tasks</title></info>

 <para>
  Pyrus allows special handling of files through tasks.  File tasks can perform
  any action necessary both when installing a package and when creating a
  package.  Both Pyrus and the PEAR Installer ship with 4 built-in tasks,
  <literal>replace</literal>, <literal>windowseol</literal>,
  <literal>unixeol</literal>, and <literal>postinstallscript</literal>.
 </para>
 <para>
  The built-in tasks are documented <link linkend="guide.developers.package2.tasks">here</link>.
  The documentation also describes how to create custom tasks for the
  PEAR Installer.  Custom tasks for Pyrus are documented
  <link linkend="pyrus.plugins.task">here</link>.
 </para>
 <para>
  Tasks are specifically designed to allow customization of an installation, and
  particularly modification of a specific file's contents.  The
  <literal>unixeol</literal> task, for instance, transforms line endings to
  UNIX <literal>\n</literal> and is useful for shell scripts that must have
  the proper line endings.  The <literal>replace</literal> task can be used
  to update the version of a package directly in the source code, or to
  automatically set up the path to a PEAR Installation in a shell script.
 </para>
 <para>
  Tasks are defined using the XML namespace
  <literal>http://pear.php.net/dtd/tasks-1.0</literal>.  Most often, this
  is declared using <literal>tasks</literal> as the namespace prefix, as in
  <literal><![CDATA[xmlns:tasks="http://pear.php.net/dtd/tasks-1.0"]]></literal>.
  More than one task can be used for a single file, as shown by this example from
  the PEAR package:
 </para>
 <programlisting role="xml">
  <![CDATA[
    <file name="pearcmd.php" role="php">
     <tasks:replace from="@php_bin@" to="php_bin" type="pear-config" />
     <tasks:replace from="@php_dir@" to="php_dir" type="pear-config" />
     <tasks:replace from="@pear_version@" to="version" type="package-info" />
     <tasks:replace from="@include_path@" to="php_dir" type="pear-config" />
    </file>
  ]]>
 </programlisting>
</section>

 </chapter>

   
<chapter xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="installationpyrus">
  <info>
   <title>Installation (Pyrus)</title>
   <author><personname><firstname>Gregory</firstname><surname>Beaver</surname></personname></author>
   <date>2009-06-17</date>
  </info>

  <simpara>
   This chapter describes how to install Pyrus, the package manager for PEAR2 and PHP 5.3+.
  </simpara>

  
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="installationpyrus.introduction">
    <info><title>Introduction: it's simple</title></info>

   <para>
    Installing Pyrus is much simpler than installing PEAR.  Installing PEAR
    requires downloading a separate installation and installing PEAR before you
    can use it to install any packages.
   </para>
   <para>
    To install pyrus, you must follow two simple steps:
    <orderedlist>
     <listitem>
      <simpara>
       Install PHP 5.3.1 or newer.  Pyrus needs the phar, simplexml, libxml2,
       spl and pcre extensions in order to work.  Fortunately, these are all
       enabled by default in PHP 5.3.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       download pyrus.phar from the pear2.php.net website front page
      </simpara>
     </listitem>
    </orderedlist>
    That's it, pyrus has no external dependencies.  Using Pyrus is also simple,
    one simply passes it to the command-line interface (CLI) like so:
   </para>
   <para>
    <screen>
     <![CDATA[
php pyrus.phar install packagename
     ]]>
    </screen>
   </para>
   <para>
    The first time pyrus is run on your system, it will ask where you would like
    to install packages.  After this, one can simply use it.
   </para>
   <para>
    To match PEAR, it is also possible to create a convenience script for
    accessing pyrus.  Here is a sample script for unix systems:
   </para>
   <para>
    <programlisting role="script">
     <![CDATA[
#!/bin/bash
/usr/local/bin/php -dphar.readonly=0 /home/username/pyrus.phar $*
     ]]>
    </programlisting>
   </para>
   <para>
    If your system has open_basedir enabled, the script should instead look like:
   </para>
   <para>
    <programlisting role="script">
     <![CDATA[
#!/bin/bash
/usr/local/bin/php -dphar.readonly=0 -dopen_basedir= -dsafe_mode= /home/username/pyrus.phar $*
     ]]>
    </programlisting>
   </para>
   <para>
    Windows users can create a batch file similar to the unix script named pyrus.bat:
   </para>
   <para>
    <programlisting role="script">
     <![CDATA[
@ECHO OFF
C:\php5\php -dphar.readonly=0 -dopen_basedir= -dsafe_mode= C:\php5\pyrus.phar %*
     ]]>
    </programlisting>
   </para>
   <para>
    Place the shell script (on unix) or batch file (on windows) in your path,
    and then you can run commands like so:
   </para>
   <para>
    <screen>
     <![CDATA[
pyrus install packagename
     ]]>
    </screen>
   </para>
  </section>

 </chapter>

 </book>

 <book xml:id="pyrus">
   <title>Using Pyrus, the PEAR Installer for PHP 5.3+</title>

  
<chapter xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.about">
  <info>
   <title>About Pyrus</title>
   <author><personname><firstname>Gregory</firstname><surname>Beaver</surname></personname></author>
   <date>2009-06-16</date>
  </info>

  <para>
   This documentation is organized with progressive complexity in mind.  If
   you are new to PEAR, you should read the
   <link linkend="guide.users.concepts">PEAR Concepts</link> section of the
   manual first, and then return to learn more about Pyrus.
  </para>
  <para>
   If you are migrating from using the PEAR installer, it will be helpful to
   read the section on <link linkend="pyrus.differences.frompear">differences
   from PEAR</link>.
  </para>
  <para>
   To get started with information on the features available in Pyrus,
   start with the <link linkend="pyrus.commands">Pyrus commands</link> section
   to familiarize yourself with the commands available for users of Pyrus,
   then read about the <link linkend="pyrus.configuration">configuration options</link>
   available in Pyrus.
  </para>
  <para>
   If you wish to extend Pyrus's functionality, read the section on <link linkend="pyrus.plugins">plugins</link>.  <!-- Finally, if you are inspired to
   distribute your own software using Pyrus, you can either apply for a PEAR
   developer account (<link linkend="developers-newmaint">information here</link>)
   or read the section on releasing packages through your own channel
   <link linkend="channels.scs">here</link>. -->
  </para>
  <para>
   PEAR, PEAR2 and PECL developers should read the documentation on how to use
   Pyrus to manage your existing or new packages
   <link linkend="pyrus.developers">here</link>.
  </para>

 
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.about.whatis">
 <info><title>What is a "Pyrus"?</title></info>

 <section xml:id="pyrus.about.whatis.intro">
  <info><title>Pyrus</title></info>
  <para>
   In botany (the science of plants), <literal>Pyrus</literal> is the genus of
   the pear family, and thus includes all of the pear-producing trees and
   shrubs under its taxonomical umbrella.
  </para>
  <para>
   In PHP (the hypertext programming language), <literal>Pyrus</literal> is
   the next-generation PEAR Installer, a revolutionary package management
   and distribution system that extends the functionality of the PEAR Installer's
   already advanced functionality.  Pyrus is also friendlier to projects
   outside of PEAR that wish to take advantage of the strengths of PEAR through
   <link linkend="channels">channels</link>.
  </para>
  <para>
   Pyrus represents the cumulative effort of years of work, experience with the
   PEAR Installer since its inception in 1999, and feedback from users like you.
   We are very proud to present the best installation tool for PHP.
  </para>
 </section>
</section>

 </chapter>

  
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:phd="http://www.php.net/ns/phd" version="lillet" xml:id="pyrus.commands">
  <info>
   <title>Commands available in Pyrus</title>
   <author><personname><firstname>Gregory</firstname><surname>Beaver</surname></personname></author>
   <date>2009-06-25</date>
  </info>

  <!-- this thing does not work whatsoever. -->
  <phd:toc phd:toc-depth="3" phd:element="pyrus.commands"/>
  <simpara>
   Commands available for the Pyrus command-line script.
  </simpara>

  
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.commands.install">
 <info><title>install - install a package</title></info>

 <section xml:id="pyrus.commands.install.intro">
  <info><title>Introduction</title></info>
  <para>
   The install command is used to install packages and accepts a list of package
   names to install as arguments.  Unlike
   <link linkend="pyrus.commands.upgrade">upgrade</link>, the install command will
   only install new packages.
  </para>
  <para>
   Install recognizes several different ways of specifying a package:
   <table>
    <title>Ways of specifying a package for installation</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Package type</entry>
       <entry>Local/Remote</entry>
       <entry>Example</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><literal>package.xml</literal> file</entry>
       <entry>Local</entry>
       <entry><userinput>php pyrus.phar install /path/to/package.xml</userinput></entry>
      </row>
      <row>
       <entry>Package release archive</entry>
       <entry>Local</entry>
       <entry><userinput>php pyrus.phar install /path/to/PackageName-1.2.3.tgz</userinput></entry>
      </row>
      <row>
       <entry>Static url</entry>
       <entry>Remote</entry>
       <entry><userinput>php pyrus.phar install http://example.com/PackageName-1.2.3.tgz</userinput></entry>
      </row>
      <row>
       <entry>Abstract package</entry>
       <entry>Remote</entry>
       <entry><userinput>php pyrus.phar install PackageName</userinput></entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </para>
  <para>
   Abstract Packages are documented
   <link linkend="guide.users.concepts.abstractpackage">here</link>.
  </para>
 </section>
 <section xml:id="pyrus.commands.install.optionaldeps">
  <title>--optionaldeps</title>
  <para>
   By default, required package dependencies are also installed.  To also
   automatically install optional dependencies (not dependency groups, but
   dependencies specified using the &lt;optional&gt; tag in package.xml),
   pass the <literal>-o</literal> or <literal>--optionaldeps</literal> option
   to the install command:
  </para>
  <para>
   <screen>php pyrus.phar install -o PackageName</screen>
  </para>
 </section>
 <section xml:id="pyrus.commands.install.plugin">
  <title>--plugin</title>
  <para>
   Plugins (documented <link linkend="pyrus.plugins">here</link>) must be explicitly
   installed with the <literal>-p</literal> or <literal>--plugin</literal> option.
   Plugins are installed into the location specified by the <literal>plugins_dir</literal>
   configuration variable, which defaults to the same location that the user
   configuration file is located (<literal>$HOME/.pear</literal> in unix,
   <literal>&lt;My Documents&gt;\pear</literal> on windows).
  </para>
  <para>
   <screen>php pyrus.phar install -p PEAR2_Pyrus_Developer</screen>
  </para>
 </section>
 <section xml:id="pyrus.commands.install.packagingroot">
  <title>--packagingroot</title>
  <para>
   Developers packaging RPMs or other forms of distribution for OS vendors
   should use the <literal>-r</literal> or <literal>--packagingroot</literal>
   option to install a package into a subdirectory for creating the RPM.
  </para>
  <para>
   <screen>php pyrus.phar install -r /home/myuser/package PackageName</screen>
  </para>
  <para>
   For the example above, if the default Pyrus installation is in
   <literal>/usr/local/lib/pear</literal>, all files will be installed
   into <literal>/home/myuser/package/usr/local/lib/pear</literal>.  Another
   way of understanding this is that the packagingroot option instructs
   Pyrus to treat <literal>/home/myuser/package</literal> as if it were the
   root directory <literal>/</literal>.
  </para>
  <para>
   Developers packaging RPMs or other forms of distribution for OS vendors
   should use the <literal>-r</literal> or <literal>--packagingroot</literal>
   option to install a package into a subdirectory for creating the RPM.
  </para>
  <para>
   <screen>php pyrus.phar install -r /home/myuser/package PackageName</screen>
  </para>
 </section>
 <section xml:id="pyrus.commands.install.force">
  <title>--force</title>
  <para>
   The <literal>--force</literal> or <literal>-f</literal> option can be used
   to force installation if there are errors.  For instance, this can be used
   to override problems in dependency validation, or to force installation of a
   package that is not stable enough.  As such, it should be used sparingly if
   at all.  Better is to request a specific version for installation.
  </para>
 </section>
</section>

  
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.commands.upgrade">
 <info><title>upgrade - upgrade or install a package</title></info>

 <section xml:id="pyrus.commands.upgrade.intro">
  <info><title>Introduction</title></info>
  <para>
   The upgrade command is almost identical to the <link linkend="pyrus.commands.install">install</link>
   command.  The only difference is that upgrade will also upgrade an existing package
   as well as install a new one.
  </para>
  <para>
   The <literal>--packagingroot</literal> option is also unavailable,
   <literal>--packagingroot</literal>
   should only be used for installing new files.
  </para>
 </section>
</section>

  
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.commands.uninstall">
 <info><title>uninstall - remove a package</title></info>

 <section xml:id="pyrus.commands.uninstall.intro">
  <info><title>Introduction</title></info>
  <para>
   The uninstall command removes a package and accepts a list of installed
   packages to remove as arguments.
  </para>
 </section>
 <section xml:id="pyrus.commands.uninstall.plugins">
  <title>--plugin</title>
  <para>
   Plugins (documented <link linkend="pyrus.plugins">here</link>) must be explicitly
   uninstalled with the <literal>-p</literal> or <literal>--plugin</literal> option.
   Plugins are installed into the location specified by the <literal>plugins_dir</literal>
   configuration variable, which defaults to the same location that the user
   configuration file is located (<literal>$HOME/.pear</literal> in unix,
   <literal>&lt;My Documents&gt;\pear</literal> on windows).
  </para>
  <para>
   <screen>php pyrus.phar uninstall -p PEAR2_Pyrus_Developer</screen>
  </para>
 </section>
 <section xml:id="pyrus.commands.uninstall.force">
  <title>--force</title>
  <para>
   The <literal>--force</literal> or <literal>-f</literal> option can be used
   to force uninstallation if there are errors.  For instance, this can be used
   to override problems in dependency validation.  As such, it should be used
   sparingly if at all.  Better is to uninstall the packages tha depend on the
   package being uninstalled.
  </para>
 </section>
</section>

  
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.commands.runscripts">
 <info><title>run-scripts - execute post-install scripts for specified packages</title></info>

 <section xml:id="pyrus.commands.runscripts.intro">
  <info><title>Introduction</title></info>
  <para>
   The <literal>run-scripts</literal> command is used to execute
   post-install scripts of a package.  It accepts a list
   of <link linkend="guide.users.concepts.abstractpackage">abstract package names</link>.</para>
 </section>
</section>

  
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.commands.download">
 <info><title>download - download a package</title></info>

 <section xml:id="pyrus.commands.download.intro">
  <info><title>Introduction</title></info>
  <para>
   This command downloads a remote package to the current directory.  It
   will accept any package name,
   <link linkend="guide.users.concepts.abstractpackage">abstract</link> or
   concrete, and save the resulting file in the current directory.
  </para>
 </section>
</section>


  
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.commands.channeladd">
 <info><title>channel-add - add a channel by its channel.xml</title></info>

 <section xml:id="pyrus.commands.channeladd.intro">
  <info><title>Introduction</title></info>
  <para>
   Add a channel to the registry by its local <literal>channel.xml</literal> file.
   Use <link linkend="pyrus.commands.channeldiscover">channel-discover</link> to
   add a channel by its name.
  </para>
 </section>
</section>

  
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.commands.channeldiscover">
 <info><title>channel-discover - add a channel by channel name</title></info>

 <section xml:id="pyrus.commands.channeldiscover.intro">
  <info><title>Introduction</title></info>
  <para>
   This command searches for a channel.xml first at a secure <literal>https</literal>
   and then unsecured <literal>http</literal> address.
  </para>
  <para>
   Examples:
   <screen>php pyrus.phar channel-discover pear.example.com</screen>
   This tries to locate <literal>https://pear.example.com/channel.xml</literal>
   and if that fails, <literal>http://pear.example.com/channel.xml</literal>,
   then adds the channel to the registry.
  </para>
  <para>
   Use <link linkend="pyrus.commands.channeladd">channel-add</link> to add a
   local channel.xml to the registry.
  </para>
 </section>
</section>

  
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.commands.channeldel">
 <info><title>channel-del - remove a channel</title></info>

 <section xml:id="pyrus.commands.channeldel.intro">
  <info><title>Introduction</title></info>
  <para>
   Remote a channel from the registry.  Note that the default channels cannot
   be removed from the registry.
  </para>
  <para>
   Default channels in Pyrus:
   <itemizedlist>
    <listitem><simpara><literal>__uri</literal></simpara></listitem>
    <listitem><simpara><literal>pear.php.net</literal></simpara></listitem>
    <listitem><simpara><literal>pear2.php.net</literal></simpara></listitem>
    <listitem><simpara><literal>pecl.php.net</literal></simpara></listitem>
    <listitem><simpara><literal>doc.php.net</literal></simpara></listitem>
   </itemizedlist>
  </para>
 </section>
</section>


  
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.commands.info">
 <info><title>info - get information on a package</title></info>

 <section xml:id="pyrus.commands.info.intro">
  <info><title>Introduction</title></info>
  <para>
   This command is used to display a list of information on a package,
   such as the maintainers, the stability and version or versions available
   for installation (for remote packages).
  </para>
  <para>
   If passed <literal>description</literal> or <literal>notes</literal>,
   it displays the complete text of these fields.  If passed <literal>files</literal>,
   it lists the files in the package and their on-disk location for installed
   packages.  For example:
  </para>
  <para>
   <screen>php pyrus.phar info PackageName description</screen>
  </para>
  <para>
   The command will accept any concrete or
   <link linkend="guide.users.concepts.abstractpackage">abstract</link> package
   names as its argument.  Note that if there is an ambiguity between an installed
   package and the remote package, Pyrus will assume that information is being
   requested on the installed package.
  </para>
 </section>
 <section xml:id="pyrus.commands.info.forceremote">
  <title>--forceremote</title>
  <para>
   The <literal>--forceremote</literal> or <literal>-r</literal> option is used
   to instruct Pyrus to resolve any ambiguity between an installed package and
   a remote package to assume that information is requested on the remote package.
  </para>
 </section>
</section>

  
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.commands.list-packages">
 <info><title>list-packages - list all installed packages in all channels</title></info>

 <section xml:id="pyrus.commands.listpackages.intro">
  <info><title>Introduction</title></info>
  <para>
   This command lists all installed packages in all channels, organized
   by the installation location.
  </para>
 </section>
</section>

  
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.commands.listchannels">
 <info><title>list-channels - list known channels</title></info>

 <section xml:id="pyrus.commands.listchannels.intro">
  <info><title>Introduction</title></info>
  <para>
   List all known channels alphabetically.
  </para>
 </section>
</section>

  
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.commands.remotelist">
 <info><title>remote-list - list remote packages on a channel</title></info>

 <section xml:id="pyrus.commands.remotelist.intro">
  <info><title>Introduction</title></info>
  <para>
   The remote-list command lists all remote packages in a channel, organized by
   category.  This command present an alphabetized list of all packages with the
   latest release and package summary. Installed packages are marked with an
   asterisk (<literal>*</literal>).
  </para>
 </section>
 <section xml:id="pyrus.commands.remotelist.basic">
  <title>--basic</title>
  <para>
   If the <literal>--basic</literal> or <literal>-b</literal> option is specified,
   only package name, latest release, and latest stable release are listed.
  </para>
 </section>
</section>

  
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.commands.listupgrades">
 <info><title>list-upgrades - list all available upgrades</title></info>

 <section xml:id="pyrus.commands.listupgrades.intro">
  <info><title>Introduction</title></info>
  <para>
   This command lists all packages that have upgrades available within the
   current <literal>preferred_state</literal> or the installed package's stability,
   whichever is less stable.  This command does not list releases that are
   incompatible with the current PHP version.
  </para>
  <para>
   If package <literal>X</literal> is installed with version <literal>0.3.0</literal>,
   stability <literal>alpha</literal>, and <literal>preferred_state</literal>
   is <literal>stable</literal>, Pyrus will list the newest version available
   that satisfies stability of <literal>alpha</literal>, <literal>beta</literal>
   or <literal>stable</literal>.  If package <literal>Y</literal> is also
   installed, with version <literal>1.2.3</literal>, stability <literal>stable</literal>,
   only the latest stable release will be listed.  In both cases, if the latest
   available version that satisfies these requirements is not found, none will
   be listed.
  </para>
  <para>
   Another example: If package <literal>X</literal> is installed with version
   <literal>1.0.0</literal>, stability <literal>stable</literal>, and the
   <literal>preferred_state</literal> is <literal>alpha</literal>, Pyrus
   will list the newest version available
   that satisfies stability of <literal>alpha</literal>, <literal>beta</literal>
   or <literal>stable</literal>.
  </para>
 </section>
</section>

  
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.commands.upgraderegistry">
 <info><title>upgrade-registry - convert a registry from PEAR format to Pyrus format</title></info>

 <section xml:id="pyrus.commands.upgraderegistry.intro">
  <info><title>Introduction</title></info>
  <para>
   The upgrade-registry command is used to convert a registry from the old
   PEAR Installer format into the new Pyrus format, and then optionally
   remove the old registry.
  </para>
  <para>
   The command creates registries in Sqlite3 and XML formats in the path passed
   as the argument to <literal>upgrade-registry</literal>.  Note that Pyrus
   registries are stored in the parent directory as the installed PHP files,
   whereas PEAR registries are stored in the same directory as the installed
   PHP files, so it is necessary for Pyrus to have write access to the parent
   directory.
  </para>
 </section>
 <section xml:id="pyrus.commands.upgraderegistry.removeold">
  <title>--removeold</title>
  <para>
   The <literal>--removeold</literal> or <literal>-r</literal> option instructs
   Pyrus to remove the old PEAR registry when finished upgrading.
  </para>
 </section>
</section>


  
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.commands.configshow">
 <info><title>config-show - show all configuration values</title></info>

 <section xml:id="pyrus.commands.configshow.intro">
  <info><title>Introduction</title></info>
  <para>
   The <literal>config-show</literal> command lists all system and user
   configuration variables.  Documentation on currently supported
   configuration variables and how Pyrus organizes configuration can be found
   <link linkend="pyrus.configuration">here</link>.
  </para>
 </section>
</section>

  
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.commands.set">
 <info><title>set - set a configuration value</title></info>

 <section xml:id="pyrus.commands.set.intro">
  <info><title>Introduction</title></info>
  <para>
   Set a configuration value.  Documentation on how Pyrus organizes configuration
   values can be found <link linkend="pyrus.configuration">here</link>.  Also
   note that <link linkend="pyrus.commands.mypear">mypear</link> can be used
   as a simpler method of setting the <literal>my_pear_path</literal>
   configuration value.
  </para>
  <para>
   For example:
  </para>
  <para>
   <screen>php pyrus.phar set download_dir /home/blah/downloads</screen>
  </para>
 </section>
</section>

  
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.commands.mypear">
 <info><title>mypear - set the pear path: location of PEAR installations to manage by default</title></info>

 <section xml:id="pyrus.commands.mypear.intro">
  <info><title>Introduction</title></info>
  <para>
   The <literal>mypear</literal> command sets up the path or paths in which Pyrus
   will look for installed packages.  If multiple paths are specified, they
   should be separated by <constant>PATH_SEPARATOR</constant>, which is
   <literal>:</literal> on unix systems, and <literal>;</literal> on Windows-based
   systems.  If multiple paths are specified, only the first path will be
   used for installing packages.  The other paths are only used to validate
   package dependencies.
  </para>
  <para>
   <literal>mypear</literal> is a convenient alternative to using the
   <link linkend="pyrus.commands.set"><literal>set</literal></link> command to
   set the <literal>my_pear_path</literal> configuration variable.
  </para>
 </section>
</section>


  
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.commands.runphpt">
 <info><title>run-phpt - execute PHPT tests</title></info>

 <section xml:id="pyrus.commands.runphpt.intro">
  <info><title>Introduction</title></info>
  <para>
   The <literal>run-phpt</literal> command is used to execute tests in the
   <literal>PHPT</literal> format.  If the <literal>xdebug</literal> extension
   is present, the command can also be used to generate code coverage.  This
   coverage can then be used to construct a coverage report and even to
   intelligently detect both modified tests and tests that are affected by
   changes to the source code in between test runs.
  </para>
  <para>
   The command takes as arguments a list of paths containing tests to execute,
   unless the <literal>--modified</literal> option is specified, then it takes
   as arguments the path to the tests directory and the path to the source
   directory.  If the <literal>--modified</literal> option is not specified,
   and no arguments are passed, the command searches for tests in the current
   working directory.
  </para>
 </section>
 <section xml:id="pyrus.commands.runphpt.modified">
  <title>--modified</title>
  <para>
   The <literal>--modified</literal> or <literal>-m</literal> option, if present,
   implies both the <literal>--recursive</literal> and <literal>--coverage</literal>
   options, and is used to generate a coverage database and to use that database
   to detect modifications in the tests and the source.  These modified tests are
   then executed.
  </para>
  <para>
   The command places a file named <literal>pear2coverage.db</literal> in the
   tests directory, which is an Sqlite3 database containing the coverage information.
   The coverage can be viewed as a web-based report by taking the
   <literal>pear2coverage.phar.php</literal> file installed with the developer
   tools and placing it in a web server directory, and then browsing to it.
   The web server must have the <literal>phar</literal> and <literal>sqlite3</literal>
   extensions enabled in order to function properly.
  </para>
  <para>
   To illustrate how powerful this option is, imagine a hypothetical directory
   structure as follows:
  </para>
  <para>
   <screen>
  src/
      File1.php
      File2.php
      File3.php
  tests/
      test1.phpt
      test2.phpt
      test3.phpt
      test4.phpt
   </screen>
  </para>
  <para>
   Here are the source files:
  </para>
  <para>
   File1.php:
   <programlisting role="php">
    <![CDATA[
<?php
class File1
{
    var $a = 1;
    function __construct($a = 1)
    {
        $this->a = $a;
    }

    function setInternalThing($thing)
    {
        $this->internal = $thing;
        $this->internal->initialize($this);
    }
}
?>
    ]]>
   </programlisting>
  </para>
  <para>
   File2.php:
   <programlisting role="php">
    <![CDATA[
<?php
class File2
{

    function initialize(File1 $parent)
    {
        $parent->a = 2;
    }
}
?>
    ]]>
   </programlisting>
  </para>
  <para>
   File3.php:
   <programlisting role="php">
    <![CDATA[
<?php
class File3 extends File2
{

    function initialize(File1 $parent)
    {
        $parent->a = 3;
    }
}
?>
    ]]>
   </programlisting>
  </para>
  <para>
   test1.phpt:
   <programlisting role="php">
    <![CDATA[
--TEST--
test 1
--FILE--
<?php
function __autoload($class) { include __DIR__ . '/../src/' . $class . '.php'; }

$test = new File1(6);
if ($test->a != 6) {
    echo '$a is not 6, it is ' . $test->a, "\n";
}
?>
===DONE===
--EXPECT--
===DONE===
    ]]>
   </programlisting>
  </para>
  <para>
   test2.phpt:
   <programlisting role="php">
    <![CDATA[
--TEST--
test 2
--FILE--
<?php
function __autoload($class) { include __DIR__ . '/../src/' . $class . '.php'; }

$test2 = new File2;

$test = new File1;
$test->setInternalThing($test2);

if ($test->a != 2) {
    echo '$a is not 2, it is ' . $test->a, "\n";
}
?>
===DONE===
--EXPECT--
===DONE===
    ]]>
   </programlisting>
  </para>
  <para>
   test3.phpt:
   <programlisting role="php">
    <![CDATA[
--TEST--
test 3
--FILE--
<?php
function __autoload($class) { include __DIR__ . '/../src/' . $class . '.php'; }

$test2 = new File2;

$test = new stdClass;
$test2->initialize($test);

if ($test->a != 2) {
    echo '$a is not 2, it is ' . $test->a, "\n";
}
?>
===DONE===
--EXPECT--
===DONE===
    ]]>
   </programlisting>
  </para>
  <para>
   test4.phpt:
   <programlisting role="php">
    <![CDATA[
--TEST--
test 4
--FILE--
<?php
function __autoload($class) { include __DIR__ . '/../src/' . $class . '.php'; }

$test3 = new File3;

$test = new File1;
$test->setInternalThing($test3);

if ($test->a != 3) {
    echo '$a is not 3, it is ' . $test->a, "\n";
}
?>
===DONE===
--EXPECT--
===DONE===
    ]]>
   </programlisting>
  </para>
  <para>
   If a modification is made to <literal>File3.php</literal>, the
   run-phpt command will detect that only <literal>test4.phpt</literal> uses
   this file, and will run that test.  If a modification is made to
   <literal>File2.php</literal>, <literal>test2.phpt</literal>,
   <literal>test3.phpt</literal> and <literal>test4.phpt</literal> will all be
   executed, even though <literal>test4.phpt</literal> does not directly
   use the <literal>File2</literal> class, because <literal>File3</literal>
   extends <literal>File2</literal> and so the file is loaded.  If a modification
   is made to <literal>File1.php</literal>, <literal>test1.phpt</literal>,
   <literal>test2.phpt</literal> and <literal>test4.phpt</literal> will all
   be executed.  Finally, if any of the phpt test files are executed, or any
   external files that they include are modified, they will be run again.  If a
   new test, <literal>test5.phpt</literal> is added, the run-phpt command will
   also detect the test and run it.
  </para>
  <para>
   This allows extremely efficient development, as surgically running only
   tests that are affected by source code changes allows assurance that even
   the most remote file dependencies are validated, and irrelevant tests are not
   executed unnecessarily.  By relying upon the coverage report, it is also
   easy to catch subtle logic bugs preventing code blocks from being
   executed, resulting in far more robust code much faster.  Pyrus itself
   was developed using this technique.
  </para>
 </section>
 <section xml:id="pyrus.commands.runphpt.recursive">
  <title>--recursive</title>
  <para>
   The <literal>--recursive</literal> or <literal>-r</literal> option causes Pyrus
   to recursively traverse directories specified
  </para>
 </section>
 <section xml:id="pyrus.commands.runphpt.coverage">
  <title>--coverage</title>
  <para>
   the <literal>--coverage</literal> or <literal>-x</literal> option causes
   Pyrus to record coverage using the <literal>xdebug</literal> extension's
   code coverage capabilities.
  </para>
 </section>
</section>

  
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.commands.generatepear2">
 <info><title>generate-pear2 - Create the subversion source layout for a PEAR2 package</title></info>

 <section xml:id="pyrus.commands.generatepear2.intro">
  <info><title>Introduction</title></info>
  <para>
   The <literal>generate-pear2</literal> command is used to create a bare
   skeleton for a new PEAR2 package. It creates everything needed except the
   source code.
  </para>
  <para>
   Two arguments are accepted, <literal>package</literal> and optionally
   <literal>channel</literal>.
  </para>
 </section>
 <section xml:id="pyrus.commands.generatepear2.package">
  <title>package</title>
  <para>
   The <literal>package</literal> argument is the name of the package to create
   a skeleton for. This is used as the directory name and as the package name
   used within files related to creating a PEAR2 package.
  </para>
  <para>
   If <literal>MyPackage</literal> is passed, a directory will be created in
   the current working directory titled <literal>MyPackage</literal>. All the
   required packaging files will be within this directory, and you can place
   your code within the <literal>MyPackage/src/MyPackage/Main.php</literal>
   file.
  </para>
  <note>
   <para>
    If no channel is specified <literal>PEAR2_MyPackage</literal> will be the
    name of your package if <literal>MyPackage</literal> is passed as the
    package name.
   </para>
  </note>
 </section>
 <section xml:id="pyrus.commands.generatepear2.channel">
  <title>channel</title>
  <para>
   The <literal>channel</literal> argument defaults to pear2.php.net.
  </para>
 </section>
</section>

  
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.commands.generateext">
 <info><title>generate-ext - Create the subversion source layout for a new PHP extension that is PECL-ready</title></info>

 <section xml:id="pyrus.commands.generateext.intro">
  <info><title>Introduction</title></info>
  <para>
   The <literal>generate-pecl</literal> command is used to create a bare
   skeleton for a new PECL package or PHP extension as it will reside in
   Subversion. This is designed to provide all of the functionality of the
   ext_skel command but also generates a package.xml and other files that can
   be used to automatically update for a release.
  </para>
  <para>
   One argument is accepted, <literal>extension</literal>.
  </para>
  <para>
  This command automatically creates class definitions as well as ZEND_ARG_INFO
  for parameters to provide useful reflection to your extension's users.
  </para>
 </section>
 <section xml:id="pyrus.commands.generateext.extension">
  <title>extension</title>
  <para>
   The <literal>extension</literal> argument is the name of the package to create
   a skeleton for. This is used as the directory name and as the extension name
   used within files related to creating a PECL package.
  </para>
 </section>
 <section xml:id="pyrus.commands.generateext.proto">
  <title>--proto</title>
  <para>
   The <literal>--proto</literal> or <literal>-p</literal> option specifies a
   file containing function and method prototypes to create in your new extension.
  </para>
  <para>
   As an example, here are some supported protos:
   <itemizedlist>
    <listitem>
     <simpara>
      <literal>
       int myfunc(string firstarg, unicode secondarg, array thirdarg,
       object fourtharg [, double optionalarg1
       [, float optionalarg2 [, callback optionalarg3 [, text optionalarg4]]]])
      </literal>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <literal>
       void Myclass::myfunc(array|object arg1, bool arg2, class arg3,
       resource arg4, mixed arg5 [, ... varargs])
      </literal>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <literal>
       static int Myclass::staticfunc()
      </literal>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <literal>
       protected string Myclass::otherguy([mixed optionalarg])
      </literal>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <literal>
       static protected object Myclass::factory(text path)
      </literal>
     </simpara>
    </listitem>
   </itemizedlist>
  </para>
  <para>
   A proto begins with either the return type or access modifiers
   <literal>static</literal> and one of <literal>public</literal>,
   <literal>protected</literal> and <literal>private</literal> followed
   by the return type.  Next, the name of the function, or name of the
   class::method is specified, followed by an argument list.  Optional
   methods are enclosed in <literal>[brackets]</literal> and whitespace
   is important, so follow the conventions as in the above examples.
  </para>
  <para>
   Each argument consists of a type followed by an argument name.  The types are
   informed by parameter parsing as supported by PHP's internal
   <function>zend_parse_parameters</function>.  This is thoroughly documented
   in the file <literal>README.PARAMETER_PARSING</literal> inside PHP's
   source code.  Note that some of the parameter parsing choices only work
   in PHP 6, in particular the unicode-related options.
  </para>
  <para>
   The following types are supported:
   <itemizedlist>
    <listitem>
     <simpara>
      <literal>array</literal> (maps to <literal>'a'</literal> in parameter parsing)
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <literal>array|object</literal> (maps to <literal>'A'</literal> in parameter parsing)
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <literal>bool</literal> (maps to <literal>'b'</literal> in parameter parsing)
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <literal>boolean</literal> (maps to <literal>'b'</literal> in parameter parsing)
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <literal>callback</literal> (maps to <literal>'f'</literal> in parameter parsing)
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <literal>class</literal> (Maps to <literal>'C'</literal> in parameter parsing)
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <literal>double</literal> (maps to <literal>'d'</literal> in parameter parsing)
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <literal>float</literal> (maps to <literal>'d'</literal> in parameter parsing)
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <literal>handle</literal> (maps to <literal>'r'</literal> in parameter parsing)
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <literal>int</literal> (Maps to <literal>'L'</literal> in parameter parsing)
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <literal>long</literal> (Maps to <literal>'L'</literal> in parameter parsing)
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <literal>mixed</literal> (maps to <literal>'z'</literal> in parameter parsing)
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <literal>object</literal> (maps to <literal>'o'</literal> in parameter parsing)
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <literal>resource</literal> (maps to <literal>'r'</literal> in parameter parsing)
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <literal>string</literal> (maps to <literal>'s'</literal> in parameter parsing)
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <literal>text</literal> (Maps to <literal>'T'</literal> in parameter parsing)
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <literal>unicode</literal> (maps to <literal>'u'</literal> in parameter parsing)
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <literal>void</literal>, use only for the return value of a function that returns nothing
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <literal>...</literal> (varags: maps to <literal>'*'</literal> in parameter parsing)
      However, if the parameter is not optional, if maps to <literal>'+'</literal>
      is used.
     </simpara>
    </listitem>
   </itemizedlist>
  </para>
 </section>
</section>

  
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.commands.make">
 <info><title>make - create a package.xml from its source directory</title></info>

 <section xml:id="pyrus.commands.make.intro">
  <info><title>Introduction</title></info>
  <note>
   <simpara>
    The <literal>make</literal> command is available through the developer tools.
    If you do not have the developer tools installed, simply run
   </simpara>
   <screen>php pyrus.phar make</screen>
   <simpara>
    and Pyrus will ask if you would like to install the developer tools.  If you
    assent with the word <literal>yes</literal>, Pyrus will automatically
    download them and install them for you.
   </simpara>
  </note>
  <para>
   This command creates a package.xml file from a standard PEAR2 directory layout,
   and then optionally creates a package release.
  </para>
  <para>
   This command looks for these standard files:
   <itemizedlist>
    <listitem><simpara><literal>CREDITS</literal></simpara></listitem>
    <listitem><simpara><literal>README</literal></simpara></listitem>
    <listitem><simpara><literal>RELEASE-X.Y.Z</literal> (where X.Y.Z is the release version)</simpara></listitem>
    <listitem><simpara><literal>API-X.Y.Z</literal> (where X.Y.Z is the API version)</simpara></listitem>
   </itemizedlist>

   and for a standard directory layout of

   <table>
    <title>Standard directory layout</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Sub-directory</entry>
       <entry>Description</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><literal>src/</literal></entry>
       <entry>PHP files</entry>
      </row>
      <row>
       <entry><literal>data/</literal></entry>
       <entry>Data files</entry>
      </row>
      <row>
       <entry><literal>test/</literal></entry>
       <entry>Test files</entry>
      </row>
      <row>
       <entry><literal>doc/</literal></entry>
       <entry>Documentation files</entry>
      </row>
      <row>
       <entry><literal>examples/</literal></entry>
       <entry>Example files (documentation)</entry>
      </row>
      <row>
       <entry><literal>scripts/</literal></entry>
       <entry>Executable files, scripts</entry>
      </row>
      <row>
       <entry><literal>www/</literal></entry>
       <entry>Web files</entry>
      </row>
      <row>
       <entry><literal>customrole/</literal></entry>
       <entry>Custom installer role XML definition files</entry>
      </row>
      <row>
       <entry><literal>customtask/</literal></entry>
       <entry>Custom installer task XML definition files</entry>
      </row>
      <row>
       <entry><literal>customcommand/</literal></entry>
       <entry>Custom command XML definition files</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </para>
  <para>
   The <literal>CREDITS</literal> file must have this format:

   <programlisting role="txt">
    <![CDATA[
;; comments ignored
Maintainer One [handle1] <email@example.com> (role)
Maintainer Two [handle2] <email@example.com> (role)
    ]]>
   </programlisting>

   Where role is one of <literal>lead</literal>, <literal>developer</literal>,
   <literal>contributor</literal>, or <literal>helper</literal>.
  </para>
  <para>
   The first line of <literal>README</literal> is used as the summary of the
   package, the rest is used as the description.
   <literal>RELEASE-X.Y.Z</literal> is used as the release notes.  Pyrus will
   scan all release notes (such as <literal>RELEASE-1.0.0</literal> and
   <literal>RELEASE-1.2.3</literal>) and use the most recent version number
   (<literal>1.2.3</literal> in our example) as the version, and the contents
   of the file (<literal>RELEASE-1.2.3</literal> in our example) as the release
   notes.
  </para>
  <para>
   <literal>API-X.Y.Z</literal> is used as notes about the
   <link linkend="guide.users.concepts.api">API</link> and the version
   <literal>X.Y.Z</literal> is used as the API version.
  </para>
 </section>
 <section xml:id="pyrus.commands.make.packagexmlsetup">
  <title>--packagexmlsetup</title>
  <para>
   if <literal>--packagexmlsetup</literal> or <literal>-s</literal> is specified,
   it should be passed the name of a file in the package base directory that is
   used to fine-tune the generated package.xml.  This file should work with variable
   <literal>$package</literal> for modifying the package.xml, and
   <literal>$compatible</literal> for the compatible
   one (if present).  If --packagexmlsetup is not specified, and
   <literal>packagexmlsetup.php</literal>
   exists in the package base directory, it will be used.
  </para>
  <para>
   Here is an example <literal>packagexmlsetup.php</literal>:
   <programlisting role="php">
    <![CDATA[
<?php
$package->dependencies['required']->package['pear2.php.net/PEAR2_Autoload']->save();
$package->dependencies['required']->package['pear2.php.net/PEAR2_Exception']->save();
$package->dependencies['required']->package['pear2.php.net/PEAR2_MultiErrors']->save();

$compatible->dependencies['required']->package['pear2.php.net/PEAR2_Autoload']->save();
$compatible->dependencies['required']->package['pear2.php.net/PEAR2_Exception']->save();
$compatible->dependencies['required']->package['pear2.php.net/PEAR2_MultiErrors']->save();
?>
    ]]>
   </programlisting>
  </para>
 </section>
 <section xml:id="pyrus.commands.make.nocompatible">
  <title>--nocompatible</title>
  <para>
   If <literal>--nocompatible</literal> or <literal>-n</literal> option
   is passed in, Pyrus will not generate a package.xml that is compatible
   with the PEAR Installer.
  </para>
 </section>
 <section xml:id="pyrus.commands.make.package">
  <title>--package</title>
  <para>
   This option instruct the <literal>make</literal> command to pass off the
   finished package.xml to the
   <link linkend="pyrus.commands.package"><literal>package</literal></link>
   command.  It accepts a comma-delimited list of file formats, and can be any
   of <literal>phar</literal>, <literal>tar</literal>, <literal>tgz</literal>
   or <literal>zip</literal>.
  </para>
 </section>
 <section xml:id="pyrus.commands.make.stub">
  <title>--stub</title>
  <para>
   This option is identical to the option for the
   <link linkend="pyrus.commands.package.stub"><literal>--stub</literal></link>
   option of the <link linkend="pyrus.commands.package"><literal>package</literal></link>
   command, and is ignored if <literal>--package</literal> or <literal>-p</literal>
   is not also specified.
  </para>
 </section>
 <section xml:id="pyrus.commands.make.extrasetup">
  <title>--extrasetup</title>
  <para>
   This option is identical to the option for the
   <link linkend="pyrus.commands.package.extrasetup"><literal>--extrasetup</literal></link>
   option of the <link linkend="pyrus.commands.package"><literal>package</literal></link>
   command, and is ignored if <literal>--package</literal> or <literal>-p</literal>
   is not also specified.
  </para>
 </section>
</section>

  
<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="lillet" xml:id="pyrus.commands.package">
 <info><title>package - create a packaged release in phar, tar, tgz or zip format</title></info>

 <section xml:id="pyrus.commands.package.intro">
  <info><title>Introduction</title></info>
  <note>
   <simpara>
    The <literal>package</literal> command is available through the developer tools.
    If you do not have the developer tools installed, simply run
   </simpara>
   <screen>php pyrus.phar package</screen>
   <simpara>
    and Pyrus will ask if you would like to install the developer tools.  If you
    assent with the word <literal>yes</literal>, Pyrus will automatically
    download them and install them for you.
   </simpara>
  </note>
  <para>
   The package command bundles up the files of a package and its package.xml
   into an archive for distribution.  It accepts a single optional argument, the
   path to a package.xml.
  </para>
  <para>
   If the optional path is not provided, the command
   searches for a file named <literal>package.xml</literal> in the current
   directory.  If this file is an older version 1.0, it also searches for
   <literal>package2.xml</literal> in the current directory, and uses that
   as the package file.  This allows creating packages that are compatible
   with ancient versions of PEAR older than version <literal>1.4.0</literal>
  </para>
  <para>
   If <literal>package.xml</literal> exists and is
   a PEAR2 package (requires pear installer version equal to or newer than
   <literal>2.0.0a1</literal>), the command will also look for a file
   in the current directory named <literal>package_compatible.xml</literal>.
   This file should be a package.xml customized for use by the PEAR Installer,
   and is automatically generated by the <link linkend="pyrus.commands.make">make</link>
   command unless explicitly prevented.  This file makes it possible for the
   PEAR Installer to install packages generated for Pyrus.
  </para> 
  <para>
   The created archive can be in any or all
   of the following formats:
   <orderedlist>
    <listitem><simpara>phar</simpara></listitem>
    <listitem><simpara>tar</simpara></listitem>
    <listitem><simpara>tgz</simpara></listitem>
    <listitem><simpara>zip</simpara></listitem>
   </orderedlist>
  </para>
  <para>
   The formats are requested by passing their name as an option like so:
   <screen>php pyrus.phar package --phar --tar --tgz --zip</screen>.
  </para>
  <para>
   The <literal>phar</literal> file format is a format that can be used to
   create self-installing archives, or even archives that are self-contained
   commands.  <literal>pyrus.phar</literal>, for instance, is a complete
   application that runs directly from its archive.  Due to security
   considerations, the ability to create executable phar archives is disabled
   by default.  To create a phar archive, the <literal>phar.readonly</literal>
   php.ini setting must be disabled like so:
  </para>
  <screen>php -dphar.readonly=0 pyrus.phar package --phar</screen>
  <para>
   The <literal>tar</literal> and <literal>tgz</literal> file formats are the
   formats familiar to users of PEAR.  <literal>tgz</literal> is a gzipped tar
   archive, and requires the <literal>zlib</literal> extension be enabled in
   order to create it.
  </para>
  <para>
   The <literal>zip</literal> file format is most familiar to Windows users.
  </para>
 </section>
 <section xml:id="pyrus.commands.package.pear2">
  <title>PEAR2 packages</title>
  <para>
   All packages designed for Pyrus automatically have <literal>PEAR2/Autoload.php</literal>,
   <literal>PEAR2/Exception.php</literal>, <literal>PEAR2/MultiErrors.php</literal>,
   and <literal>PEAR2/MultiErrors/Exception.php</literal> bundled so that
   these dependencies are available when a package is extracted without use of
   Pyrus to install it.  Packages designed for installation by the PEAR Installer
   and not for Pyrus do not bundle any dependencies.
  </para>
 </section>
 <section xml:id="pyrus.commands.package.signing">
  <title>Package signing</title>
  <para>
   Pyrus supports creating archives that have a mandatory signature using
   <literal>OpenSSL</literal> certificates such as those available from
   <link xlink:href="http://www.cacert.org">CACert</link>.  Signed archives
   cannot be processed without the presence of the <literal>openssl</literal>
   PHP extension.  In addition, a bug in the <literal>phar</literal> extension's
   verification of openssl signatures requires PHP version <literal>5.3.1</literal>
   or newer.  Creation of signatures only requires PHP version <literal>5.3.0</literal>
   or newer.
  </para>
  <para>
   To create a package signature, set the
   <link linkend="pyrus.configuration.user.opensslcert">openssl_cert</link>
   configuration variable to the path of your PKCS#12 certificate (generally
   saved with a file extension of <literal>p12</literal>), and the
   <link linkend="pyrus.configuration.user.handle">handle</link>
   configuration variable to your handle in package.xml.
  </para>
 </section>
 <section xml:id="pyrus.commands.package.stub">
  <title>--stub</title>
  <para>
   The <literal>--stub</literal> or <literal>-s</literal> option specifies
   a PHP script to use as the stub to a phar archive, and is ignored if
   <literal>--phar</literal> is not passed to the command.  The stub is a
   short executable script that is executed as a boot strap when a phar
   archive is passed to PHP like <screen>php pyrus.phar</screen>.  All stubs
   must end with the <literal>__HALT_COMPILER();</literal> directive to be a
   valid stub.
  </para>
  <para>
   If the <literal>--stub</literal> option is not explicitly specified and
   a phar archive is being created, Pyrus will look for a file named
   <literal>stub.php</literal> in the same directory as the package.xml, and
   will use that as the stub for the phar archive if found.
  </para>
  <para>
   Here is pyrus's stub:
  </para>
  <para>
   <programlisting role="php">
    <![CDATA[
<?php
if (version_compare(phpversion(), '5.3.0', '<')) {
    if (substr(phpversion(), 0, 5) != '5.3.0') {
        // this small hack is because of running RCs of 5.3.0
        echo "Pyrus requires PHP 5.3.0 or newer.\n";
        exit -1;
    }
}
foreach (array('phar', 'spl', 'pcre', 'simplexml') as $ext) {
    if (!extension_loaded($ext)) {
        echo 'Extension ', $ext, " is required\n";
        exit -1;
    }
}
try {
    Phar::mapPhar();
} catch (Exception $e) {
    echo "Cannot process Pyrus phar:\n";
    echo $e->getMessage(), "\n";
    exit -1;
}
function pyrus_autoload($class)
{
    $class = str_replace('_', '\\', $class);
    if (file_exists('phar://' . __FILE__ . '/php/' . implode('/', explode('\\', $class)) . '.php')) {
        include 'phar://' . __FILE__ . '/php/' . implode('/', explode('\\', $class)) . '.php';
    }
}
spl_autoload_register("pyrus_autoload");
$frontend = new \PEAR2\Pyrus\ScriptFrontend\Commands;
@array_shift($_SERVER['argv']);
$frontend->run($_SERVER['argv']);
__HALT_COMPILER();
    ]]>
   </programlisting>
  </para>
 </section>
 <section xml:id="pyrus.commands.package.extrasetup">
  <title>--extrasetup</title>
  <para>
   The <literal>--extrasetup</literal> or <literal>-e</literal> option
   is used to specify the path to a PHP script that is used to include
   files in the created packages that are not in the package.xml list of
   files.  This is used to create archives that are designed to be friendly to
   users simply <quote>trying before they buy</quote> the archive, or to provide
   support files needed to create self-installing archives.
  </para>
  <para>
   If the <literal>--extrasetup</literal> option is not explicitly specified,
   then Pyrus looks for a file named <literal>extrasetup.php</literal> in the
   same directory as the package.xml, and will use this if found.
  </para>
  <para>
   The extrasetup script should create a variable named <literal>$extrafiles</literal>
   that contains an associative array mapping relative path within the archive
   to an absolute path of a file on disk.
  </para>
  <para>
   Here is Pyrus's extrasetup, which demonstrates bundling of the required
   dependencies PEAR2_HTTP_Request and PEAR2_Console_Commandline:
  </para>
  <para>
   <programlisting role="php">
    <![CDATA[
<?php
/**
 * This file generates the pyrus.phar file and PEAR2 package for Pyrus.
 */
$rp = __DIR__ . '/../HTTP_Request/src/HTTP';
$cc = __DIR__ . '/../sandbox/Console_CommandLine/src/Console';
$extrafiles = array(
    'php/PEAR2/HTTP/Request.php' => $rp . '/Request.php',
    'php/PEAR2/HTTP/Request/Adapter.php' => $rp . '/Request/Adapter.php',
    'php/PEAR2/HTTP/Request/Adapter/Curl.php' => $rp . '/Request/Adapter/Curl.php',
    'php/PEAR2/HTTP/Request/Adapter/Http.php' => $rp . '/Request/Adapter/Http.php',
    'php/PEAR2/HTTP/Request/Adapter/Phpsocket.php' => $rp . '/Request/Adapter/Phpsocket.php',
    'php/PEAR2/HTTP/Request/Adapter/Phpstream.php' => $rp . '/Request/Adapter/Phpstream.php',
    'php/PEAR2/HTTP/Request/Exception.php' => $rp . '/Request/Exception.php',
    'php/PEAR2/HTTP/Request/Headers.php' => $rp . '/Request/Headers.php',
    'php/PEAR2/HTTP/Request/Listener.php' => $rp . '/Request/Listener.php',
    'php/PEAR2/HTTP/Request/Response.php' => $rp . '/Request/Response.php',
    'php/PEAR2/HTTP/Request/Uri.php' => $rp . '/Request/Uri.php',

    'php/PEAR2/Console/CommandLine.php' => $cc . '/CommandLine.php',
    'php/PEAR2/Console/CommandLine/Result.php' => $cc . '/CommandLine/Result.php',
    'php/PEAR2/Console/CommandLine/Renderer.php' => $cc . '/CommandLine/Renderer.php',
    'php/PEAR2/Console/CommandLine/Outputter.php' => $cc . '/CommandLine/Outputter.php',
    'php/PEAR2/Console/CommandLine/Option.php' => $cc . '/CommandLine/Option.php',
    'php/PEAR2/Console/CommandLine/MessageProvider.php' => $cc . '/CommandLine/MessageProvider.php',
    'php/PEAR2/Console/CommandLine/Exception.php' => $cc . '/CommandLine/Exception.php',
    'php/PEAR2/Console/CommandLine/Element.php' => $cc . '/CommandLine/Element.php',
    'php/PEAR2/Console/CommandLine/Command.php' => $cc . '/CommandLine/Command.php',
    'php/PEAR2/Console/CommandLine/Argument.php' => $cc . '/CommandLine/Argument.php',
    'php/PEAR2/Console/CommandLine/Action.php' => $cc . '/CommandLine/Action.php',
    'php/PEAR2/Console/CommandLine/Renderer/Default.php' => $cc . '/CommandLine/Renderer/Default.php',
    'php/PEAR2/Console/CommandLine/Outputter/Default.php' => $cc . '/CommandLine/Outputter/Default.php',
    'php/PEAR2/Console/CommandLine/MessageProvider/Default.php' => $cc . '/CommandLine/MessageProvider/Default.php',
    'php/PEAR2/Console/CommandLine/Action/Callback.php' => $cc . '/CommandLine/Action/Callback.php',
    'php/PEAR2/Console/CommandLine/Action/Counter.php' => $cc . '/CommandLine/Action/Counter.php',
    'php/PEAR2/Console/CommandLine/Action/Help.php' => $cc . '/CommandLine/Action/Help.php',
    'php/PEAR2/Console/CommandLine/Action/StoreFloat.php' => $cc . '/CommandLine/Action/StoreFloat.php',
    'php/PEAR2/Console/CommandLine/Action/StoreInt.php' => $cc . '/CommandLine/Action/StoreInt.php',
    'php/PEAR2/Console/CommandLine/Action/StoreString.php' => $cc . '/CommandLine/Action/StoreString.php',
    'php/PEAR2/Console/CommandLine/Action/StoreTrue.php' => $cc . '/CommandLine/Action/StoreTrue.php',
    'php/PEAR2/Console/CommandLine/Action/Version.php' => $cc . '/CommandLine/Action/Version.php',
);
    ]]>
   </programlisting>
  </para>
 </section>
</section>


  
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.commands.pickle">
 <info><title>pickle - automatically create a PECL package.xml and package release from source directory</title></info>

 <section xml:id="pyrus.commands.pickle.intro">
  <info><title>Introduction</title></info>
  <para>
   The pickle command is designed to make the creation of an extension for
   <acronym>PECL</acronym> developers very easy.  It scans a SVN checkout
   of a PECL package directory, generates package.xml, and packages a
   release in one step.
  </para>
  <para>
   The pickle command looks for these standard files:

   <itemizedlist>
    <listitem><simpara>CREDITS</simpara></listitem>
    <listitem><simpara>README</simpara></listitem>
    <listitem><simpara>RELEASE-X.Y.Z (where X.Y.Z is the release version)</simpara></listitem>
    <listitem><simpara>API-X.Y.Z (where X.Y.Z is the API version)</simpara></listitem>
   </itemizedlist>

   and for a standard directory layout of

<screen>
/                Extension source files
data/            Data files
tests/           Test files
doc/             Documentation files
examples/        Example files (documentation)
</screen>

   The CREDITS file must have this format for the pickle command to recognize it:

<screen>
 <![CDATA[
;; extensionname
Maintainer One [handle1] <email@example.com> (role)
Maintainer Two [handle2] <email@example.com> (role)
 ]]>
</screen>

   Where role is one of lead, developer, contributor, helper.

   The first line of README is used as the summary of the package.
   RELEASE-X.Y.Z is used as the release notes.
  </para>
  <para>
   <literal>X.Y.Z</literal> in the filename <literal>RELEASE-X.Y.Z</literal> is
   also used to automatically calculate the stability, and
   <literal>X.Y.Z</literal> in the filename <literal>API-X.Y.Z</literal> is used
   to calculate the API stability.  The formula is relatively simple: if X is
   <literal>0</literal>, the stability is set to <literal>alpha</literal>.
   Otherwise, if X is <literal>1</literal> or greater, the following methods are
   used to calculate the stability.
   <itemizedlist>
    <listitem>
     <para>
      If Z contains <literal>a</literal> as in the version <literal>1.0.0a1</literal>
      the stability is set to <literal>alpha</literal>
     </para>
    </listitem>
    <listitem>
     <para>
      If Z contains <literal>b</literal> as in the version <literal>1.0.0b1</literal>
      the stability is set to <literal>beta</literal>
     </para>
    </listitem>
    <listitem>
     <para>
      If Z contains <literal>RC</literal> as in the version <literal>1.0.0RC1</literal>
      the stability is set to <literal>beta</literal>
     </para>
    </listitem>
    <listitem>
     <para>
      Otherwise, stability is set to <literal>stable</literal>.
     </para>
    </listitem>
   </itemizedlist>
  </para>
 </section>
 <section xml:id="pyrus.commands.pickle.args">
  <title>Arguments to the pickle command</title>
  <para>
   The pickle command has 4 arguments:
   <screen>php pyrus.phar pickle extname channelname /path/to/packagedir extensions...</screen>
  </para>
  <para>
   <literal>/path/to/packagedir</literal> specifies the location in which to
   package up the release.  If not present, it defaults to the current working
   directory.  The pickle command usually should be executed from that directory,
   this argument is present to allow batch creation of package.xml files for
   multiple extensions with a single shell script.
  </para>
  <para>
   If <literal>package.xml</literal> does not exist in the location packaging
   will take place, then the first argument is required.  The first argument
   is the name of the package, which is usually the same name as the extension,
   and the second argument is the channel name.  If not specified, the package
   is assumed to be in the <literal>pecl.php.net</literal> channel.
  </para>
  <para>
   The final argument, <literal>extensions</literal> is a list of file extensions
   that should be considered source files.  By default, the file extensions
   recognized as source files are:

   <itemizedlist>
    <listitem><simpara>c</simpara></listitem>
    <listitem><simpara>cc</simpara></listitem>
    <listitem><simpara>h</simpara></listitem>
    <listitem><simpara>m4</simpara></listitem>
    <listitem><simpara>w32</simpara></listitem>
    <listitem><simpara>re</simpara></listitem>
    <listitem><simpara>y</simpara></listitem>
    <listitem><simpara>l</simpara></listitem>
    <listitem><simpara>frag</simpara></listitem>
   </itemizedlist>
  </para>
 </section>
 <section xml:id="pyrus.commands.pickle.donotpackage">
  <title>--donotpackage</title>
  <para>
   If <literal>--donotpackage</literal> or <literal>-n</literal> is specified,
   then the pickle command will only generate package.xml, and will not
   package up a release.  The <link linkend="pyrus.commands.package">package</link>
   command can be used to build the release after reviewing package.xml.
  </para>
 </section>
</section>

  
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.commands.build">
 <info><title>build - build a PECL PHP extension package</title></info>

 <section xml:id="pyrus.commands.build.intro">
  <info><title>Introduction</title></info>
  <para>
   This command builds an installed PECL extension.  It accepts as its
   arguments a list of installed php extension packages to build.
   It performs an automatic version of:
  </para>
  <para>
   <screen>
phpize --clean
phpize
./configure
make
make install
   </screen>
  </para>
  <para>
   In the source directory of the package.  It also will prompt the user
   if any <literal>&lt;configureoption&gt;</literal> tags exist in package.xml
   (see the documentation for <literal>&lt;configureoption&gt;</literal>
   <link linkend="guide.developers.package2.pecl">here</link>)
  </para>
 </section>
</section>

  
 </chapter>

  
<chapter xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.configuration">
  <info>
   <title>Pyrus configuration</title>
   <author><personname><firstname>Gregory</firstname><surname>Beaver</surname></personname></author>
   <date>2009-06-26</date>
  </info>

  <para>
   Pyrus has two kinds of configuration files, system configuration files, which
   are stored directly in the installation location, and user configuration files,
   which are stored in the home directory of the user, or in the Windows
   equivalent, <literal>My Documents</literal>.
  </para>
  <para>
   Each installation is tightly bound to the configuration that defines where
   files should be installed, which PHP executable to use, and which php.ini
   is used to manage that installation.
  </para>
  <para>
   On the other hand, user-specific preferences are tightly bound to each
   user, by placing them in the user's home directory.  These values are
   universal to all installations and include things like the amount of
   information to display, the preferred mirror to use for a channel, the
   openssl certificate to use for package signing, and so on.
  </para>
  <para>
   This way, multiple PEAR installations can be managed very safely without
   ambiguity over what configuration values should be used.
  </para>

  
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.configuration.user">
 <info><title>Pyrus user configuration variables</title></info>

 <section xml:id="pyrus.configuration.user.intro">
  <info><title>Introduction</title></info>
  <para>
   The user configuration file is always stored in the user's personal directory,
   the home directory on unix, and <literal>My Documents</literal> on Windows.
   For a unix user with username <literal>user</literal>, the user configuration
   file is stored in <literal>/home/user/.pear/pearconfig.xml</literal>.  For
   a Windows user, the configuration is stored in
   <literal>My Documents\pear\pearconfig.xml</literal>.  The file is saved in
   XML format and can be hand-edited if necessary.
  </para>
  <para>
   Unlike the system configuration file, the user configuration file is always
   saved when an operation that writes to disk is called, such as installing
   a package.  On startup, Pyrus uses the configuration file's existence to
   determine whether it is being executed for the first time, and if so, prompts
   the user to initialize a few default settings such as the PEAR path.
  </para>
  <para>
   There are two kinds of user configuration variables, installation-wide variables
   such as <literal>verbose</literal>, and channel-specific variables such as
   <literal>openssl_cert</literal>.  Channel-specific variables can have different
   values for different channels.  This allows setting a different certificate
   for each channel, for instance.  The channel name is used as a tag, with
   non-XML friendly characters translated into simple mnemonics (such as
   <literal>.</literal> becoming <literal>DOT</literal>).
  </para>
  <para>
   Here is a sample user configuration file (with line breaks added for readability):
  </para>
  <para>
   <programlisting role="xml">
    <![CDATA[
<?xml version="1.0"?>
<pearconfig version="1.0">
 <default_channel>pear2.php.net</default_channel>
 <auto_discover>0</auto_discover>
 <http_proxy></http_proxy>
 <cache_dir>/home/user/testpear/cache</cache_dir>
 <temp_dir>/home/user/testpear/temp</temp_dir>
 <verbose>1</verbose>
 <paranoia>2</paranoia>
 <preferred_state>stable</preferred_state>
 <umask>0022</umask>
 <cache_ttl>3600</cache_ttl>
 <my_pear_path>/home/user/testpear:/usr/local/lib/php</my_pear_path>
 <plugins_dir>/home/user/.pear</plugins_dir>
 <openssl_cert>
  <pear2DOTphpDOTnet>/home/user/mykey.p12</pear2DOTphpDOTnet>
 </openssl_cert>
 <handle>
  <pear2DOTphpDOTnet>cellog</pear2DOTphpDOTnet>
 </handle>
</pearconfig>
    ]]>
   </programlisting>
  </para>
 </section>
 
 
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.configuration.user.autodiscover">
 <info><title>auto_discover</title></info>

 <section xml:id="pyrus.configuration.user.autodiscover.intro">
  <info><title>Introduction</title></info>
  <para>
   <literal>auto_discover</literal> is a flag (boolean), defaulting to
   <literal>0</literal> or off.  If on, this flag instructs Pyrus
   to automatically discover channels of dependencies (see
   <link linkend="pyrus.commands.channeldiscover">channel-discover</link> for
   a more in-depth description of what channel discovery means).
  </para>
  <para>
   For example, let's say we are installing Package <literal>foo</literal> from channel
   <literal>pear2.php.net</literal>, and that <literal>foo</literal> depends on package
   <literal>bar</literal> from channel <literal>pear.example.com</literal>.
   If Pyrus does not know the <literal>pear.example.com</literal> channel, and
   <literal>auto_discover</literal> is set to <literal>1</literal>, it will
   attempt to discover information on the channel, and after successfully
   adding its information to the registry, will then successfully download
   and install the dependency <literal>bar</literal>.  However, if
   <literal>auto_discover</literal> is disabled, Pyrus will simply fail
   with an error explaining that nothing is known about the
   <literal>pear.example.com</literal> channel, and that it must be
   added prior to installation.
  </para>
 </section>
</section>

 
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.configuration.user.cachedir">
 <info><title>cache_dir</title></info>

 <section xml:id="pyrus.configuration.user.cachedir.intro">
  <info><title>Introduction</title></info>
  <para>
   <literal>cache_dir</literal> is the location where HTTP caching of
   PEAR channel <link linkend="core.rest">REST</link> files is cached.
  </para>
 </section>
</section>

 
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.configuration.user.cachettl">
 <info><title>cache_ttl</title></info>

 <section xml:id="pyrus.configuration.user.cachettl.intro">
  <info><title>Introduction</title></info>
  <para>
   the <literal>cache_ttl</literal> configuration variable is used to determine
   when to consider the PEAR Channel <link linkend="core.rest">REST</link>
   cache to have been invalidated.  It is measured in seconds, and by default
   is <literal>3600</literal>, or 1 hour.
  </para>
 </section>
</section>

 
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.configuration.user.defaultchannel">
 <info><title>default_channel</title></info>

 <section xml:id="pyrus.configuration.user.defaultchannel.intro">
  <info><title>Introduction</title></info>
  <para>
   The default channel is the channel that should be implied when an
   <link linkend="guide.users.concepts.abstractpackage">Abstract Package</link>
   is ambiguous.  By default, it is <literal>pear2.php.net</literal>.
  </para>
  <para>
   As an example, when executing:
  </para>
  <screen>php pyrus.phar install PEAR2_HTTP_Request</screen>
  <para>
   The abstract package <literal>PEAR2_HTTP_Request</literal> is ambiguous - it
   does not specify a channel.  Pyrus assumes, therefore, that the requested
   package is from the default channel, and acts as if the user had in fact
   typed:
  </para>
  <screen>php pyrus.phar install pear2.php.net/PEAR2_HTTP_Request</screen>
  <para>
   The <literal>default_channel</literal> value is also used for all
   channel-specific configuration values.
  </para>
 </section>
</section>

 
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.configuration.user.downloaddir">
 <info><title>download_dir</title></info>

 <section xml:id="pyrus.configuration.user.downloaddir.intro">
  <info><title>Introduction</title></info>
  <note><simpara>This is a channel-specific configuration value</simpara></note>
  <para>
   The <literal>download_dir</literal> is where downloaded packages are kept.
   This can allow later repairing or easy cloning of an installation.  There is
   no penalty if the files are removed, and they may be easily removed to
   conserve space.
  </para>
 </section>
</section>

 
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.configuration.user.handle">
 <info><title>handle</title></info>

 <section xml:id="pyrus.configuration.user.handle.intro">
  <info><title>Introduction</title></info>
  <note><simpara>This is a channel-specific configuration value</simpara></note>
  <para>
   The <literal>handle</literal> variable should be set to the handle you use
   to identify yourself in the <literal>&lt;maintainers&gt;</literal> section
   of package.xml for packages in a specific channel.
  </para>
  <para>
   For example, if your <literal>&lt;maintainer&gt;</literal> entry in package.xml
   is:
  </para>
  <para>
   <programlisting role="xml">
    <![CDATA[
 <lead>
  <name>Greg Beaver</name>
  <user>cellog</user>
  <email>cellog@php.net</email>
  <active>no</active>
 </lead>
    ]]>
   </programlisting>
  </para>
  <para>
   Your handle is <literal>cellog</literal>.
  </para>
  <para>
   This configuration variable is used in conjunction with the
   <link linkend="pyrus.configuration.user.opensslcert">openssl_cert</link>
   configuration variable to implement package signing.
  </para>
 </section>
</section>

 
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.configuration.user.httpproxy">
 <info><title>http_proxy</title></info>

 <section xml:id="pyrus.configuration.user.httpproxy.intro">
  <info><title>Introduction</title></info>
  <para>
   The <literal>http_proxy</literal> configuration variable should be set to the
   full URI of your local HTTP proxy, or left blank for none.
  </para>
 </section>
</section>

 
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.configuration.user.mypearpath">
 <info><title>my_pear_path</title></info>

 <section xml:id="pyrus.configuration.user.mypearpath.intro">
  <info><title>Introduction</title></info>
  <para>
   The <literal>my_pear_path</literal> configuration value controls the order
   in which Pyrus cascades PEAR installations.  The path should have the same
   syntax as <literal>include_path</literal>, a
   <constant>PATH_SEPARATOR</constant>-separated list of full paths to PEAR
   installations.  The <literal>my_pear_path</literal> configuration variable
   can be easily set with the <link linkend="pyrus.commands.mypear">mypear</link>
   command.
  </para>
  <para>
   Only the first path is considered to be read/write, the others are only used
   to validate package dependencies on download.
  </para>
  <para>
   For instance, the <literal>my_pear_path</literal>
   <literal>/home/user/testpear:/usr/local/lib/php</literal> instructs Pyrus
   to install all packages into the PEAR installation at
   <literal>/home/user/testpear</literal>, and to also use the PEAR installation
   in <literal>/usr/local/lib/php</literal> to validate dependencies.
  </para>
  <para>
   On Windows, an example <literal>my_pear_path</literal> is
   <literal>D:\customPear;C:\php5</literal>.
  </para>
 </section>
</section>

 
<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="lillet" xml:id="pyrus.configuration.user.opensslcert">
 <info><title>openssl_cert</title></info>

 <section xml:id="pyrus.configuration.user.opensslcert.intro">
  <info><title>Introduction</title></info>
  <note><simpara>This is a channel-specific configuration value</simpara></note>
  <para>
   The <literal>openssl_cert</literal> configuration variable should be set to
   the full path to your personal PKCS#12 certificate, as signed by a recognized
   certificate authority such as <link xlink:href="http://www.cacert.org">CACert</link>.
   Pyrus uses this certificate along with your
   <link linkend="pyrus.configuration.user.handle">handle</link> to implement
   package signing.
  </para>
  <para>
   Your certificate must have the email address you use in package.xml as its
   alternate name, otherwise Pyrus will refuse to use it.  Pyrus uses the
   email address as stated in package.xml of the releasing maintainer of a
   package to verify that the package was actually created by the maintainer.
   This makes a man-in-the-middle attack far more difficult to execute, as well
   as verifying package integrity.
  </para>
 </section>
</section>

 
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.configuration.user.password">
 <info><title>password</title></info>

 <section xml:id="pyrus.configuration.user.password.intro">
  <info><title>Introduction</title></info>
  <note><simpara>This is a channel-specific configuration value</simpara></note>
  <para>
   This configuration variable is a legacy variable from PEAR, is not yet
   used in Pyrus, and may be removed before the stable release.
  </para>
 </section>
</section>

 
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.configuration.user.pluginsdir">
 <info><title>plugins_dir</title></info>

 <section xml:id="pyrus.configuration.user.pluginsdir.intro">
  <info><title>Introduction</title></info>
  <para>
   The <literal>plugins_dir</literal> directory is where all Pyrus plugins are
   installed.  By default, it is the directory in which the user configuration
   file is stored.
  </para>
 </section>
</section>

 
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.configuration.user.preferredmirror">
 <info><title>preferred_mirror</title></info>

 <section xml:id="pyrus.configuration.user.preferredmirror.intro">
  <info><title>Introduction</title></info>
  <note><simpara>This is a channel-specific configuration value</simpara></note>
  <para>
   This variable controls which mirror of a channel should be used
   to retrieve package releases and PEAR Channel
   <link linkend="core.rest">REST</link> information.  By default, it is
   set to the main channel path.
  </para>
 </section>
</section>

 
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.configuration.user.preferredstate">
 <info><title>preferred_state</title></info>

 <section xml:id="pyrus.configuration.user.preferredstate.intro">
  <info><title>Introduction</title></info>
  <para>
   The <literal>preferred_state</literal> configuration variable controls the
   release stability level of packages that will be installed.  By default it
   is <literal>stable</literal>, which instructs Pyrus to ignore any releases
   with lesser stabilities <literal>beta</literal>, <literal>alpha</literal>
   or <literal>devel</literal> unless explicitly requested by the user.
  </para>
  <para>
   This can be changed to allow riskier installation of newer, less-tested
   releases that are on the cutting edge of development.
  </para>
 </section>
</section>

 
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.configuration.user.tempdir">
 <info><title>temp_dir</title></info>

 <section xml:id="pyrus.configuration.user.tempdir.intro">
  <info><title>Introduction</title></info>
  <para>
   The <literal>temp_dir</literal> configuration directive is where all
   temporary files are extracted by Pyrus.
  </para>
 </section>
</section>

 
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.configuration.user.umask">
 <info><title>umask</title></info>

 <section xml:id="pyrus.configuration.user.umask.intro">
  <info><title>Introduction</title></info>
  <para>
   The <literal>umask</literal> configuration value is used to control the
   default file mask used when setting file permissions.  By default it is
   octal value <literal>0022</literal>.  The value is a bitmask that is used
   to clear any bits.  Thus, a <literal>umask</literal> of <literal>0000</literal>
   will cause files to be installed with <literal>0666</literal> permissions.  A
   <literal>umask</literal> of <literal>0022</literal> causes files to be installed
   with <literal>0644</literal> permissions.
  </para>
 </section>
</section>

 
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.configuration.user.username">
 <info><title>username</title></info>

 <section xml:id="pyrus.configuration.user.username.intro">
  <info><title>Introduction</title></info>
  <note><simpara>This is a channel-specific configuration value</simpara></note>
  <para>
   This configuration variable is a legacy variable from PEAR, is not yet
   used in Pyrus, and may be removed before the stable release.
  </para>
 </section>
</section>

 
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.configuration.user.verbose">
 <info><title>verbose</title></info>

 <section xml:id="pyrus.configuration.user.verbose.intro">
  <info><title>Introduction</title></info>
  <para>
   The <literal>verbose</literal> setting controls how much information Pyrus
   echoes as it performs its task.  The higher the setting, the more information
   Pyrus will spew.  By default, it is set to <literal>1</literal>.
  </para>
 </section>
</section>

 
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.configuration.user.paranoia">
 <info><title>verbose</title></info>

 <section xml:id="pyrus.configuration.user.paranoia.intro">
  <info><title>Introduction</title></info>
  <para>
   The <literal>paranoia</literal> setting controls how Pyrus handles automatic upgrades
   to new versions of packages.  The <link linkend="guide.users.concepts.api">API</link>
   version of the installed package is compared against the API version of remote
   packages, and chooses a release that is compatible with the current version
   based on the paranoia level.  This setting does not affect upgrades of
   local packages, only those retrieved from a remote PEAR channel server.
  </para>
  <para>
   The paranoia setting is a numeric setting with levels <literal>1</literal>
   to <literal>4</literal> supported, anything above <literal>4</literal> is
   automatically converted to <literal>4</literal>.  The levels work as follows:
  </para>
  <para>
   <orderedlist>
    <listitem> <!-- 1 -->
     <para>
      API version is ignored, only package stability and PHP version compatibility
      is used to determine which package to download for installation.
     </para>
    </listitem>
    <listitem> <!-- 2 -->
     <para>
      This is the default setting, and specifies that backwards compatibility
      must be maintained.
     </para>
     <para>
      This is performed by checking that the
      API version first digit does not change.  Thus a package with
      API version of <literal>1.2.3</literal> cannot upgrade to a new package
      with API version <literal>2.0.0</literal>.  Upgrades are allowed
      to versions such as <literal>1.2.4</literal> or <literal>1.3.0</literal>.
     </para>
    </listitem>
    <listitem> <!-- 3 -->
     <para>
      This is a strict setting, only allowing security and other API bugfixes.
     </para>
     <para>
      This is performed by checking that the API version's first and second
      digits do not change.  Thus a package with
      API version of <literal>1.2.3</literal> cannot upgrade to a new package
      with API version <literal>2.0.0</literal>.  Upgrades are allowed
      to versions such as <literal>1.2.4</literal>, but not to
      <literal>1.3.0</literal>.
     </para>
    </listitem>
    <listitem> <!-- 4 -->
     <para>
      Do not allow any API changes
     </para>
     <para>
      This is the most paranoid setting, and prevents upgrading to any package
      that changes API version whatsoever.
     </para>
    </listitem>
   </orderedlist>
  </para>
  <para>
   If using pyrus.phar, the setting can also be changed with the <literal>-p</literal>
   command-line option.  This example sets paranoia temporarily to 1:
   <screen>php pyrus.phar -p install PackageName</screen>
   This example sets paranoia temporarily to 4:
   <screen>php pyrus.phar -pppp install PackageName</screen>
  </para>
 </section>
</section>

</section>

  
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.configuration.system">
 <info><title>Pyrus system configuration variables</title></info>

 <section xml:id="pyrus.configuration.system.intro">
  <info><title>Introduction</title></info>
  <para>
   The system configuration file is always saved in a file named <literal>.config</literal>
   in the base of the PEAR installation.  Thus, if php files are installed in
   <literal>/usr/local/lib/pear/php</literal>, then the configuration for
   that installation is installed in <literal>/usr/local/lib/pear/.config</literal>.
   The configuration is stored in XML format, and can be modified by hand if
   necessary.
  </para>
  <para>
   The configuration will not be saved if no values are modified from the default values
  </para>
  <para>
   Here is a sample system configuration file (with line breaks added for readability):
  </para>
  <para>
   <programlisting role="xml">
    <![CDATA[
<?xml version="1.0"?>
<pearconfig version="1.0">
 <ext_dir>/usr/local/lib/php/extensions/debug-non-zts-20090115</ext_dir>
 <cfg_dir>/home/user/testpear/cfg</cfg_dir>
 <doc_dir>/home/user/testpear/mydata</doc_dir>
 <bin_dir>/usr/local/bin</bin_dir>
 <www_dir>/home/user/testpear/www</www_dir>
 <test_dir>/home/user/testpear/tests</test_dir>
 <src_dir>/home/user/testpear/src</src_dir>
 <php_bin>/usr/local/bin/php</php_bin>
 <php_ini>/usr/local/lib/php.ini</php_ini>
 <php_prefix></php_prefix>
 <php_suffix></php_suffix>
</pearconfig>
    ]]>
   </programlisting>
  </para>

 </section>
 
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.configuration.system.bindir">
 <info><title>bin_dir</title></info>

 <section xml:id="pyrus.configuration.system.bindir.intro">
  <info><title>Introduction</title></info>
  <para>
   executable files (files with a <literal>script</literal> role) are installed
   into <literal>bin_dir</literal>
  </para>
 </section>
</section>

 
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.configuration.system.cfgdir">
 <info><title>cfg_dir</title></info>

 <section xml:id="pyrus.configuration.system.cfgdir.intro">
  <info><title>Introduction</title></info>
  <para>
   Customizable configuration files (files with <literal>cfg</literal> role) are
   installed into this directory.  These files are intended to be manipulated
   by the user, and Pyrus will not overwrite them if any changes have been made.
  </para>
 </section>
</section>

 
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.configuration.system.datadir">
 <info><title>data_dir</title></info>

 <section xml:id="pyrus.configuration.system.datadir.intro">
  <info><title>Introduction</title></info>
  <para>
   Files with roles <literal>data</literal>, <literal>customcommand</literal>,
   <literal>customrole</literal> and <literal>customtask</literal> are installed
   into the <literal>data_dir</literal> configuration variable.
  </para>
  <para>
   In Pyrus, this is a pseudo-configuration variable: its value cannot be changed
   without creating an entirely new repository.  Data is always stored in the
   directory <literal>data/</literal> relative to the location of the installation.
  </para>
 </section>
</section>

 
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.configuration.system.docdir">
 <info><title>doc_dir</title></info>

 <section xml:id="pyrus.configuration.system.docdir.intro">
  <info><title>Introduction</title></info>
  <para>files with the <literal>doc</literal> role are installed into
  <literal>doc_dir</literal>.</para>
 </section>
</section>

 
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.configuration.system.extdir">
 <info><title>ext_dir</title></info>

 <section xml:id="pyrus.configuration.system.extdir.intro">
  <info><title>Introduction</title></info>
  <para>
   Compiled extension files are installed into the <literal>ext_dir</literal>,
   and files with role <literal>ext</literal>.
  </para>
 </section>
</section>

 
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.configuration.system.phpbin">
 <info><title>php_bin</title></info>

 <section xml:id="pyrus.configuration.system.phpbin.intro">
  <info><title>Introduction</title></info>
  <para>
   the <literal>php_bin</literal> configuration variable refers to the location
   of PHP that should be used for installed executable scripts.
  </para>
 </section>
</section>

 
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.configuration.system.phpdir">
 <info><title>php_dir</title></info>

 <section xml:id="pyrus.configuration.system.phpdir.intro">
  <info><title>Introduction</title></info>
  <para>
   Files with roles <literal>php</literal> are installed
   into the <literal>php_dir</literal> configuration variable.
  </para>
  <para>
   In Pyrus, this is a pseudo-configuration variable: its value cannot be changed
   without creating an entirely new repository.  PHP files are always stored in the
   directory <literal>php/</literal> relative to the location of the installation.
  </para>
 </section>
</section>

 
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.configuration.system.phpini">
 <info><title>php_ini</title></info>

 <section xml:id="pyrus.configuration.system.phpini.intro">
  <info><title>Introduction</title></info>
  <para>
   the <literal>php_ini</literal> variable should be set to the location of
   <literal>php.ini</literal> that is used by this installation, and is used
   to automatically enable extensions on installation.
  </para>
 </section>
</section>

 
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.configuration.system.phpprefix">
 <info><title>php_prefix</title></info>

 <section xml:id="pyrus.configuration.system.phpprefix.intro">
  <info><title>Introduction</title></info>
  <para>
   This variable should be set to the value that <literal>--program-prefix</literal>
   was set to when PHP was configured, and is used when building PECL extensions.
  </para>
 </section>
</section>

 
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.configuration.system.phpsuffix">
 <info><title>php_suffix</title></info>

 <section xml:id="pyrus.configuration.system.phpsuffix.intro">
  <info><title>Introduction</title></info>
  <para>
   This variable should be set to the value that <literal>--program-suffix</literal>
   was set to when PHP was configured, and is used when building PECL extensions.
  </para>
 </section>
</section>

 
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.configuration.system.srcdir">
 <info><title>src_dir</title></info>

 <section xml:id="pyrus.configuration.system.srcdir.intro">
  <info><title>Introduction</title></info>
  <para>
   Files with the <literal>src</literal> role are installed into
   <literal>src_dir</literal>, and building of PECL packages
   also happens in this directory.
  </para>
 </section>
</section>

 
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.configuration.system.testdir">
 <info><title>test_dir</title></info>

 <section xml:id="pyrus.configuration.system.testdir.intro">
  <info><title>Introduction</title></info>
  <para>
   Files with <literal>test</literal> role are installed into this directory.
  </para>
 </section>
</section>

 
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.configuration.system.wwwdir">
 <info><title>www_dir</title></info>

 <section xml:id="pyrus.configuration.system.wwwdir.intro">
  <info><title>Introduction</title></info>
  <para>
   Files with <literal>www</literal> role are installed into this directory.
  </para>
 </section>
</section>

</section>

  
 </chapter>

  
<chapter xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.differences">
  <info>
   <title>Differences from the PEAR Installer</title>
   <author><personname><firstname>Gregory</firstname><surname>Beaver</surname></personname></author>
   <date>2009-06-25</date>
  </info>

  <simpara>
   Differences between Pyrus and the PEAR Installer.  This documentation is a work in progress.
  </simpara>

  
<section xmlns="http://docbook.org/ns/docbook" xmlns:phd="http://www.php.net/ns/phd" version="lillet" xml:id="pyrus.differences.frompear">
 <info><title>Pyrus: Improvements from the PEAR Installer</title></info>

 <section xml:id="pyrus.differences.frompear.overview">
  <info><title>Overview</title></info>
  <para>
   Pyrus is a re-factored version of the PEAR installer, re-designed for new features
   available in PHP 5.3 and newer.  As a result, Pyrus is more robust than PEAR
   as well as faster.  Several of the subtle design flaws in the PEAR Installer
   have been fixed, and so Pyrus is more stable than the PEAR Installer for
   handling an existing PEAR repository.
  </para>
  <para>
   Here is a brief summary of the differences from PEAR:
  </para>
  <section xml:id="pyrus.differences.frompear.overview.simpler">
   <title>Simpler to use than PEAR</title>
   <para>
    Pyrus is distributed as a single file, pyrus.phar.  Because of PHP's new
    phar extension, Pyrus does not need to be installed, and can run directly
    from the file pyrus.phar.
   </para>
   <para>
    Pyrus also simplifies the command-line options available, and provides a
    far greater range of developer tools for creating, managing and
    distributing packages through tools such as the simple channel server and
    package.xml creation command <literal>make</literal>.
   </para>
  </section>
  <section xml:id="pyrus.differences.frompear.overview.secure">
   <title>More secure than PEAR</title>
   <para>
    Several security vulnerabilities in the design of PEAR were discovered due
    to the particular Command Pattern implementation used to detect file roles,
    commands, and other plugins.  Pyrus fixes this by requiring that all plugins
    be installed into a centralized location separate from the actual PEAR
    installation.  In addition, installation of plugins cannot happen at the same
    time as installation of packages, thus the enforced separation ensures a level
    of security that is much higher than PEAR supports, while preserving the
    flexibility that extending the installer provides.
   </para>
   <para>
    Pyrus also feaures true package signing and signature verification
    using OpenSSL PKCS#12 and X.509 certificates.  This allows users
    to directly verify the validity of a package, protecting from
    man-in-the-middle attacks and other potential disruptions of a package
    release.  This feature requires the openssl extension, which is not
    enabled by default.
   </para>
   <para>
    PEAR supports signing packages using PGP keys, but has no mechanism
    in place to verify the signed packages.  Pyrus will refuse to install
    a signed package without verifying the signature even if the openssl
    extension is not enabled.
   </para>
   <para>
    In addition, the new <link linkend="pyrus.configuration.user.paranoia">paranoia</link>
    setting can be used to control how upgrades are performed to releases that
    change the <link linkend="guide.users.concepts.api">API</link>, helping
    to guarantee safe upgrades to future releases.
   </para>
  </section>
  <section xml:id="pyrus.differences.frompear.overview.smaller">
   <title>Smaller than PEAR</title>
   <para>
    Because Pyrus takes advantage of PHP 5.3's built in support for XML processing,
    archive handling, and advanced structures through the simplexml, libxml2,
    phar, sqlite3, and spl extensions, Pyrus is significantly smaller than PEAR, and
    as a result consumes far less memory to accomplish its tasks.
   </para>
  </section>
  <section xml:id="pyrus.differences.frompear.overview.faster">
   <title>Faster than PEAR</title>
   <para>
    Pyrus is also faster than PEAR because of its reliance on built-in features
    of PHP 5.3 and a more structured object-oriented design.
   </para>
  </section>
  <section xml:id="pyrus.differences.frompear.overview.robust">
   <title>More robust than PEAR</title>
   <para>
    Pyrus has redundant registries in XML and Sqlite3 database formats, as well
    as support for the existing PEAR registry.  Reconstruction of a corrupted
    registry is simple and fully supported.
   </para>
   <para>
    In addition, all installation tasks
    occur within an atomic transaction, including file installation and removal,
    so that if an installation or uninstall command fails mid-stream, or something
    as drastic as a power failure occurs, the PEAR installation will be not be
    left in a half-installed state.
   </para>
  </section>
  <section xml:id="pyrus.differences.frompear.overview.flexible">
   <title>More flexible than PEAR</title>
   <para>
    Pyrus supports cascading installations, so that a system-wide installation
    of core packages can be recognized.  By default, include_path is used to
    detect PEAR installations, but a different location for a PEAR installation
    can be passed directly to Pyrus as its first argument.
   </para>
   <para>
    Convention over configuration allows packages constructed with the new PEAR2
    coding standards to be installed simply by extracting the archive, and then
    later upgraded using Pyrus without the intermediate step of using Pyrus to
    install the packages.  For the first time, this allows a try-before-you-buy
    approach to be possible.
   </para>
   <para>
    The same principle also makes bundling a PEAR2 package in another package's
    source repository possible, and Pyrus can be used to easily upgrade the
    package or revert to a previous version.
   </para>
  </section>
  <section xml:id="pyrus.differences.frompear.overview.tested">
   <title>More tested than PEAR</title>
   <para>
    Pyrus has been developed with extensive unit testing and xdebug coverage
    data has been used to verify that the code is being executed.  As a result,
    the first alpha release of Pyrus has 10% higher code coverage than the most
    recent stable version of the PEAR Installer.
   </para>
  </section>
 </section>
 <section xml:id="pyrus.differences.frompear.configuration">
  <info><title>Configuration files</title></info>
  <para>
   One of the most important conceptual changes in Pyrus is how configuration
   is handled.  PEAR was designed to handle at most 2 installations by default,
   a system and a user PEAR installation, and it excels at this.  As soon as
   PEAR is used on multiple installations, a separate configuration file must
   be specified (as in <literal>pear -c /path/to/another/pear.conf install
   blah</literal>).  This leads to what is colloquially referred to as
   <quote>config hell</quote>, where it is easy to accidentally install
   things into the wrong place without realizing it.  Pyrus's configuration
   handling is specifically engineered to eliminate config hell, and to make
   handling multiple PEAR installations simple.
  </para>
  <para>
   PEAR stores all configuration values in a single configuration file, and allows
   specifying a different configuration file for different setups.  In addition,
   PEAR supports automatic cascade of a system configuration file and a user
   configuration file.  The configuration values are used when installing applications,
   and for customizing things like the path to php in the PEAR Installer's
   <literal>pear</literal> command.  Configuration files are stored separate
   from the PEAR installations that they represent.
  </para>
  <para>
   Pyrus instead splits up configuration files into two separate components: one
   file contains user customizations such as the preferred stability of packages
   to install, the username and password for logging into a channel, the verbose
   setting and so on.  Configuration variables that affect where to install files
   are stored in a separate configuration that is tightly bound to the PEAR
   installation.
  </para>
  <para>
   Thus, a PEAR configuration setup might look like:
  </para>
  <para>
   <itemizedlist>
    <listitem>
     <simpara>
      System configuration in <literal>/etc/pear.conf</literal>, defines
      <literal>php_dir</literal> as <literal>/usr/local/lib/php</literal>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      User configuration in <literal>/home/username/.pearrc</literal>, defines
      <literal>php_dir</literal> as <literal>/home/username/pear</literal>.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <literal>include_path</literal> is set to <literal>/home/username/pear:/usr/local/lib/php</literal>.
     </simpara>
    </listitem>
   </itemizedlist>
  </para>
  <para>
   The equivalent configuration setup with Pyrus would look like:
  </para>
  <para>
   <itemizedlist>
    <listitem>
     <simpara>
      Pyrus-based installation in <literal>/usr/local/lib/pear</literal>, system configuration
      stored in <literal>/usr/local/pear/.config</literal> and php files in
      <literal>/usr/local/lib/pear/php</literal>.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Another Pyrus-based installation in <literal>/home/username/pear</literal>, system
      configuration stored in <literal>/home/username/pear/.config</literal> and php
      files in <literal>/home/username/pear/php</literal>.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      User configuration in <literal>/home/username/.pear/pearconfig.xml</literal>.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <literal>include_path</literal> is set to <literal>/home/username/pear:/usr/local/lib/pear/php</literal>.
     </simpara>
    </listitem>
   </itemizedlist>
  </para>
  <para>
   By default, Pyrus uses the <literal>include_path</literal> to locate PEAR
   installations, but this is configurable with the new user configuration
   variable <literal>my_pear_path</literal>, which is a <constant>PATH_SEPARATOR</constant>
   separated list of paths to PEAR installations.
  </para>
  <para>
   In addition, an explicit path can be directly passed to Pyrus:
  </para>
  <para>
   <literal>php pyrus.phar /home/username/pear:/usr/local/lib/pear list-packages</literal>
  </para>
  <para>
   The above command will list the installed packages in both registries in
   <literal>/home/username/pear</literal> and in <literal>/usr/local/lib/pear/php</literal>.
  </para>
  <para>
   A detailed reference of Pyrus's handling of configuration files is
   <link linkend="pyrus.configuration">here</link>
  </para>
 </section>
 <section xml:id="pyrus.differences.frompear.registry">
  <info><title>Registries</title></info>
  <para>
   Pyrus fully supports PEAR's registry format, but introduces 2 new registry formats,
   an sqlite3 database-based registry, and an XML file-based registry.  These
   registries are fully redundant, and can be used to repair or reconstruct a corrupt
   registry.
  </para>
  <para>
   In addition, unlike PEAR, which stores the registry in the same directory as
   the PHP source files, Pyrus stores the registry in its parent directory.
   Thus, PHP files stored in <literal>/usr/local/lib/php</literal> have their
   registry in <literal>/usr/local/lib</literal>.
  </para>
  <note>
   <simpara>
    For backwards compatibility, an older PEAR registry is always
    stored in the location the PEAR Installer expects it to be stored.
   </simpara>
  </note>
  <para>
   Pyrus is intelligent enough to detect which registries are present, and
   to use them.  If only an older PEAR registry exists, Pyrus will not
   automatically upgrade to the newer format.  However, the
   <literal>upgrade-registries</literal> command is available to convert from
   an older registry to the newer format.
  </para>
  <para>
   Some of the benefits of the newer registry format include much speedier
   processing of a large registry at installation time due to Sqlite3's
   speedy processing.  Additionally, truly safe uninstall-time resolution of
   dependencies is possible, something that PEAR can only do for relatively
   simple package dependency trees.
  </para>
  <para>
   In addition, the XML registry consists of storing the package.xml and
   channel.xml files for package releases in the same location that they
   are packaged.  This is what makes it possible to extract a package
   created with Pyrus and then later use Pyrus to upgrade it.
  </para>
  <para>
   For instance, the hypothetical <literal>PEAR2_Foo</literal> package from
   channel <literal>pear2.php.net</literal> version <literal>1.2.3</literal>
   will store its package.xml in path
   <literal>.xmlregistry/packages/pear2.php.net/PEAR2_Foo/1.2.3-package.xml</literal>
   inside the archive, so that when it is extracted, it lines up exactly with how
   the package would look on disk when installed with the XML registry.
  </para>
 </section>
 <section xml:id="pyrus.differences.frompear.packagexml">
  <info><title>package.xml changes</title></info>
  <para>
   Pyrus no longer supports
   <link linkend="developers.packagedef.intro">package.xml version 1.0</link>,
   although it will include a package.xml version 1.0 in an archive designed
   to support both earlier PEAR versions and the more recent versions.  It does
   not validate the package.xml, however, and so it is important to validate
   any older package.xml format using PEAR and not Pyrus.
  </para>
  <para>
   In addition, Pyrus has introduced support for PEAR2 packages that can
   be extracted to disk and then later upgraded using Pyrus.  To implement
   this feature, Pyrus transforms paths in a different way from PEAR.
  </para>
  <para>
   For example, this entry from a package.xml:
  </para>
  <para>
   <programlisting role="xml">
    <![CDATA[
   <dir name="php" baseinstalldir="PEAR2">
    <dir name="Pyrus">
     <dir name="Developer">
      <dir name="CoverageAnalyzer">
       <dir name="SourceFile">
        <file role="php" name="PerTest.php"/>
       </dir>
      </dir>
     </dir>
    </dir>
   </dir>
    ]]>
   </programlisting>
  </para>
  <para>
   would cause PEAR to install <literal>PerTest.php</literal> into the
   relative path <literal>PEAR2/php/Pyrus/Developer/CoverageAnalyzer/SourceFile/PerTest.php</literal>.
   Pyrus, however, recognizes that <literal>php</literal> is actually the default value of
   the <link linkend="pyrus.configuration.system.phpdir">php_dir</link> system
   configuration variable, and strips it from the path, resulting in
   <literal>PerTest.php</literal> being installed into the path:
   <literal>PEAR2/Pyrus/Developer/CoverageAnalyzer/SourceFile/PerTest.php</literal>.
  </para>
  <para>
   To enable this handling, one need only set the &lt;pearinstaller&gt;
   dependency to version <literal>2.0.0a1</literal> or newer.  Pyrus will
   automatically recognize any package.xml with a &lt;pearinstaller&gt;
   dependency on any version of the PEAR Installer as an older package.xml, and
   will not perform the magic removal of configuration values from
   directories.
  </para>
  <para>
   No other changes have been made to package.xml handling, except that the
   default version of package.xml used when generating a package.xml is
   version 2.1, which has been supported by the PEAR Installer since
   version <literal>1.5.0</literal>.
  </para>
 </section>
 <section xml:id="pyrus.differences.frompear.plugins">
  <info><title>Extending Pyrus: plugins</title></info>
  <para>
   The PEAR Installer allowed packages to install custom commands as well as
   custom file roles and custom file tasks that are used in package.xml.  Pyrus
   also allows this, but the format of plugins is very different.  If you are
   simply a user of PEAR, you probably won't notice the difference, except that
   some packages that use custom file roles or tasks will not be installable by
   Pyrus until the maintainer releases an update that will work with both PEAR
   and Pyrus.
  </para>
  <para>
   PEAR extensions are installed directly into the location where the PEAR
   installer is located.  Thus, if PEAR is located in
   <literal>/usr/local/lib/php/PEAR</literal>, a custom command must install
   its XML information file and PHP script into
   <literal>/usr/local/lib/php/PEAR/Command</literal>,
   a custom file role must install its XML information file and PHP script into
   <literal>/usr/local/lib/php/PEAR/Installer/Role</literal> and a custom file
   task must install its PHP script into
   <literal>/usr/local/lib/php/PEAR/Task</literal>.
  </para>
  <para>
   Pyrus is distributed as a phar archive, so this model is no longer physically
   possible, one cannot just magically insert files into the phar archive without
   considerable pain and annoyance (the phar.readonly INI setting must be disabled
   by hand).  Instead, Pyrus installs all plugins into a location specified
   by the new <literal>plugins_dir</literal> user configuration variable.
   By default, this installs plugins into <literal>$HOME/.pear/plugins</literal>
   on unix systems, and <literal>My Documents\pear\plugins</literal> on Windows.
  </para>
  <para>
   All plugins to Pyrus now must provide an xml file with one of the three
   new file roles <literal>customcommand</literal>, <literal>customrole</literal>
   or <literal>customtask</literal> in package.xml.  Pyrus uses the information
   in the XML file to locate the PHP script that will execute the plugin.  In
   addition, only one plugin is allowed per package, and the first one Pyrus
   encounters is the one that will be used.  More information on custom plugins
   is provided in the <link linkend="pyrus.plugins">Pyrus plugins</link> section
   of the manual.
  </para>
  <para>
   For developers of existing PEAR custom roles/tasks and post-install scripts,
   a special kind of file role that allows configuration of your package after
   installation, making your work compatible with Pyrus can be accomplished.
   See the documentation
   on <link linkend="pyrus.differences.customroles">Custom Roles</link>,
   <link linkend="pyrus.differences.customtasks">Custom Tasks</link>, and
   <link linkend="pyrus.differences.postinstallscripts">Post-install scripts</link>.
  </para>
 </section>
 <section xml:id="pyrus.differences.frompear.pecl">
  <info><title>Installing and Building PECL extensions</title></info>
  <para>
   PEAR's handling of PECL extensions has been somewhat dodgy, with reports of
   issues with phpize failing, and other problems.
   Pyrus attempts to fix this through two major changes to the way PECL packages
   are built and installed.
  </para>
  <para>
   <orderedlist>
    <listitem>
     <simpara>
      PECL packages are installed into a new location <literal>src/</literal>
      and then built directly inside this location.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      The same tool process used to build extensions by hand is used verbatim
      by pyrus to build the extension
     </simpara>
    </listitem>
   </orderedlist>
  </para>
  <section>
   <title>PECL installation changes</title>
   <para>
    PEAR builds PECL packages by creating a temporary directory, installing all of
    the source files into this directory, building the extension, harvesting
    built files, and finally removes the temporary directory.  This system works
    most of the time, but if there is a problem, it is impossible to debug because
    the sources are removed.
   </para>
   <para>
    Pyrus solves this by splitting PECL package installation into two components,
    installation and build.  The installation process simply places the
    source files into a sub-directory of the <literal>src_dir</literal> configuration
    variable, and thus makes it possible to debug problems or even apply patches
    to the source and re-build.
   </para>
   <para>
    In addition, because installation is separate from the actual building, PECL
    packages can now implement post-install scripts to handle truly complex
    configuration of extensions beyond what configure options can handle.
   </para>
  </section>
  <section>
   <title>PECL build</title>
   <para>
    The new <literal>build</literal> command enhances PEAR's package building by
    directly calling this sequence:
   </para>
   <para>
    <screen>
     <![CDATA[
phpize --clean
phpize
./configure [any options specified by <configureoptions>]
make
make install
     ]]>
    </screen>
   </para>
   <para>
    This is the same sequence one would use to build a PECL extension by hand.
    In addition, <function>proc_open</function> is used instead of
    <function>popen</function>, which allows better monitoring and control of
    the processes in question.
   </para>
   <para>
    Lastly, Pyrus is more cross-platform than PEAR, as it replaces a
    call to <literal>find</literal> and <literal>xargs</literal> with native
    PHP iteration over the modules directory when listing extension components
    that were built.
   </para>
  </section>
 </section>
</section>

  
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.differences.postinstallscripts">
 <info><title>Pyrus Post-install scripts: differences from PEAR</title></info>

 <section xml:id="pyrus.differences.postinstallscripts.overview">
  <info><title>Overview</title></info>
  <para>
   Post-install scripts 
   are mostly the same in Pyrus with a few important differences.
  </para>
  <para>
   The XML format in package.xml is identical, so no change need be made to
   the <literal>&lt;paramgroup&gt;</literal> or other tags.  The script itself
   should still follow the naming conventions of PEAR.  The only real difference
   is the naming of methods within the script.
  </para>
  <para>
   PEAR requires that all post-install scripts implement <function>init</function>,
   <function>run</function> and optionally <function>postProcessPrompts</function>.
   Pyrus requires post-install scripts to implement <function>init2</function>,
   <function>run2</function>, and optionally <function>postProcessPrompts2</function>.
   This allows PEAR and Pyrus-based post-install scripts to co-exist in the
   same package without difficulty.  Note that post-install scripts must be
   <literal>E_STRICT</literal> and <literal>E_DEPRECATED</literal> compliant,
   otherwise many PHP warnings will be emitted.  One way of handling this issue
   is to put PHP4 non-E_STRICT-compatible code into a separate file and include it
   dynamically at run-time.  The same should be done for any PHP5+ non-PHP4
   compatible code if the post-install script is expected to be able to run in PHP 4.
  </para>
 </section>

 <section xml:id="pyrus.differences.postinstallscripts.init2">
  <info><title>The init2 method</title></info>
  <para>
   The <function>init2</function> method should accept two parameters like so:
   <programlisting role="php">
    <![CDATA[
<?php
function init2($pkg, $lastversion)
{
}
?>
    ]]>
   </programlisting>
   <literal>$pkg</literal> is an object representing the package, and
   <literal>$lastversion</literal> is the last installed version of the
   package.
  </para>
 </section>

 <section xml:id="pyrus.differences.postinstallscripts.run2post2">
  <info><title>The run2 and postProcessPrompts2 methods</title></info>
  <para>
   These two methods should accept identical parameters to what the PEAR
   equivalent accepted.  The only reason these are called is to allow
   easy differentiation between what kind of installer is calling the post-install
   script.
  </para>
 </section>
</section>

  
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.differences.customcommands">
 <info><title>Pyrus Custom Commands: differences from PEAR</title></info>

 <section xml:id="pyrus.differences.customcommands.overview">
  <info><title>Overview</title></info>
  <para>
   Custom commands
   have changed substantially in Pyrus.  PEAR commands draw their information
   from Xml files located in the directory <literal>PEAR/Command</literal> and
   require all commands to be implemented in a single file.  Pyrus is much
   more flexible on this account, and extends the custom XML format used to
   define commands.  Because of this difference, it is theoretically possible
   to create custom commands that will work in both the PEAR Installer and in
   Pyrus, although the internal implementation of these commands will necessarily
   be quite different.
  </para>
  <para>
   The biggest difference between how a custom command is implemented in Pyrus has
   to do with the new plugin system (documented <link linkend="pyrus.plugins">here</link>).
   Before reading any further, it may be a good idea to familiarize yourself with
   the way that plugins work in Pyrus by reading the documentation on plugins,
   then return back to finish reading about custom commands.
  </para>
  <para>
   Here is PEAR's version of the xml for the <literal>install</literal> command:
  </para>
  <para>
   <programlisting role="xml">
    <![CDATA[
<commands version="1.0">
 <install>
  <summary>Install Package</summary>
  <function>doInstall</function>
  <shortcut>i</shortcut>
  <options>
   <force>
    <shortopt>f</shortopt>
    <doc>will overwrite newer installed packages</doc>
   </force>
   <loose>
    <shortopt>l</shortopt>
    <doc>do not check for recommended dependency version</doc>
   </loose>
   <nodeps>
    <shortopt>n</shortopt>
    <doc>ignore dependencies, install anyway</doc>
   </nodeps>
   <register-only>
    <shortopt>r</shortopt>
    <doc>do not install files, only register the package as installed</doc>
   </register-only>
   <soft>
    <shortopt>s</shortopt>
    <doc>soft install, fail silently, or upgrade if already installed</doc>
   </soft>
   <nobuild>
    <shortopt>B</shortopt>
    <doc>don&#039;t build C extensions</doc>
   </nobuild>
   <nocompress>
    <shortopt>Z</shortopt>
    <doc>request uncompressed files when downloading</doc>
   </nocompress>
   <installroot>
    <shortopt>R</shortopt>
    <doc>root directory used when installing files (ala PHP&#039;s INSTALL_ROOT), use packagingroot for RPM</doc>
    <arg>DIR</arg>
   </installroot>
   <packagingroot>
    <shortopt>P</shortopt>
    <doc>root directory used when packaging files, like RPM packaging</doc>
    <arg>DIR</arg>
   </packagingroot>
   <ignore-errors>
    <shortopt></shortopt>
    <doc>force install even if there were errors</doc>
   </ignore-errors>
   <alldeps>
    <shortopt>a</shortopt>
    <doc>install all required and optional dependencies</doc>
   </alldeps>
   <onlyreqdeps>
    <shortopt>o</shortopt>
    <doc>install all required dependencies</doc>
   </onlyreqdeps>
   <offline>
    <shortopt>O</shortopt>
    <doc>do not attempt to download any urls or contact channels</doc>
   </offline>
   <pretend>
    <shortopt>p</shortopt>
    <doc>Only list the packages that would be downloaded</doc>
   </pretend>
  </options>
  <doc>[channel/]&lt;package&gt; ...
Installs one or more PEAR packages.  You can specify a package to
install in four ways:

&quot;Package-1.0.tgz&quot; : installs from a local file

&quot;http://example.com/Package-1.0.tgz&quot; : installs from
anywhere on the net.

&quot;package.xml&quot; : installs the package described in
package.xml.  Useful for testing, or for wrapping a PEAR package in
another package manager such as RPM.

&quot;Package[-version/state][.tar]&quot; : queries your default channel&#039;s server
({config master_server}) and downloads the newest package with
the preferred quality/state ({config preferred_state}).

To retrieve Package version 1.1, use &quot;Package-1.1,&quot; to retrieve
Package state beta, use &quot;Package-beta.&quot;  To retrieve an uncompressed
file, append .tar (make sure there is no file by the same name first)

To download a package from another channel, prefix with the channel name like
&quot;channel/Package&quot;

More than one package may be specified at once.  It is ok to mix these
four ways of specifying packages.
</doc>
 </install>
  </commands>
    ]]>
   </programlisting>
  </para>
  <para>
   And the same command as implemented in Pyrus:
  </para>
  <para>
   <programlisting role="xml">
    <![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<commands version="2.0" xmlns="http://pear2.php.net/dtd/customcommand-2.0">
 <command>
  <name>install</name>
  <class>PEAR2\Pyrus\ScriptFrontend\Commands</class>
  <function>install</function>
  <summary>Install a package.  Use install --plugin to install plugins</summary>
  <shortcut>i</shortcut>
  <options>
   <option>
    <name>plugin</name>
    <shortopt>p</shortopt>
    <type><bool/></type>
    <doc>Manage plugin installation only</doc>
   </option>
   <option>
    <name>packagingroot</name>
    <shortopt>r</shortopt>
    <type><string/></type>
    <doc>Install the package in a directory in preparation for packaging with tools like RPM</doc>
   </option>
   <option>
    <name>optionaldeps</name>
    <shortopt>o</shortopt>
    <type><bool/></type>
    <doc>Automatically download and install all optional dependencies</doc>
   </option>
   <option>
    <name>force</name>
    <shortopt>f</shortopt>
    <type><bool/></type>
    <doc>Force the installation to proceed independent of errors.  USE SPARINGLY.</doc>
   </option>
  </options>
  <arguments>
   <argument>
    <name>package</name>
    <multiple>1</multiple>
    <optional>0</optional>
    <doc>package.xml, local package archive, remove package archive, or abstract package.</doc>
   </argument>
  </arguments>
  <doc>Installs listed packages.

local package.xml example:
php pyrus.phar install package.xml

local package archive example:
php pyrus.phar install PackageName-1.2.0.tar

remote package archive example:
php pyrus.phar install http://www.example.com/PackageName-1.2.0.tgz

Examples of an abstract package:
php pyrus.phar install PackageName
 installs PackageName from the default channel with stability preferred_state
php pyrus.phar pear/PackageName
 installs PackageName from the pear.php.net channel with stability preferred_state
php pyrus.phar install channel://doc.php.net/PackageName
 installs PackageName from the doc.php.net channel with stability preferred_state
php pyrus.phar install PackageName-beta
 installs PackageName from the default channel, beta or stable stability
php pyrus.phar install PackageName-1.2.0
 installs PackageName from the default channel, version 1.2.0</doc>
 </command>
</commands>
    ]]>
   </programlisting>
  </para>
  <para>
   The format for commands in Pyrus is much more fine-grained, and provides both
   better validation and better presentation of options and arguments as passed
   in from the user.  In addition, Pyrus allows fine-grained specification of
   where a command is located, and automatically registers an autoloader to
   load the class implementing the command, and any dependent classes in the
   same location.
  </para>
  <para>
   The details of new tags like &lt;classprefix&gt; and &lt;autoloadpath&gt; are
   documented in the full documentation of custom roles
   <link linkend="pyrus.plugins.command">here</link>.
  </para>
  <para>
   This XML metadata file is identified by Pyrus through the use of the file role
   <literal>customcommand</literal>, which is used in the custom command's package.xml.
   Here is an example from the &lt;contents&gt; of a package.xml:
  </para>
  <para>
   <programlisting role="xml">
    <![CDATA[
...
  <contents>
   <dir name="data">
    <file name="commands.xml" role="customcommand"/>
    <file name="someotherdata.csv" role="data"/>
   </dir>
  </contents>
...
    ]]>
   </programlisting>
  </para>
 </section>
</section>

  
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.differences.customroles">
 <info><title>Pyrus Custom File Roles: differences from PEAR</title></info>

 <section xml:id="pyrus.differences.customroles.overview">
  <info><title>Overview</title></info>
  <para>
   Custom file roles
   have changed substantially in Pyrus.  Fortunately, the usage of roles in package.xml
   remains unchanged, and Pyrus's expectation of custom role implementation does not conflict
   or overlap with PEAR's at all, so custom role packages can easily be designed
   to work with both PEAR and Pyrus.
  </para>
  <para>
   The biggest difference between how a custom role is implemented in Pyrus has
   to do with the new plugin system (documented <link linkend="pyrus.plugins">here</link>).
   Before reading any further, it may be a good idea to familiarize yourself with
   the way that plugins work in Pyrus by reading the documentation on plugins,
   then return back to finish reading about custom roles.
  </para>
  <para>
   Pyrus modifies the XML description file for custom file roles slightly, here
   is the PEAR version of a role:
  </para>
  <para>
   <programlisting role="xml">
    <![CDATA[
<role version="1.0">
 <releasetypes>php</releasetypes>
 <releasetypes>extsrc</releasetypes>
 <releasetypes>extbin</releasetypes>
 <releasetypes>zendextsrc</releasetypes>
 <releasetypes>zendextbin</releasetypes>
 <installable>1</installable>
 <locationconfig>php_dir</locationconfig>
 <honorsbaseinstall>1</honorsbaseinstall>
 <unusualbaseinstall />
 <phpfile>1</phpfile>
 <executable />
 <phpextension />
 <config_vars />
</role>    ]]>
   </programlisting>
  </para>
  <para>
   And the same role as implemented in Pyrus:
  </para>
  <para>
   <programlisting role="xml">
    <![CDATA[
<role version="2.0" xmlns="http://pear2.php.net/dtd/customrole-2.0">
 <name>php</name>
 <class>PEAR2\Pyrus\Installer\Role\Php</class>
 <releasetypes>php</releasetypes>
 <releasetypes>extsrc</releasetypes>
 <releasetypes>extbin</releasetypes>
 <releasetypes>zendextsrc</releasetypes>
 <releasetypes>zendextbin</releasetypes>
 <installable>1</installable>
 <locationconfig>php_dir</locationconfig>
 <honorsbaseinstall>1</honorsbaseinstall>
 <unusualbaseinstall />
 <executable />
</role>
    ]]>
   </programlisting>
  </para>
  <para>
   The most obvious difference is that Pyrus now includes the name of the role,
   PEAR extracts the role name from the name of the file (which in the
   example above was <literal>Php.xml</literal>).  In addition, the
   <literal>&lt;phpfile&gt;</literal> and <literal>&lt;phpextension&gt;</literal>
   elements have been removed.
  </para>
  <para>
   The details of new tags like &lt;class&gt; and &lt;autoloadpath&gt; are
   documented in the full documentation of custom roles
   <link linkend="pyrus.plugins.role">here</link>.
  </para>
  <para>
   This XML metadata file is identified by Pyrus through the use of the file role
   <literal>customrole</literal>, which is used in the custom role's package.xml.
   Here is an example from the &lt;contents&gt; of a package.xml:
  </para>
  <para>
   <programlisting role="xml">
    <![CDATA[
...
  <contents>
   <dir name="data">
    <file name="myrole.xml" role="customrole"/>
    <file name="someotherdata.csv" role="data"/>
   </dir>
  </contents>
...
    ]]>
   </programlisting>
  </para>
 </section>
</section>

  
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.differences.customtasks">
 <info><title>Pyrus Custom File Tasks: differences from PEAR</title></info>

 <section xml:id="pyrus.differences.customtasks.overview">
  <info><title>Overview</title></info>
  <para>
   Custom file tasks
   have changed substantially in Pyrus.  Fortunately, the XML format of tasks
   used in package.xml remains the
   same, and Pyrus's expectation of custom task implementation does not conflict
   or overlap with PEAR's at all, so custom task packages can easily be designed
   to work with both PEAR and Pyrus.
  </para>
  <para>
   The biggest difference between how a custom task is implemented in Pyrus has
   to do with the new plugin system (documented <link linkend="pyrus.plugins">here</link>).
   Before reading any further, it may be a good idea to familiarize yourself with
   the way that plugins work in Pyrus by reading the documentation on plugins,
   then return back to finish reading about custom tasks.
  </para>
  <para>
   In PEAR, custom tasks are detected simply by scanning the
   <literal>PEAR/Tasks</literal> directory, and no differentiation is made between
   tasks built into PEAR, and external custom tasks.
  </para>
  <para>
   Pyrus custom tasks are detected through the use a new XML metadata format.
   The format is simple, and looks like this:
  </para>
  <para>
   <programlisting role="xml">
    <![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<task xmlns="http://pear2.php.net/dtd/customtask-2.0" version="2.0">
 <name>mytask</name>
 <classprefix>vendor_PackageName</classprefix>
 <autoloadpath/>
</task>
    ]]>
   </programlisting>
  </para>
  <para>
   The details of what &lt;classprefix&gt; and &lt;autoloadpath&gt; mean are
   revealed in the full documentation of custom tasks
   <link linkend="pyrus.plugins.task">here</link>.
  </para>
  <para>
   This XML metadata file is identified by Pyrus through the use of the file role
   <literal>customtask</literal>, which is used in the custom task's package.xml.
   Here is an example from the &lt;contents&gt; of a package.xml:
  </para>
  <para>
   <programlisting role="xml">
    <![CDATA[
...
  <contents>
   <dir name="data">
    <file name="mytask.xml" role="customtask"/>
    <file name="someotherdata.csv" role="data"/>
   </dir>
  </contents>
...
    ]]>
   </programlisting>
  </para>
 </section>
</section>

 </chapter>

  
<chapter xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.plugins">
  <info>
   <title>Creating plugins for Pyrus</title>
   <author><personname><firstname>Gregory</firstname><surname>Beaver</surname></personname></author>
   <date>2009-06-16</date>
  </info>

  <para>
   Pyrus defines three kinds of plugins: commands, file roles, and file tasks.
   Commands add new commands to a frontend for Pyrus, file roles and file tasks
   add new features to package.xml.
  </para>
  <para>
   Pyrus, by necessity, requires a clear separation between its plugins and
   its core.  This is because Pyrus is distributed as a phar archive, which
   cannot be modified without jumping through several hoops.  For this reason,
   plugins are installed in a special directory whose location is specified by
   the <link linkend="pyrus.configuration.user.pluginsdir">plugins_dir</link>
   user configuration variable.
  </para>
  <para>
   Pyrus also makes a clear separation between regular packages and plugin
   packages.  Plugins must be installed separate from any non-plugin packages using the
   <link linkend="pyrus.commands.install.plugin"><literal>--plugin</literal></link>
   option of the <link linkend="pyrus.commands.install">install</link>,
   <link linkend="pyrus.commands.upgrade">upgrade</link>, and
   <link linkend="pyrus.commands.uninstall">uninstall</link> command.  Here is
   an example, installing the developer tools plugin:
  </para>
  <screen>php pyrus.phar install -p PEAR2_Pyrus_Developer</screen>
  <para>
   Pyrus defines a plugin as any package that contains one of the three
   file roles that identify a plugin: <literal>customcommand</literal>,
   <literal>customrole</literal>, or <literal>customtask</literal>.  In addition,
   a plugin package can only contain one plugin.  This helps users by mapping
   one package to one plugin so that when they list plugin packages, it clearly
   shows all of the plugins that are installed.
  </para>
  <para>
   A plugin's definition is handled by an XML file, which must be referenced
   using one of the three plugin file roles in package.xml.  Here is an
   example identifying a custom command in package.xml:
  </para>
  <para>
   <programlisting role="xml">
    <![CDATA[
...
  <dir name="/">
   <dir name="customcommand" baseinstalldir="/">
    <file role="customcommand" name="commands.xml"/>
   </dir>
...
    ]]>
   </programlisting>
  </para>

 <section xml:id="pyrus.plugins.autoload">
  <title>Telling Pyrus how to load your plugin: &lt;class&gt; and &lt;autoloadpath&gt;</title>
  <para>
   Pyrus relies upon PHP5's autoloading capabilities to automatically load a plugin
   class.  All plugins should include the <literal>&lt;autoloadpath&gt;</literal>
   element to specify
   a path relative to the <link linkend="pyrus.configuration.system.phpdir">php_dir</link>
   location for the plugin registry.  For plugin classes that conform to PEAR2
   standards, the autoloadpath should be an empty string:
  </para>
  <programlisting role="xml">
   <![CDATA[
<autoloadpath></autoloadpath>
   ]]>
  </programlisting>
  <para>
   The pyrus autoloader will automatically replace <literal>_</literal> and
   the namespace separator <literal>\</literal> with <constant>DIRECTORY_SEPARATOR</constant>
   and append <literal>.php</literal> to determine the class name to load.  To
   instruct Pyrus to prepend a particular relative path, put this path in the
   <literal>&lt;autoloadpath&gt;</literal> element.  As an example, the following
   XML will prompt Pyrus to load the file
   <literal>/home/user/.pear/MyPackage/customcommands/Command/Line/Obj.php</literal>
   if the user's <link linkend="pyrus.configuration.user.pluginsdir">plugins_dir</link>
   is <literal>/home/user/.pear</literal>:
  </para>
  <programlisting role="xml">
   <![CDATA[
<autoloadpath>MyPackage/customcommands</autoloadpath>
<class>Command_Line\Obj</class>
   ]]>
  </programlisting>
  <para>
   The <literal>&lt;class&gt;</literal> element is used by Pyrus to determine
   which object to instantiate.  If <literal>&lt;class&gt;</literal> is:
  </para>
  <programlisting role="xml">
   <![CDATA[
<class>FooBar_Willy\Dilly</class>
   ]]>
  </programlisting>
  <para>
   Pyrus will instantiate an object of class <literal>FooBar_Willy\Dilly</literal>.
  </para>
 </section>
  
<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="lillet" xml:id="pyrus.plugins.command">
 <info><title>Pyrus plugins: custom commands</title></info>

 <section xml:id="pyrus.plugins.command.intro">
  <info><title>Introduction</title></info>
  <para>
   Custom commands add new functionality to pyrus.phar.  An example of a
   plugin that implements custom commands is the
   <literal>PEAR2_Pyrus_Developer</literal> package, which implements the
   <link linkend="pyrus.commands.make">make</link>,
   <link linkend="pyrus.commands.package">package</link>,
   <link linkend="pyrus.commands.pickle">pickle</link>, and
   <link linkend="pyrus.commands.runphpt">run-phpt</link> commands.
  </para>
  <para>
   Custom command plugins can implement multiple commands, and are defined by
   an xml file that is noted in package.xml with the <literal>customcommand</literal>
   file role.  The XML format is defined and validated by pyrus with the
   <link xlink:href="https://github.com/pear2/PEAR2_Pyrus/blob/master/data/customcommand-2.0.xsd">customcommand.xsd</link>
   XSchema file.
  </para>
  <section xml:id="pyrus.plugins.command.intro.args">
   <title>Command Arguments and Options: a brief primer</title>
   <para>
    Commands can have arguments and options.  Here is an example of a command with
    a single argument:
   </para>
   <screen>php pyrus.phar install PackageName</screen>
   <para>
    The command is <literal>install</literal>, and the argument is
    <literal>PackageName</literal>.
   </para>
   <para>
    Here is an example of a command with multiple arguments:
   </para>
   <screen>php pyrus.phar install PackageName package.xml http://example.com/Foo.tgz</screen>
   <para>
    The command is <literal>install</literal>, and the arguments are
    <literal>PackageName</literal>, <literal>package.xml</literal> and
    <literal>http://example.com/Foo.tgz</literal>.
   </para>
   <para>
    An option is a special argument that is preceded by 1-2 dashes (<literal>-</literal> or
    <literal>--</literal>).  Short arguments are single letters preceded by a dash,
    and long arguments are words preceded by two dashes.  Here is an example
    of a command with both a short and a long option
   </para>
   <screen>php pyrus.phar package -p --tar</screen>
   <para>
    The command is <literal>package</literal>, the short option is
    <literal>-p</literal> and the long option is <literal>--tar</literal>.  Short
    options are aliases for long options.  For the <literal>package</literal> command,
    the <literal>-p</literal> short
    option is an alias to the <literal>--phar</literal> long option.
   </para>
   <para>
    Options can also accept arguments in 2 formats.  If an option accepts
    an argument, there are two ways of passing that argument.  Short options
    consider the next argument to be their argument:
   </para>
   <screen>php pyrus.phar install -r /path/to/packagingroot PackageName</screen>
   <para>
    <literal>/path/to/packagingroot</literal> is the argument to the short
    option <literal>-r</literal>, <literal>PackageName</literal> is the argument
    to the <literal>install</literal> command.
   </para>
   <para>
    Long options require an <literal>=</literal> sign in between the option and
    the argument as in:
   </para>
   <screen>php pyrus.phar install --packagingroot=/path/to/packagingroot PackageName</screen>
   <para>
    <literal>/path/to/packagingroot</literal> is the argument to the long
    option <literal>--packagingroot</literal>, <literal>PackageName</literal> is the argument
    to the <literal>install</literal> command.
   </para>
  </section>
 </section>
 <section xml:id="pyrus.plugins.command.xmloverview">
  <title>Overview of the Custom Command XML Format</title>
  <para>
   Here is a human-readable overview of a custom command's XML definition file.
   Optional tags are enclosed in [brackets].  If there is a choice of
   tags, they are separated by a vertical line <literal>|</literal> and
   enclosed in parentheses like <literal>(&lt;this&gt;|&lt;example&gt;)</literal>.
  </para>
  <para>
   <programlisting role="xml">
    <![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<commands version="2.0" xmlns="http://pear2.php.net/dtd/customcommand-2.0">
 <command>
  <name>commandname</name>
  <class>CommandClass\Name</class>
  <function>makePackageXml</function>
[ <webfunction>webCommand</webfunction>]
[ <gtkfunction>gtkCommand</gtkfunction>]
[ <autoloadpath>CommandClass</autoloadpath>]
  <summary>Short description of command purpose</summary>
  <shortcut>CN</shortcut>
  <options>
  [<option>
    <name>optionname</name>
    <shortopt>O</shortopt>
    <type>(<bool/>|<string/>|<int/>|<float/>|<counter/>|
           <callback>optionProcessorCallback</callback>|
           <set><value>value1</value><value>value2</value>...</set>)</type>
   [<default>defaultvalue</default>]
    <doc>Short description of option purpose</doc>
   </option>]
  </options>
  <arguments>
  [<argument>
    <name>argname</name>
    <multiple>0</multiple>
    <optional>1</optional>
    <doc>Short argument description</doc>
   </argument>]
  </arguments>
  <doc>
Long description of command usage for help output
  </doc>
 </command>
</commands>
    ]]>
   </programlisting>
  </para>
  <para>
   A command need not require or accept any arguments or options, and can
   accept multiple arguments and multiple options.  In addition, a custom command
   definition XML file may declare multiple commands.
  </para>
  <para>
   Commands can also implement a shortcut, which is a shorter alias.  The
   <literal>upgrade</literal> command, for instance, has a shortcut of
   <literal>up</literal>.
  </para>
  <para>
   By convention, all command names of external projects should be prefixed with
   the vendor name.  For instance, if the vendor is Zend Framework, commands should be
   prefixed with something like <literal>zf-</literal> or with <literal>zend-</literal>.
   An install command would be <literal>zf-install</literal>.
  </para>
  <para>
   In addition, all shortcuts from external vendors should be upper-cased and
   consist of the first letter of the vendor, and the first two letters
   of the command.  <literal>zf-install</literal> would have a shortcut of
   <literal>Zin</literal>.  This helps to avoid name collisions between
   vendors.
  </para>
 </section>
 <section xml:id="pyrus.plugins.command.autoload">
  <title>Telling Pyrus how to load your command: &lt;class&gt; and &lt;autoloadpath&gt;</title>
  <para>
   This is the same method used for all plugins, and is documented
   <link linkend="pyrus.plugins.autoload">here</link>.
  </para>
  <para>
   The three frontend command handlers are discussed in the
   <link linkend="pyrus.plugins.command.cli">CLI</link> section,
   <link linkend="pyrus.plugins.command.web">Web</link> section, and the
   <link linkend="pyrus.plugins.command.gtk">Gtk</link> section.
  </para>
 </section>
 <section xml:id="pyrus.plugins.command.arguments">
  <title>Defining arguments</title>
  <para>
   Pyrus recognizes both optional and required arguments, as well as the ability
   to specify repeating arguments.  The logic is very similar to function
   signatures in PHP.  Each argument is placed by name into an associative
   array and passed to the function.  Note that invalid input is not passed
   to custom commands, so a command can assume valid input if it is called.
  </para>
  <para>
   Here is a sample argument definition and the way that Pyrus will handle
   different valid inputs for the hypothetical foo command:
  </para>
  <programlisting role="xml">
   <![CDATA[
 <arguments>
  <argument>
   <name>argname</name>
   <multiple>0</multiple>
   <optional>0</optional>
   <doc>required arg</doc>
  </argument>
  <argument>
   <name>argname2</name>
   <multiple>0</multiple>
   <optional>1</optional>
   <doc>optional arg</doc>
  </argument>
  <argument>
   <name>argname3</name>
   <multiple>1</multiple>
   <optional>1</optional>
   <doc>optional arg, multiple</doc>
  </argument>
 </arguments>
   ]]>
  </programlisting>
  <screen>php pyrus.phar foo arg1</screen>
  <programlisting role="php">
   <![CDATA[
    function foo($frontend, $args, $options)
    {
        // $args = array('argname' => 'arg1')
    }
   ]]>
  </programlisting>
  <screen>php pyrus.phar foo arg1 arg2</screen>
  <programlisting role="php">
   <![CDATA[
    function foo($frontend, $args, $options)
    {
        // $args = array('argname' => 'arg1', 'argname2' => 'arg2')
    }
   ]]>
  </programlisting>
  <screen>php pyrus.phar foo arg1 arg2 arg3</screen>
  <programlisting role="php">
   <![CDATA[
    function foo($frontend, $args, $options)
    {
        // $args = array('argname' => 'arg1', 'argname2' => 'arg2', 'argname3' => array('arg3'))
    }
   ]]>
  </programlisting>
  <screen>php pyrus.phar foo arg1 arg2 arg3 arg4</screen>
  <programlisting role="php">
   <![CDATA[
    function foo($frontend, $args, $options)
    {
        // $args = array('argname' => 'arg1', 'argname2' => 'arg2', 'argname3' => array('arg3', 'arg4'))
    }
   ]]>
  </programlisting>
 </section>
 <section xml:id="pyrus.plugins.command.options">
  <title>Defining options</title>
  <para>
   Options must define a short and a long option, a type for the option, and
   a short description of the option for help text.
  </para>
  <para>
   Options fall into two categories, those that accept arguments, and those that don't.
   Options that don't accept arguments are of type <literal>&lt;bool/&gt;</literal>
   and <literal>&lt;counter/&gt;</literal>.
  </para>
  <para>
   The types recognized are:
   <itemizedlist>
    <listitem><simpara><literal>&lt;bool/&gt;</literal></simpara></listitem>
    <listitem><simpara><literal>&lt;counter/&gt;</literal></simpara></listitem>
    <listitem><simpara><literal>&lt;string/&gt;</literal></simpara></listitem>
    <listitem><simpara><literal>&lt;int/&gt;</literal></simpara></listitem>
    <listitem><simpara><literal>&lt;float/&gt;</literal></simpara></listitem>
    <listitem><simpara><literal>&lt;callback&gt;&lt;/callback&gt;</literal></simpara></listitem>
    <listitem><simpara><literal>&lt;set&gt;&lt;/set&gt;</literal></simpara></listitem>
   </itemizedlist>
  </para>
  <section xml:id="pyrus.plugins.command.options.bool">
   <title>&lt;bool/&gt;</title>
   <para>
    A <literal>&lt;bool/&gt;</literal> option sets its value to <constant xmlns="http://docbook.org/ns/docbook">TRUE</constant> if
    present, and <constant xmlns="http://docbook.org/ns/docbook">FALSE</constant> if not.
   </para>
   <programlisting role="xml">
    <![CDATA[
  <options>
   <option>
    <name>nocompatible</name>
    <shortopt>n</shortopt>
    <type><bool/></type>
    <doc>Do not generate package_compatible.xml</doc>
   </option>
  </options>
    ]]>
   </programlisting>
   <screen>php pyrus.phar foo</screen>
   <programlisting role="php">
    <![CDATA[
    function foo($frontend, $args, $options)
    {
        // $options = array('nocompatible' => false)
    }
    ]]>
   </programlisting>
   <screen>php pyrus.phar foo -n</screen>
   <programlisting role="php">
    <![CDATA[
    function foo($frontend, $args, $options)
    {
        // $options = array('nocompatible' => true)
    }
    ]]>
   </programlisting>
   <screen>php pyrus.phar foo --nocompatible</screen>
   <programlisting role="php">
    <![CDATA[
    function foo($frontend, $args, $options)
    {
        // $options = array('nocompatible' => true)
    }
    ]]>
   </programlisting>
  </section>
  <section xml:id="pyrus.plugins.command.options.counter">
   <title>&lt;counter/&gt;</title>
   <para>
    A <literal>&lt;counter/&gt;</literal> option sets its value to <literal>0</literal>
    if not present, and to the number of times the option is present if it is.
    This is the only option type for which multiple occurrences of the option
    are allowed.
   </para>
   <programlisting role="xml">
    <![CDATA[
  <options>
   <option>
    <name>verbose</name>
    <shortopt>v</shortopt>
    <type><counter/></type>
    <doc>How verbose to be with output</doc>
   </option>
  </options>
    ]]>
   </programlisting>
   <screen>php pyrus.phar foo</screen>
   <programlisting role="php">
    <![CDATA[
    function foo($frontend, $args, $options)
    {
        // $options = array('verbose' => 0)
    }
    ]]>
   </programlisting>
   <screen>php pyrus.phar foo -v</screen>
   <programlisting role="php">
    <![CDATA[
    function foo($frontend, $args, $options)
    {
        // $options = array('verbose' => 1)
    }
    ]]>
   </programlisting>
   <screen>php pyrus.phar foo --verbose -vv --verbose</screen>
   <programlisting role="php">
    <![CDATA[
    function foo($frontend, $args, $options)
    {
        // $options = array('verbose' => 4)
    }
    ]]>
   </programlisting>
  </section>
  <section xml:id="pyrus.plugins.command.options.string">
   <title>&lt;string/&gt;</title>
   <para>
    A <literal>&lt;string/&gt;</literal> option sets its value to the
    argument passed in if present, or to <constant xmlns="http://docbook.org/ns/docbook">NULL</constant> if not present.
   </para>
   <programlisting role="xml">
    <![CDATA[
  <options>
   <option>
    <name>name</name>
    <shortopt>n</shortopt>
    <type><string/></type>
    <doc>Name of foo</doc>
   </option>
  </options>
    ]]>
   </programlisting>
   <screen>php pyrus.phar foo</screen>
   <programlisting role="php">
    <![CDATA[
    function foo($frontend, $args, $options)
    {
        // $options = array('name' => null)
    }
    ]]>
   </programlisting>
   <screen>php pyrus.phar foo -n myname</screen>
   <programlisting role="php">
    <![CDATA[
    function foo($frontend, $args, $options)
    {
        // $options = array('name' => 'myname')
    }
    ]]>
   </programlisting>
   <screen>php pyrus.phar foo --name=myname</screen>
   <programlisting role="php">
    <![CDATA[
    function foo($frontend, $args, $options)
    {
        // $options = array('name' => 'myname')
    }
    ]]>
   </programlisting>
  </section>
  <section xml:id="pyrus.plugins.command.options.int">
   <title>&lt;int/&gt;</title>
   <para>
    An <literal>&lt;int/&gt;</literal> option sets its value to the
    integer argument passed in if present, or to <constant xmlns="http://docbook.org/ns/docbook">NULL</constant> if not present.
   </para>
   <programlisting role="xml">
    <![CDATA[
  <options>
   <option>
    <name>namecount</name>
    <shortopt>n</shortopt>
    <type><int/></type>
    <doc>Number of foo names</doc>
   </option>
  </options>
    ]]>
   </programlisting>
   <screen>php pyrus.phar foo</screen>
   <programlisting role="php">
    <![CDATA[
    function foo($frontend, $args, $options)
    {
        // $options = array('namecount' => null)
    }
    ]]>
   </programlisting>
   <screen>php pyrus.phar foo -n 3</screen>
   <programlisting role="php">
    <![CDATA[
    function foo($frontend, $args, $options)
    {
        // $options = array('namecount' => 3)
    }
    ]]>
   </programlisting>
   <screen>php pyrus.phar foo --namecount=3</screen>
   <programlisting role="php">
    <![CDATA[
    function foo($frontend, $args, $options)
    {
        // $options = array('namecount' => 3)
    }
    ]]>
   </programlisting>
  </section>
  <section xml:id="pyrus.plugins.command.options.float">
   <title>&lt;float/&gt;</title>
   <para>
    A <literal>&lt;float/&gt;</literal> option sets its value to the
    float argument passed in if present, or to <constant xmlns="http://docbook.org/ns/docbook">NULL</constant> if not present.
   </para>
   <programlisting role="xml">
    <![CDATA[
  <options>
   <option>
    <name>foopercent</name>
    <shortopt>f</shortopt>
    <type><float/></type>
    <doc>Foo percent in decimal notation</doc>
   </option>
  </options>
    ]]>
   </programlisting>
   <screen>php pyrus.phar foo</screen>
   <programlisting role="php">
    <![CDATA[
    function foo($frontend, $args, $options)
    {
        // $options = array('foopercent' => null)
    }
    ]]>
   </programlisting>
   <screen>php pyrus.phar foo -f .2</screen>
   <programlisting role="php">
    <![CDATA[
    function foo($frontend, $args, $options)
    {
        // $options = array('foopercent' => 0.2)
    }
    ]]>
   </programlisting>
   <screen>php pyrus.phar foo --foopercent=0.3</screen>
   <programlisting role="php">
    <![CDATA[
    function foo($frontend, $args, $options)
    {
        // $options = array('foopercent' => 0.3)
    }
    ]]>
   </programlisting>
  </section>
  <section xml:id="pyrus.plugins.command.options.callback">
   <title>&lt;callback&gt;&lt;/callback&gt;</title>
   <para>
    A <literal>&lt;callback/&gt;</literal> option calls the specified
    callback with the value passed in by the user as a string.
    The callback must be a static method in the same class that
    implements the command.
   </para>
   <programlisting role="xml">
    <![CDATA[
  <options>
   <option>
    <name>foocallback</name>
    <shortopt>f</shortopt>
    <type><callback>processfoo</callback></type>
    <doc>Foo date</doc>
   </option>
  </options>
    ]]>
   </programlisting>
   <screen>php pyrus.phar foo</screen>
   <programlisting role="php">
    <![CDATA[
    function foo($frontend, $args, $options)
    {
        // $options = array('foocallback' => null)
    }

    static function processfoo($value)
    {
        // $value = null
        return null;
    }
    ]]>
   </programlisting>
   <screen>php pyrus.phar foo -f 2009-12-31</screen>
   <programlisting role="php">
    <![CDATA[
    function foo($frontend, $args, $options)
    {
        // $options = array('foocallback' => new DateTime('2009-12-31', new DateTimeZone('UTC')))
    }

    static function processfoo($value)
    {
        // $value = '2009-12-31';
        $date = new DateTime($value, new DateTimeZone('UTC'));
        return $date;
    }
    ]]>
   </programlisting>
   <screen>php pyrus.phar foo --foocallback=2009-12-31</screen>
   <programlisting role="php">
    <![CDATA[
    function foo($frontend, $args, $options)
    {
        // $options = array('foocallback' => new DateTime('2009-12-31', new DateTimeZone('UTC')))
    }

    static function processfoo($value)
    {
        // $value = '2009-12-31';
        $date = new DateTime($value, new DateTimeZone('UTC'));
        return $date;
    }
    ]]>
   </programlisting>
  </section>
  <section xml:id="pyrus.plugins.command.options.set">
   <title>&lt;set&gt;&lt;/set&gt;</title>
   <para>
    A <literal>&lt;set/&gt;</literal> option sets its value to <constant xmlns="http://docbook.org/ns/docbook">NULL</constant> if not
    present.  Otherwise it ensures that the value passed in by the user is within
    a pre-defined acceptable list of values.
   </para>
   <programlisting role="xml">
    <![CDATA[
  <options>
   <option>
    <name>numbah</name>
    <shortopt>n</shortopt>
    <type>
     <set>
      <value>one</value>
      <value>two</value>
      <value>three</value>
      <value>four</value>
     </set>
    </type>
    <doc>Numbers less than five</doc>
   </option>
  </options>
    ]]>
   </programlisting>
   <screen>php pyrus.phar foo</screen>
   <programlisting role="php">
    <![CDATA[
    function foo($frontend, $args, $options)
    {
        // $options = array('numbah' => null)
    }
    ]]>
   </programlisting>
   <screen>php pyrus.phar foo -n four</screen>
   <programlisting role="php">
    <![CDATA[
    function foo($frontend, $args, $options)
    {
        // $options = array('numbah' => 'four')
    }
    ]]>
   </programlisting>
   <screen>php pyrus.phar foo --numbah=one</screen>
   <programlisting role="php">
    <![CDATA[
    function foo($frontend, $args, $options)
    {
        // $options = array('numbah' => 'one')
    }
    ]]>
   </programlisting>
  </section>
 </section>
 <section xml:id="pyrus.plugins.command.cli">
  <title>Declaring CLI command method</title>
  <para>
   A class must implement a command-line handler, which should have this method
   signature:
  </para>
  <programlisting role="php">
   <![CDATA[
    function commandhandler($frontend, $args, $options)
    {
        // perform command here
    }
   ]]>
  </programlisting>
  <para>
   The first argument is the CLI frontend, and can be used for asking the user
   a question with the <function>ask</function> method, or passing control
   to a built-in command.  <literal>$args</literal> is an associative array of
   arguments.  Only required arguments are guaranteed to be present, all optional
   arguments must be verified as present before using.  <literal>$options</literal>
   is an associative array of options.  All options will be present, those not present
   will be initialized to <constant xmlns="http://docbook.org/ns/docbook">NULL</constant>.
  </para>
  <para>
   Options should be accessed using their long names, and arguments using their
   names (see examples in the documentation sections for arguments and options
   above).
  </para>
  <para>
   The <function>ask</function> method accepts 3 arguments:
   <orderedlist>
    <listitem>
     <para>
      string <literal>$question</literal> the question to ask the user.  It should end in a question mark
     </para>
    </listitem>
    <listitem>
     <para>
      (optional) array <literal>$choices</literal> an array of possible answers
     </para>
    </listitem>
    <listitem>
     <para>
      (optional) string <literal>$default</literal> the default answer
     </para>
    </listitem>
   </orderedlist>
  </para>
 </section>
 <section xml:id="pyrus.plugins.command.web">
  <title>Declaring Web command method</title>
  <para>
   Although a Web frontend has not yet been written for Pyrus, the XML command
   format supports the eventual addition of a Web frontend.  A separate method
   should be used for the Web handling, and is named via the
   <literal>&lt;webfunction&gt;</literal> tag.
  </para>
 </section>
 <section xml:id="pyrus.plugins.command.gtk">
  <title>Declaring GTK command method</title>
  <para>
   Although a GTK frontend has not yet been written for Pyrus, the XML command
   format supports the eventual addition of a GTK frontend.  A separate method
   should be used for the GTK handling, and is named via the
   <literal>&lt;gtkfunction&gt;</literal> tag.
  </para>
 </section>
</section>

  
<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="lillet" xml:id="pyrus.plugins.role">
 <info><title>Pyrus plugins: custom file roles</title></info>

 <section xml:id="pyrus.plugins.role.intro">
  <info><title>Introduction</title></info>
  <para>
   If you are not familiar with how file roles install, read the
   <link linkend="guide.users.concepts.filerole">introduction to file roles</link>
   first.  This segment of the documentation assumes you are familiar with
   concepts such as <literal>baseinstalldir</literal> and with what a file
   role means in terms of installation location.
  </para>
  <para>
   Custom file roles can implement a single role, and are defined by
   an xml file that is noted in package.xml with the <literal>customrole</literal>
   file role.  The XML format is defined and validated by pyrus with the
   <link xlink:href="https://github.com/pear2/PEAR2_Pyrus/blob/master/data/customrole-2.0.xsd">customrole-2.0.xsd</link>
   XSchema file.
  </para>
  <para>
   Here is a human-readable custom file role xml file definition.
   Optional elements are enclosed in [brackets], and if there is a choice of
   values, they are delimited with a vertical bar <literal>|</literal> and
   enclosed in (parentheses).
  </para>
  <programlisting role="xml">
   <![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<role version="2.0" xmlns="http://pear2.php.net/dtd/customrole-2.0">
 <name>rolename</name>
 <class>MyPlugin_Rolename</class>
[<validationmethod>validate</validationmethod>]
[<autoloadpath>relative/path/to/MyPlugin</autoloadpath>]
(<releasetype>php</releasetype>|<releasetype>extsrc</releasetype>|
 <releasetype>extbin</releasetype>|<releasetype>zendextsrc</releasetype>|
 <releasetype>zendextbin</releasetype>)
 <installable>(1|0)</installable>
 <locationconfig>config_var</locationconfig>
 <honorsbaseinstall>(1|0)</honorsbaseinstall>
 <unusualbaseinstall>(1|0)</unusualbaseinstall>
 <executable>(1|0)</executable>
[<configvar>
  <name>config_name</name>
  <type>string</type>
  <default>
   <![CDATA[
    <?php $default = 'hi'; ?>
   ]]]]><![CDATA[>
  </default>
  <doc>Extensive, multi-line documentation</doc>
 [<validset>val1</validset><validset>val2</validset>...]
  <prompt>summary documentation</prompt>
  <group>Custom</group>
  <configtype>(system|user|channel-specific)</configtype>
 </configvar>]*
</role>
   ]]>
  </programlisting>
 </section>
 <section xml:id="pyrus.plugins.role.autoload">
  <title>Telling Pyrus how to load your role: &lt;class&gt; and &lt;autoloadpath&gt;</title>
  <para>
   This is the same method used for all plugins, and is documented
   <link linkend="pyrus.plugins.autoload">here</link>.
  </para>
 </section>
 <section xml:id="pyrus.plugins.role.packagetimevalidation">
  <title>Validating your custom role at packaging time</title>
  <para>
   Some roles benefit from the ability to validate the files they represent
   at packaging time.  For instance, a <literal>customcommand</literal> file
   is checked to ensure it conforms to its XML schema, so that a custom command
   with invalid XML cannot be distributed by mistake.
  </para>
  <para>
   By convention, a validation method should be named <literal>validate</literal>,
   although the xml supports any name.  The method name should be placed in
   the <literal>&lt;validationmethod</literal> tag, and the method itself should
   have the same method signature as this example from Pyrus's
   <literal>customrole</literal> validation:
  </para>
  <programlisting role="php">
   <![CDATA[
    function validate(\PEAR2\Pyrus\IPackage $package, array $file)
    {
        $parser = new \PEAR2\Pyrus\XMLParser;
        $schemapath = \PEAR2\Pyrus\Main::getDataPath();
        if (!file_exists(\PEAR2\Pyrus\Main::getDataPath() . '/customrole-2.0.xsd')) {
            $schemapath = realpath(__DIR__ . '/../../../../data');
        }
        $taskschema = $schemapath . '/customrole-2.0.xsd';
        try {
            $taskinfo = $parser->parse($package->getFilePath($file['attribs']['name']), $taskschema);
        } catch (\Exception $e) {
            throw new \PEAR2\Pyrus\Installer\Role\Exception('Invalid custom role definition file,' .
                                                           ' file does not conform to the schema', $e);
        }
    }
   ]]>
  </programlisting>
  <para>
   A custom file role package-time validator should throw a
   <literal>PEAR2_Pyrus_Installer_Role_Exception</literal> exception object
   with an error message describing the reason for validation failure, or simply
   return on success.
  </para>
 </section>
 <section xml:id="pyrus.plugins.role.releasetype">
  <title>Release Types and file roles</title>
  <para>
   The <literal>&lt;releasetype&gt;</literal> element is used to tell Pyrus
   which releases can contain a file with this role.  For instance, the
   <literal>src</literal> role only has meaning in a PHP extension source release,
   and is only allowed in <literal>extsrc</literal> and <literal>zendextsrc</literal>
   release types.
  </para>
  <para>
   There are 5 release types that Pyrus recognizes:
   <itemizedlist>
    <listitem><para><literal>php</literal> - this is for PEAR-style packages distributing PHP code</para></listitem>
    <listitem><para><literal>extsrc</literal> - this is for PHP extension source packages</para></listitem>
    <listitem><para><literal>extbin</literal> - this is for PHP extension binary packages</para></listitem>
    <listitem><para><literal>zendextsrc</literal> - this is for PHP Zend extension source packages</para></listitem>
    <listitem><para><literal>zendextbin</literal> - this is for PHP Zend extension binary packages</para></listitem>
   </itemizedlist>
  </para>
 </section>
 <section xml:id="pyrus.plugins.role.installable">
  <title>&lt;installable&gt;</title>
  <para>
   If set to <literal>0</literal>, the file will not actually be installed onto
   the system.  Most file roles should set this to <literal>1</literal>.
  </para>
 </section>
 <section xml:id="pyrus.plugins.role.locationconfig">
  <title>&lt;locationconfig&gt;</title>
  <para>
   This element is used to tell Pyrus which configuration variable should be
   used to determine where to install the file.  This can be a
   <link linkend="pyrus.plugins.role.configvar">custom configuration variable</link>.
  </para>
 </section>
 <section xml:id="pyrus.plugins.role.baseinstall">
  <title>&lt;honorsbaseinstall&gt; and &lt;unusualbaseinstall&gt;</title>
  <para>
   The <literal>&lt;honorsbaseinstall&gt;</literal> element tells Pyrus to
   honor the <literal>baseinstalldir</literal> attribute (documentation on
   baseinstalldir is <link linkend="guide.users.concepts.filerole.baseinstalldir">here</link>)
   for roles like <literal>php</literal>.
  </para>
  <para>
   The <literal>&lt;unusualbaseinstall&gt;</literal> element tells Pyrus to
   honor the <literal>baseinstalldir</literal> attribute for roles like
   <literal>data</literal> that also prepend channel/package name to the
   installation location.
  </para>
 </section>
 <section xml:id="pyrus.plugins.role.executable">
  <title>&lt;executable&gt;</title>
  <para>
   If <literal>&lt;executable&gt;</literal> is set to <literal>1</literal>,
   Pyrus will make the installed file an executable file on unix systems
   (the equivalent of <screen>chmod +x filename</screen>).
  </para>
 </section>
 <section xml:id="pyrus.plugins.role.configvar">
  <title>Defining custom configuration variables</title>
  <para>
   A custom file role can optionally define a single or multiple custom
   configuration variables.  There are 3 kinds of configuration variables
   that Pyrus supports, <literal>system</literal>, <literal>user</literal> and
   <literal>channel-specific</literal>.  Documentation on configuration is
   available <link linkend="pyrus.configuration">here</link>.  Read that before
   continuing in order to understand how different configuration variables work.
  </para>
  <para>
   Pyrus supports one type of configuration variable: <literal>string</literal>.
   The values can be restricted to a specific set of values with the
   <literal>&lt;validset&gt;</literal> element.
  </para>
 </section>
</section>

  
<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="lillet" xml:id="pyrus.plugins.task">
 <info><title>Pyrus plugins: custom file tasks</title></info>

 <section xml:id="pyrus.plugins.task.intro">
  <info><title>Introduction</title></info>
  <para>
   If you are not familiar with how file tasks work, read the
   <link linkend="guide.users.concepts.filetasks">introduction to file tasks</link>
   first.
  </para>
  <para>
   Custom file tasks can implement a single task, and are defined by
   an xml file that is noted in package.xml with the <literal>customtask</literal>
   file role.  The XML format is defined and validated by pyrus with the
   <link xlink:href="https://github.com/pear2/PEAR2_Pyrus/blob/master/data/customtask-2.0.xsd">customtask-2.0.xsd</link>
   XSchema file.
  </para>
  <para>
   Here is a human-readable custom file task xml file definition.
   Optional elements are enclosed in [brackets].
  </para>
  <programlisting role="xml">
   <![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<task version="2.0" xmlns="http://pear2.php.net/dtd/customtask-2.0">
 <name>taskname</name>
 <class>MyPlugin_Taskname</class>
[<autoloadpath>relative/path/to/MyPlugin</autoloadpath>]
</task>
   ]]>
  </programlisting>
 </section>
 <section xml:id="pyrus.plugins.task.autoload">
  <title>Telling Pyrus how to load your task: &lt;class&gt; and &lt;autoloadpath&gt;</title>
  <para>
   This is the same method used for all plugins, and is documented
   <link linkend="pyrus.plugins.autoload">here</link>.
  </para>
 </section>
 <section xml:id="pyrus.plugins.task.taskclass">
  <title>Defining the task: the task class</title>
  <para>
   A custom file task must extend the <literal>\PEAR2\Pyrus\Task\Common</literal>
   class, and must implement a few methods:
   <itemizedlist>
    <listitem><simpara><function>validateXml</function></simpara></listitem>
    <listitem><simpara><function>startSession</function></simpara></listitem>
   </itemizedlist>
  </para>
  <para>
   Optionally, <function>__construct</function> may be used to do special
   pre-processing, storing of information or other setup tasks.
  </para>
  <para>
   A task must also define two class constants, <constant>TYPE</constant>
   and <constant>PHASE</constant>.  <constant>TYPE</constant> should be one of
   <literal>'simple'</literal> or
   <literal>'script'</literal>.  <literal>'script'</literal> tasks are
   post-install scripts, and are executed by the
   <link linkend="pyrus.commands.runscripts">run-scripts</link> command.
   <literal>'simple'</literal> tasks are executed while installation is
   in progress.
  </para>
  <para>
   <constant>PHASE</constant> should be one of:
   <itemizedlist>
    <listitem><simpara><constant>\PEAR2\Pyrus\Task\Common::PACKAGE</constant></simpara></listitem>
    <listitem><simpara><constant>\PEAR2\Pyrus\Task\Common::INSTALL</constant></simpara></listitem>
    <listitem><simpara><constant>\PEAR2\Pyrus\Task\Common::PACKAGEANDINSTALL</constant></simpara></listitem>
    <listitem><simpara><constant>\PEAR2\Pyrus\Task\Common::POSTINSTALL</constant></simpara></listitem>
   </itemizedlist>
   <constant>\PEAR2\Pyrus\Task\Common::POSTINSTALL</constant> is only used by
   post-install scripts, the other 3 are used to determine at what time the
   task should be called.  If your custom task only works at installation-time,
   use <constant>\PEAR2\Pyrus\Task\Common::INSTALL</constant>.  If the task can
   perform only at package time (this is exceedingly rare), use
   <constant>\PEAR2\Pyrus\Task\Common::PACKAGE</constant>.  Most tasks should use
   <constant>\PEAR2\Pyrus\Task\Common::PACKAGEANDINSTALL</constant>.  If your task
   can perform its task at packaging time, then you should override the
   <function>isPreProcessed</function> method and return true.  Some tasks, such
   as the <literal>replace</literal> task, perform some of their actions at
   package time, and the rest at install time.  The <function>isPreProcessed</function>
   method should only return true if the XML of the specific task could be
   processed at package time.
  </para>
  <para>
   The <function>startSession</function> method is used to actually execute the
   task, and is passed a read/write file resource that is set to the beginning
   of the file being installed.  The full path of the file's final installation
   location is also passed in, and can be used for throwing exceptions.  All
   errors should be handled by throwing a <literal>PEAR2\Pyrus\Task\Exception</literal>
   or one of its descendants.
  </para>
  <para>
   The <function>validateXml</function> method should validate the XML as
   represented in an array format.  The array uses associative arrays for tags,
   the <literal>attribs</literal> index for attributes, and for a tag with both
   attributes and content, the <literal>_content</literal> index contains the
   content.  If present, the <literal>tasks:</literal> namespace is removed
   from the tags prior to passing to <function>validateXml</function>.  On
   encountering validation errors, the method should throw one of the four
   exceptions in the example below.
  </para>
 </section>
 <section xml:id="pyrus.plugins.task.example">
  <title>Example Custom Task</title>
  <programlisting role="php">
   <![CDATA[
<?php
class MyPlugin_Taskname extends \PEAR2\Pyrus\Task\Common
{
    const TYPE = 'simple';
    const PHASE = \PEAR2\Pyrus\Task\Common::PACKAGEANDINSTALL;

    /**
     * Initialize a task instance with the parameters
     * @param array raw, parsed xml
     * @param array attributes from the <file> tag containing this task
     * @param string|null last installed version of this package
     */
    function __construct($pkg, $phase, $xml, $attribs, $lastversion)
    {
        parent::__construct($pkg, $phase, $xml, $attribs, $lastversion);
        // do any special parsing of attributes/contents here
        // phase is one of \PEAR2\Pyrus\Task\Common::PACKAGE,
        // \PEAR2\Pyrus\Task\Common::INSTALL, or
        // \PEAR2\Pyrus\Task\Common::POSTINSTALL
    }

    /**
     * Validate the basic contents of a <taskname> tag
     * @param PEAR_Pyrus_IPackageFile
     * @param array
     * @param array the entire parsed <file> tag
     * @param string the filename of the package.xml
     * @throws \PEAR2\Pyrus\Task\Exception\InvalidTask
     * @throws \PEAR2\Pyrus\Task\Exception\NoAttributes
     * @throws \PEAR2\Pyrus\Task\Exception\MissingAttribute
     * @throws \PEAR2\Pyrus\Task\Exception\WrongAttributeValue
     */
    static function validateXml(PEAR2\Pyrus\IPackage $pkg, $xml, $fileXml, $file)
    {
        if (!isset($xml['attribs'])) {
            throw new \PEAR2\Pyrus\Task\Exception\NoAttributes('taskname', $file);
        }
        if (!isset($xml['attribs']['attributename'])) {
            throw new \PEAR2\Pyrus\Task\Exception\MissingAttribute('taskname',
                                                                  $attrib, $file);
        }
        if ($xml['attribs']['attributename'] != 'hi'
            && $xml['attribs']['attributename'] != 'bye') {
            throw new \PEAR2\Pyrus\Task\Exception\WrongAttributeValue('taskname',
                                                                     'attributename',
                                                                     $xml['attribs']['attributename'],
                                                                     $file,
                                                                     array('hi', 'bye'));
            }
        }
        if (MyPlugin_Other_Class::somecondition()) {
            throw new \PEAR2\Pyrus\Task\Exception\InvalidTask(
                'general validation errors should use this exception');
        }
        return true;
    }

    /**
     * Perform the taskname task
     * @param \PEAR2\Pyrus\IPackage
     * @param resource open file pointer, set to the beginning of the file
     * @param string the eventual final file location (informational only)
     * @return string|false
     */
    function startSession($fp, $dest)
    {
        // use \PEAR2\Pyrus\Logger::log() to send messages to the user
        \PEAR2\Pyrus\Logger::log(3, 'doing stuff');
        \PEAR2\Pyrus\Logger::log(0, 'doing more important stuff');
        // operate directly on the file pointer
        $contents = stream_get_contents($fp);
        $contents .= 'hi';
        rewind($fp);
        ftruncate($fp, 0);
        fwrite($fp, $contents);
        return true;
    }

    /**
     * This is used to tell the installer to skip a task that has already been
     * executed.
     *
     * For example, package-info replacement tasks are performed at packaging
     * time, and do not need to be re-applied on installation
     * @return bool true if task has already been executed on the file at
     *              packaging time
     */
    function isPreProcessed()
    {
        // do not implement this method unless your task does its processing
        // at package-time!
        return true;
    }
}
?>
   ]]>
  </programlisting>
 </section>
</section>

 </chapter>

  
<chapter xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.developers">
  <info>
   <title>Developer Tools for Pyrus</title>
   <author><personname><firstname>Gregory</firstname><surname>Beaver</surname></personname></author>
   <date>2009-06-16</date>
  </info>

  <simpara>
   How to use Pyrus to develop packages for installation by Pyrus.  This documentation is a work in progress.
  </simpara>

  
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.developers.pear2">
 <info><title>Using Pyrus to create PEAR2 packages</title></info>

 <section xml:id="pyrus.developers.pear2.intro">
  <info><title>Introduction</title></info>
  <para>
   Pyrus is particularly well-suited to maintaining a PEAR2 package, and can
   be used to easily create a package.xml with the <link linkend="pyrus.commands.make">make</link>
   command.  Once the requisite files are in place for this command, creating
   a release is as simple as
  </para>
  <para>
   <screen>php -dphar.readonly=0 pyrus.phar make -pphar,tar,tgz,zip</screen>
  </para>
  <para>
   In addition, Pyrus provides a simple facility for creating a new PEAR2 package,
   the <link linkend="pyrus.commands.generatepear2">generate-pear2</link>
   command.  With this command, a skeleton directory and file setup is created
   that can be immediately used to get started with a new package.
  </para>
 </section>
</section>

  
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.developers.pear">
 <info><title>Using Pyrus to create PEAR packages</title></info>

 <section xml:id="pyrus.developers.pear.intro">
  <info><title>Introduction</title></info>
  <para>
   Using Pyrus to manage your existing PEAR package is simple, although not
   as easy as managing a PEAR2 package or PECL extension.  Generally speaking,
   the command you will take advantage of the most is the
   <link linkend="pyrus.commands.package">package</link>
   command, which can be used to create the release needed.
  </para>
 </section>
</section>

  
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.developers.pecl">
 <info><title>Using Pyrus to create PECL packages</title></info>

 <section xml:id="pyrus.developers.pecl.intro">
  <info><title>Introduction</title></info>
  <para>
   As a PECL developer, managing your extensions could not be simpler with
   Pyrus.  The new <link linkend="pyrus.commands.pickle">pickle</link>
   command makes creating a package.xml as simple as creating a few text files
   and then running the command.  In addition, the PECL packages created
   with the <literal>pickle</literal> command are installable by the most
   widely installed version of PEAR as well as by the newest versions of PEAR
   and by Pyrus.
  </para>
  <para>
   Pyrus's <literal>pickle</literal> command fully eliminates the need to ever
   even look at package.xml, greatly simplifying the lives of PECL extension
   developers.
  </para>
  <para>
   In addition, the <link linkend="pyrus.commands.runphpt">run-phpt</link>
   command can be used to run all the extension's phpt test files.
  </para>
 </section>
 <section xml:id="pyrus.developers.pecl.newpackage">
  <title>Creating a new PECL package with Pyrus</title>
  <para>
   If you are creating a brand new extension, you should use the
   <link linkend="pyrus.commands.generateext">generate-ext</link>
   command to create the basic structure of your extension.
  </para>
  <para>
   After creating your extension, edit the newly-created <literal>CREDITS</literal>
   file to have the correct information:
  </para>
<screen>
 <![CDATA[
;; extensionname
My Name (myhandle) <myemail@php.net> (lead)
 ]]>
</screen>
  <para>
   Add any additional maintainers using the same format.
  </para>
  <para>
   Next, edit the <literal>README</literal> file that describes your package.
   The first line should be a brief summary of what the extension does, and the
   rest of the file should be a detailed description of information the user
   should know about the origin of the extension, and perhaps a simple example
   of its usage.
  </para>
  <para>
   Finally, edit the file named <literal>RELEASE-0.1.0</literal>.  Put any
   release notes in here.  Generally <literal>initial release</literal> is
   enough information for the first release.
  </para>
  <para>
   Last, you can optionally create a file named <literal>API-0.1.0</literal>.
   Pyrus and the PEAR Installer differentiate between API version and
   release version, to allow clearly defining an API change or backwards
   compatibility break.  Put information on any API changes into
   <literal>API-0.1.0</literal>.
  </para>
  <para>
   After creating these files, simply run:
   <screen>php pyrus.phar pickle extensionname</screen>
   where <literal>extensionname</literal> is the name of your extension.  If
   you have not yet installed the developer tools, Pyrus will ask if you would
   like to download and install them.  Choose <literal>yes</literal> and then
   re-run the command.
  </para>
  <para>
   Pyrus will create a package.xml and a release called
   <literal>extensionname-0.1.0.tgz</literal>, or
   <literal>extensionname-0.1.0.tar</literal> if the <literal>zlib</literal>
   extension is not enabled.  This release can be uploaded to pecl.php.net
   for immediate distribution.
  </para>
  <para>
   Note that the directory structure described in
   <link linkend="pyrus.commands.pickle">pickle command documentation</link> is
   required for pickle to detect documentation, tests, or data files.
  </para>
 </section>
 <section xml:id="pyrus.developers.pecl.existingpackage">
  <title>Readying an existing PECL package for Pyrus</title>
  <para>
   To prepare an existing PECL package for Pyrus, you should create all of the
   information files described in the section
   <link linkend="pyrus.developers.pecl.newpackage">Creating a new PECL Package with Pyrus</link>,
   but instead of creating <literal>RELEASE-0.1.0</literal> and
   <literal>API-0.1.0</literal>, you would create a file named
   <literal>RELEASE-X.Y.Z</literal> where <literal>X.Y.Z</literal> is the
   version of the extension.  So if your extension's version is <literal>1.2.3</literal>
   you would create a file named <literal>RELEASE-1.2.3</literal>.  For each
   of the files above, rather than putting new content, you can copy/paste the
   existing description, summary and release notes from your existing package.xml.
   Note that any entities such as <literal>&amp;lt;</literal> should be
   converted to their values <literal>&lt;</literal>, as Pyrus escapes automatically
   from the text files.
  </para>
  <para>
   Note that the directory structure described in
   <link linkend="pyrus.commands.pickle">pickle command documentation</link> is
   required for pickle to detect documentation, tests, or data files.
  </para>
 </section>
 <section xml:id="pyrus.developers.pecl.future">
  <title>Future releases</title>
  <para>
   When the time rolls around for the next release, readying for this is also
   simple.  If you are about to release version <literal>0.2.0</literal>, create
   a file named <literal>RELEASE-0.2.0</literal> and put the release notes
   into the file.  Pyrus will automatically detect that <literal>0.2.0</literal>
   is newer than <literal>0.1.0</literal> and create a new release with those notes.
  </para>
 </section> 
</section>

 </chapter>

  
<chapter xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="pyrus.extending">
  <info>
   <title>Using Pyrus in your programs: Pyrus's Public API</title>
   <author><personname><firstname>Gregory</firstname><surname>Beaver</surname></personname></author>
   <date>2009-07-08</date>
  </info>

  <para>
   If you are doing advanced work with Pyrus, it is important to understand how
   to access its internals through its public <link linkend="guide.users.concepts.api">API</link>.
   This guide documents how to perform common tasks such as accessing components
   of a package.xml, managing installation tasks, and accessing configuration
   settings.
  </para>
  <para>
   The section on developing <link linkend="pyrus.plugins">plugins for Pyrus</link>
   is a good starting point for understanding how to extend Pyrus, this guide
   is more specific to using the actual classes contained within Pyrus.
  </para>

  
<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="lillet" xml:id="pyrus.extending.packagefile">
 <info><title>Accessing package.xml properties with Pyrus</title></info>

 <section xml:id="pyrus.extending.packagefile.intro">
  <info><title>Introduction</title></info>
  <para>
   If you are not familiar with the package.xml format, you will need to read
   <link linkend="guide.developers.package2">The description of the file</link>.
  </para>
  <para>
   This guide is divided into several segments.
   <itemizedlist>
    <listitem>
     <para>
      If you want to access basic properties such as the name of the package,
      the channel, summary, description, license, version, stability, date,
      time, or notes, read the section on
      <link linkend="pyrus.extending.packagefile.basic">Accessing basic properties</link>
     </para>
    </listitem>
    <listitem>
     <para>
      To learn about how to manage maintainers of the package, read the section on
      <link linkend="pyrus.extending.packagefile.maintainers">Accessing package maintainers</link>.
     </para>
    </listitem>
    <listitem>
     <para>
      To learn about how to manage and iterate over dependencies, read the section on
      <link linkend="pyrus.extending.packagefile.deps">Accessing dependencies</link>.
     </para>
    </listitem>
    <listitem>
     <para>
      To understand how to iterate over and add files to both the contents
      and release sections of package.xml, read the section on
      <link linkend="pyrus.extending.packagefile.files">Accessing files</link>
     </para>
    </listitem>
    <listitem>
     <para>
      To learn about managing custom tasks, roles, and compatible packages, read the section on
      <link linkend="pyrus.extending.packagefile.custom">usesrole, usestask and compatible</link>.
     </para>
    </listitem>
    <listitem>
     <para>
      To learn about accessing PECL-specific properties such as configureoption,
      srcpackage, srcuri and providesextension, read the section on
      <link linkend="pyrus.extending.packagefile.pecl">Accessing PECL properties</link>
     </para>
    </listitem>
   </itemizedlist>
  </para>
  <para>
   The package.xml file is represented using a <literal>PEAR2\Pyrus\PackageFile\v2</literal>
   object, but most of the time you will access it using the most packagefile
   version-agnostic <literal>PEAR2\Pyrus\Package</literal> class, which supports
   the same API seamlessly for accessing any kind of package as well as a few
   higher level options such as directly accessing the source of a file in a package.
   This documentation assumes you are working with a <literal>PEAR2\Pyrus\Package</literal>
   object named <literal>$package</literal>.
  </para>
  <para>
   To instantiate a <literal>PEAR2\Pyrus\Package</literal>, simply pass in the
   path to a local package, a URI of a remote package, or an abstract remote package
   name to the constructor.
  </para>
  <para>
   <programlisting role="php">
    <![CDATA[
<?php
$package = new PEAR2\Pyrus\Package('package.xml');
$package = new PEAR2\Pyrus\Package('Release-1.2.3.tgz');
$package = new PEAR2\Pyrus\Package('http://example.com/Release-1.2.3.tgz');
$package = new PEAR2\Pyrus\Package('pear2/Release-1.2.3');
?>
    ]]>
   </programlisting>
  </para>
 </section>
 <section xml:id="pyrus.extending.packagefile.basic">
  <info><title>Accessing basic properties</title></info>
  <para>
   Basic properties can be accessed as if they were object properties:
  </para>
  <para>
   <programlisting role="php">
    <![CDATA[
<?php
echo "Package name is ", $package->name, "\n";
echo "Package channel is ", $package->channel, "\n";
echo "Package summary is ", $package->summary, "\n";
echo "Package description is ", $package->description, "\n";
echo "Package license name is ", $package->license['name'], "\n";
if ($package->license['uri']) {
    echo "Package license URI is ", $package->license['uri'], "\n";
}
if ($package->license['filesource']) {
    echo "Package license path within the package.xml is ", $package->license['filesource'], "\n";
}
echo "Package release version is ", $package->version['release'], "\n";
echo "Package API version is ", $package->version['api'], "\n";
echo "Package release stability is ", $package->stability['release'], "\n";
echo "Package API stability is ", $package->stability['api'], "\n";
echo "Package release date in YYYY-MM-DD format is ", $package->date, "\n";
if ($package->time) {
    echo "Package release time in HH:MM:SS format is ", $package->time, "\n";
}
echo "Package release notes is ", $package->notes, "\n";
?>
    ]]>
   </programlisting>
  </para>
  <para>
   By the same token, changing these properties is as simple as setting an object
   property:
  </para>
  <para>
   <programlisting role="php">
    <![CDATA[
<?php
$package->name = 'MyPackage';
// this must be full channel, not a shortcut like "pear2"
$package->channel = 'pear2.php.net';
$package->summary = "My package's short description";
$package->description = "My package's multi-line description
of how things are done with it.";

$package->license = 'BSD License';
// or
$package->license['name'] = 'BSD License';
$package->license['uri'] = 'http://www.opensource.org/licenses/bsd-license.php';
$package->license['filesource'] = 'LICENSE';

$package->version['release'] = '1.2.3';
$package->version['api'] = '1.0.0';

$package->stability['release'] = 'stable';
$package->version['api'] = 'stable';

$package->date = '2009-12-25';
$package->time = '00:00:01';

$package->notes = "This version of MyPackage has the blessing of the pope, so
it's way better than the last one.";
?>
    ]]>
   </programlisting>
  </para>
 </section>
 <section xml:id="pyrus.extending.packagefile.maintainers">
  <info><title>Accessing package maintainers</title></info>
  <para>
   Maintainers are accessed through the <literal>maintainer</literal>
   property.  An of maintainers organized by maintainer role can be obtained via
   the <literal>allmaintainers</literal> property, but it is also possible to
   iterate over the <literal>maintainer</literal> property to iterate over all
   maintainers.
  </para>
  <para>
   The <literal>maintainer</literal> property acts as an array organized by
   developer handle.  To learn more about maintainers in package.xml, see
   the <link linkend="guide.users.concepts.maintainer">concepts section on maintainers</link>
   in the user guide.
  </para>
  <para>
   An individual maintainer's properties are set via a fluent method call.  The
   order of method call is not important, but a call to the <function>role</function>
   method is required in order to properly save the data.
  </para>
  <para>
   <programlisting role="php">
    <![CDATA[
<?php
// setting a maintainer's properties
$package->maintainer['cellog']
    ->role('lead')
    ->name('Gregory Beaver')
    ->email('cellog@php.net')
    ->active('yes');

// access a maintainer's properties
echo "Maintainer cellog's name is ",
     $package->maintainer['cellog']->name, "\n"; // Gregory Beaver
echo "Maintainer cellog's role is ",
     $package->maintainer['cellog']->role, "\n"; // lead
echo "Maintainer cellog's handle is ",
     $package->maintainer['cellog']->user, "\n"; // cellog
echo "Maintainer cellog's email is ",
     $package->maintainer['cellog']->email, "\n"; // cellog@php.net
echo "Is maintainer cellog active? ",
     $package->maintainer['cellog']->active, "\n"; // yes
?>
    ]]>
   </programlisting>
  </para>
  <para>
   The maintainers can be iterated over as well, and even modified:
  </para>
  <para>
   <programlisting role="php">
    <![CDATA[
<?php
foreach ($package->maintainer as $handle => $maintainer) {
    echo "Maintainer $handle's name is ",
         $maintainer->name, "\n";
    echo "Maintainer $handle's role is ",
         $maintainer->role, "\n";
    echo "Maintainer $handle's handle is ",
         $maintainer->user, "\n";
    echo "Maintainer $handle's email is ",
         $maintainer->email, "\n";
    echo "Is maintainer $handle active? ",
         $maintainer->active, "\n";
    $maintainer->active('no'); // shows modifying a setting in iteration
}
?>
    ]]>
   </programlisting>
  </para>
  <para>
   The <literal>allmaintainers</literal> property returns an associative
   array of arrays of maintainer objects indexed by maintainer role.
  </para>
 </section>
 <section xml:id="pyrus.extending.packagefile.deps">
  <info><title>Accessing dependencies</title></info>
  <para>
   Before it is possible to understand how Pyrus provides access to dependencies,
   it is necessary to understand their format in package.xml, which is
   documented <link linkend="guide.developers.package2.dependencies">here</link>.
  </para>
  <para>
   Pyrus provides access to dependencies through the <literal>dependencies</literal>
   property.  In addition to supporting access to and creation of individual
   dependencies, it is possible to iterate over all dependencies, or over just
   required dependencies, or just a particular dependency type.
  </para>
  <para>
   Each of the dependency types (<literal>package</literal>, <literal>subpackage</literal>,
   <literal>pearinstaller</literal>, <literal>extension</literal>, <literal>php</literal>,
   <literal>arch</literal>, and <literal>os</literal>) is accessed slightly
   differently based on how they are used in package.xml.
  </para>
  <para>
   Perhaps the best introduction is 3 examples highlighting the different
   methods of accessing dependency properties.  First, an example highlighting
   the methods for reading existing dependency properties:
  </para>
  <para>
   <programlisting role="php">
    <![CDATA[
<?php
echo "First, required/optional dependencies:\n";

// these same principles apply to all properties for dependencies.
// isset() is used to test presence, ->get to retrieve.

echo "Minimum PHP version supported: ",
     $package->dependencies['required']->php->min, "\n";

echo "Minimum PEAR Installer/Pyrus version required: ",
     $package->dependencies['required']->pearinstaller->min, "\n";
if (isset($package->dependencies['required']->pearinstaller->max)) {
    echo "Maximum PEAR Installer/Pyrus version supported: ",
         $package->dependencies['required']->pearinstaller->max, "\n";
}

echo "PHP extension ext is required? "
     isset($package->dependencies['required']->extension['ext'])
         ? "Yes\n" : "No\n";

if (isset($package->dependencies['required']->os['windows'])) {
    echo "Conflicts with Windows operating system? "
         $package->dependencies['required']->os['windows']->conflicts
             ? "Yes\n" : "No\n";
}

if (isset($package->dependencies['required']->arch['*386*'])) {
    echo "Requires i386 processor? "
         $package->dependencies['required']->arch['*386*']->conflicts
             ? "No\n" : "Yes\n";
}

echo "Now for package and subpackage dependencies:\n";

echo "Is package foo from channel gronk.example.com required? ",
     isset($package->dependencies['required']->package['gronk.example.com/foo'])
         ? "Yes\n" : "No\n";

echo "Does this package conflict with our package? ",
     $package->dependencies['required']->package['gronk.example.com/foo']->conflicts
         ? "Yes\n" : "No\n";

echo "gronk.example.com/foo2 minimum version required is ",
     $package->dependencies['required']->subpackage['gronk.example.com/foo2']->min, "\n";

echo "gronk.example.com/foo2 incompatible versions:";
foreach ($package->dependencies['required']->subpackage['gronk.example.com/foo2']->exclude
         as $version) {
    echo "\n ", $version;
}

echo "\n";

echo "Optional dependencies are accessed the same way with optional index\n";

echo "Optional dependency gronk.example.com/foo3 minimum version allowed is ",
     $package->dependencies['optional']->subpackage['gronk.example.com/foo3']->min, "\n";

echo "Dependency groups are accessed with the group index\n";

echo "Dependency group foo hint is ",
     $package->dependencies['group']->foo->hint, "\n";

echo "channel pear2.php.net package Foo package dependency in dependency group",
     " foo minimum version is ",
     $package->dependecies['group']->foo->package['pear2.php.net/Foo']->min, "\n";

// and so on...
?>
    ]]>
   </programlisting>
  </para>
  <para>
   Iteration is similar to the access, in that each dependency object is the
   same object as that when accessed using the full access syntax:
  </para>
  <para>
   <programlisting role="php">
    <![CDATA[
<?php
// display all required and optional package and subpackage dependencies
foreach (array('required', 'optional') as $required) {
    foreach (array('package', 'subpackage') as $packagedep) {
        foreach ($package->dependencies[$required]->$packagedep as $dep) {
            echo $required, ' ', $packagedep, ' ', dependency,
                 $dep->channel, '/', $dep->name;
            if (isset($dep->uri)) {
                // the channel is "__uri" for all URI dependencies
                echo "\nPackage URI: ", $dep->uri;
            }
            if (isset($dep->min)) {
                echo "\nMinimum version: ", $dep->min;
            }
            if (isset($dep->recommended)) {
                echo "\nRecommended installation version: ", $dep->recommended;
            }
            echo "\n";
        }
    }
}

// iterating over dependency groups and their contents
foreach ($package->dependencies['group'] as $group) {
    echo "Optional dependency group ", $group->name,
         " (", $group->hint, ")\n";
    foreach ($group->extension as $ext) {
        echo "Extension ", $ext->name;
    }
    foreach (array('package', 'subpackage') as $type) {
        foreach ($group->$type as $dep) {
            echo ucfirst($type), ' ', $dep->channel, '/', $dep->name;
        }
    }
}
?>
    ]]>
   </programlisting>
  </para>
  <para>
   Finally, setting dependencies can be accomplished in several ways.
  </para>
  <para>
   <programlisting role="php">
    <![CDATA[
<?php
// setting minimum PHP version required:
$package->dependencies['required']->php = '5.3.0';
$package->dependencies['required']->php->min = '5.3.0';
$package->dependencies['required']->php->min('5.3.0');

// setting minimum PEAR Installer/Pyrus version required:
$package->dependencies['required']->pearinstaller = '2.0.0a1';
$package->dependencies['required']->pearinstaller->min = '2.0.0a1';
$package->dependencies['required']->pearinstaller->min('2.0.0a1');

// setting excluded versions (all deps supporting the <exclude> tag use this syntax):
$package->dependencies['required']->php->exclude = '5.2.0';
$package->dependencies['required']->php->exclude('5.2.0')->exclude('5.2.10');
$package->dependencies['required']->php->exclude('5.2.0', '5.2.10');

// setting OS/architecture requirements:
$package->dependencies['required']->os['windows'] = true;  // Windows required
$package->dependencies['required']->arch['386'] = false; // Conflicts with 386 architecture

// saying "this package must be installed" to the installer
$package->dependencies['required']->package['pear2.php.net/Packagename']->save();

// saying "this package must not be installed"
$package->dependencies['required']->package['pear2.php.net/Packagename']->conflicts();

// setting up complex versioning requirements
$package->dependencies['optional']->package['pear2.php.net/Packagename']
    ->min('1.2.0')
    ->max('1.3.0')
    ->recommended('1.2.3')
    ->exclude('1.3.0', '1.2.2');

// depending on a PECL package
$package->dependencies['required']->package['pecl.php.net/lua']
    ->providesextension('lua');

// optionally depending on a core PHP extension
$package->dependencies['optional']->extension['PDO']->save();

// setting up a dependency group "remotefeatures"
$package->dependencies['group']->remotefeatures->hint('Remote management capabilities');
// add dependencies to the group
$package->dependencies['group']->remotefeatures
    ->package['pear2.php.net/Foo']->save();
$package->dependencies['group']->remotefeatures
    ->extension['curl']->save();
?>
    ]]>
   </programlisting>
  </para>
 </section>
 <section xml:id="pyrus.extending.packagefile.files">
  <info><title>Accessing files</title></info>
  <para>
   There are two reasons to access the files within a package.xml
   <orderedlist>
    <listitem>
     <para>
      <link linkend="pyrus.extending.packagefile.files.iterate">iterating over contents</link>
     </para>
    </listitem>
    <listitem>
     <para>
      <link linkend="pyrus.extending.packagefile.files.setting">adding new files/setting properties</link>
     </para>
    </listitem>
   </orderedlist>
  </para>
  <section xml:id="pyrus.extending.packagefile.files.iterate">
   <info><title>Iterating over package.xml contents</title></info>
   <para>
    Pyrus supports several use cases for iterating over package.xml:
    <itemizedlist>
     <listitem><simpara>Iterating for installation purposes</simpara></listitem>
     <listitem><simpara>Iterating for packaging purposes</simpara></listitem>
     <listitem><simpara>Iterating for traversing a deep package.xml tree</simpara></listitem>
     <listitem><simpara>General-purpose iteration</simpara></listitem>
    </itemizedlist>
    All of these use cases are illustrated in the following example:
   </para>
   <para>
    <programlisting role="php">
     <![CDATA[
<?php
// *************** installation iteration ***************
foreach ($package->installcontents as $file) {
    // retrieve actual file path to be used with fopen
    $path = $package->getFilePath($file->packagedname);
    // retrieve open file pointer
    $fp = $package->getFileContents($file->packagedname, true);
    // retrieve file contents as string
    $contents = $package->getFileContents($file->packagedname);

    // get file properties (XML attributes of the <file> tag)
    $role = $file->role;
    if ($file->md5sum) {
        $md5sum = $file->md5sum;
    }
    // get relative path of file after applying all modifications such
    // as <install name="" as=""/>
    $relativepath = $file->name;
    // get the path as specified in the <contents> <file> tag
    // This is the same as $file->name if no <install as> tags exist
    $originalpath = $file->packagedname;

    // get the tasks associated with this file
    $tasks = file->tasks;
    // iterate over the tasks
    $lastversion = '1.0.0'; // last version of $package that was installed, or null
    foreach (new \PEAR2\Pyrus\Package\Creator\TaskIterator($tasks, $package,
                                                          \PEAR2\Pyrus\Task\Common::INSTALL, $lastversion)
              as $name => $task) {
        // $name is the task name, $task is the actual task object, which can be
        // processed with $task->startSession(resource $fp, '/full/final/install/path');
    }
}

// *************** packaging iteration ***************
$packagingloc = '/tmp/example';
foreach ($package->packagingcontents as $packageat => $info) {
    // $packageat is the location in which the file will reside in package.xml,
    // which is often the same relative path it will end up being installed into
    // $info is an array representing the actual file XML
    $name = $info['attribs']['name'];
    // this retrieves an open file pointer to the file in order to process it
    $contents = $package->getFileContents($info['attribs']['name'], true);
    if (!file_exists(dirname($packagingloc . DIRECTORY_SEPARATOR . $packageat))) {
        mkdir(dirname($packagingloc . DIRECTORY_SEPARATOR . $packageat), 0777, true);
    }
    $fp = fopen($packagingloc . DIRECTORY_SEPARATOR . $packageat, 'wb+');
    ftruncate($fp, 0);
    // copy from the source directory to the packaging location
    stream_copy_to_stream($contents, $fp);
    fclose($contents);
    rewind($fp);
    $lastversion = '1.0.0'; // last version of $package that was installed, or null
    foreach (new \PEAR2\Pyrus\Package\Creator\TaskIterator($info, $package,
                                                          \PEAR2\Pyrus\Task\Common::PACKAGE,
                                                          $lastversion) as $task) {
        // do pre-processing of file contents
        try {
            $task->startSession($fp, $packageat);
        } catch (\Exception $e) {
            // handle task processing problems here
        }
    }
    fclose($fp);
}

// *************** traversing deep tree iteration ***************
foreach ($package->contents as $file) {
    // retrieve actual file path to be used with fopen
    $path = $package->getFilePath($file->name);
    // retrieve open file pointer
    $fp = $package->getFileContents($file->name, true);
    // retrieve file contents as string
    $contents = $package->getFileContents($file->name);

    // get file properties (XML attributes of the <file> tag)
    $role = $file->role;
    if ($file->md5sum) {
        $md5sum = $file->md5sum;
    }

    // unlike installcontents, <install as> tags are not applied, so
    // $file->name == $file->packagedname
    $relativepath = $file->name;
}

// *************** general purpose iteration ***************
foreach ($package->files as $relativepath => $infoarray) {
    // $relativepath is the same as $file->name in the other examples
    // $infoarray is the same array returned by the packagingcontents
    // iterator
}

// *************** retrieving post-install scripts ***************
foreach ($package->scriptfiles as $file) {
    // $file is the same object returned by the installcontents iterator
}
?>
     ]]>
    </programlisting>
   </para>
  </section>
  <section xml:id="pyrus.extending.packagefile.files.setting">
   <info><title>Adding new files, changing file properties</title></info>
   <para>
    Finally, adding files to package.xml is done by directly setting an
    index in the <literal>files</literal> property.  Properties are
    manipulated with the <function>setFileAttribute</function> method.
   </para>
   <para>
    <programlisting role="php">
     <![CDATA[
<?php
$package->files['path/to/file.php'] = array(
    'role' => 'php'
);
$package->setFileAttribute('path/to/file.php', 'md5sum', md5('hi'));

// adding a task to a file
$replace = $package->getTask('path/to/file.php', 'replace');
$replace->setReplacement('package-info', '@API-VER@', 'api-version');
$package->setFileAttribute('path/to/file.php', 'tasks:replace', $replace);
?>
     ]]>
    </programlisting>
   </para>
  </section>
  <section xml:id="pyrus.extending.packagefile.files.release">
   <info><title>Working with &lt;release&gt; sections</title></info>
   <para>
    Releases are documented <link linkend="guide.developers.package2.release">here</link>,
    you should familiarize yourself with this before continuing.
   </para>
   <para>
    Release properties can be accessed with the following syntax:
   </para>
   <para>
    <programlisting role="php">
     <![CDATA[
<?php
// setting release type
$package->type = 'php';
$package->type = 'extsrc';
$package->type = 'zendextsrc';
$package->type = 'bin';
$package->type = 'zendextbin';
$package->type = 'bundle';

// for types other than bundle
$package->release[0]->installconditions['php']->min('5.2.0');
// defaults to "min"
$package->release[0]->installconditions['php'] = '5.2.0';

// defaults to "pattern"
$package->release[0]->installconditions['arch'] = 'i386';
$package->release[0]->installconditions['arch']->pattern('i386')->conflicts();

// defaults to "name"
$package->release[0]->installconditions['os'] = 'windows';

// defaults to existing
$package->release[0]->installconditions['extension'][0]->name('PDO');
$package->release[0]->installconditions['extension'][0]->name('PDO')->min('1.0');
$package->release[0]->ignore('path/to/file.ext');
$package->release[0]->installAs('path/to/anotherfile.ext', 'new/name.php');

// add another release
$i = count($package->release);
$package->release[$i]->ignore('path/to/anotherfile.ext');
$package->release[$i]->installAs('path/to/file.ext', 'new/name.php');

// remove release
unset($package->release[1]);

// remove all releases
$package->release = null;

// retrieve the release that will be used on this system
$release = $package->installrelease;
?>
     ]]>
    </programlisting>
   </para>
  </section>
 </section>
 <section xml:id="pyrus.extending.packagefile.pecl">
  <info><title>Accessing PECL properties</title></info>
  <para>
   Accessing PECL properties is relatively simple, here is an example
   illustrating them:
  </para>
  <para>
   <programlisting role="php">
    <![CDATA[
<?php
$package->type = 'extsrc'; // extension source release
$package->configureoption['foothing']->prompt = 'Value for thing';
$package->configureoption['with-zlib']->prompt('Support zlib compression?')->default('yes');

$package->providesextension = 'foo';

$package->type = 'extbin'; // extension binary package release
$package->srcpackage = 'pecl.php.net/foo';
// for packages that are binary releases of URI-based packages
$package->srcuri = 'http://example.com/foo-1.2.3';
?>
    ]]>
   </programlisting>
  </para>
 </section>
 <section xml:id="pyrus.extending.packagefile.custom">
  <info><title>Accessing usesrole, usestask and compatible tags</title></info>
  <para>
   When declaring that a package.xml uses a custom role or task, this code should
   be used:
  </para>
  <para>
   <programlisting role="php">
    <![CDATA[
<?php
$package->files['example/file.php'] = array(
    'role' => 'myrole',
    'tasks:mytask' => '',
);

$package->usesrole['myrole']->package('MyRole')->channel('mypear.example.com');
$package->usestask['mytask']->package('MyTask')->channel('mypear.example.com');

// for uri-based packages:
$package->usesrole['myrole']->uri('http://my.example.com/MyRole-1.2.3');
?>
    ]]>
   </programlisting>
  </para>
  <para>
   If you are unfamiliar with the <literal>&lt;compatible&gt;</literal> tag,
   you should first read the documentation on its use
   <link linkend="guide.developers.package2.compatible">here</link>.  Creating
   and accessing compatible tags in Pyrus is as easy as:
  </para>
  <para>
   <programlisting role="php">
    <![CDATA[
<?php
$package->compatible['pear.php.net/Archive_Tar']
        ->min('1.2')
        ->max('1.3.0')
        ->exclude('1.2.1', '1.2.2');

// remove a compatibility declaration
unset($package->compatible['pear.php.net/Archive_Tar']);

// test for existence of compatible declaration
isset($package->compatible['pear.php.net/Archive_Tar']);

// display info:
echo $package->compatible['pear.php.net/Archive_Tar']->min;

// iterating over compatible packages
foreach ($package->compatible as $package => $info) {
    echo "Package :", $package, "\n";
    echo "min: ", $info->min, "\n";
    echo "max: ", $info->max, "\n";
    if (isset($info->exclude)) {
        echo "Excludes versions ",
        foreach ($info->exclude as $version) {
            echo ' ', $version, "\n";
        }
    }
}
?>
    ]]>
   </programlisting>
  </para>
 </section>
</section>

  
<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="lillet" xml:id="pyrus.extending.configuration">
 <info><title>Pyrus's configuration API</title></info>

 <section xml:id="pyrus.extending.configuration.intro">
  <info><title>Introduction</title></info>
  <para>
   This documentation describes how to use Pyrus's public class API to access
   configuration values.  Before reading further, you should be familiar
   with the documentation on Pyrus's <link linkend="pyrus.configuration">configuration</link>.
  </para>
  <para>
   Pyrus's configuration is controlled by the <literal>PEAR2\Pyrus\Config</literal>
   class, which is implemented as a multiton mapping Pyrus installation location
   to a configuration object.  In addition, the current configuration (most
   recently instantiated) is also accessible to create configuration-agnostic
   functionality.
  </para>
  <para>
   Configuration variables are accessed by referring to them as class
   properties.  Here is an example requesting the <literal>doc_dir</literal>
   configuration variable, and setting the <literal>test_dir</literal>
   configuration variable:
  </para>
  <para>
   <programlisting role="php">
    <![CDATA[
<?php
$docdir = PEAR2\Pyrus\Config::current()->doc_dir;
PEAR2\Pyrus\Config::current()->test_dir = '/path/to/tests';
?>
    ]]>
   </programlisting>
  </para>
  <para>
   The user configuration in use is also accessible from each configuration
   in the same manner as the installation-specific configuration.  Here is
   an example requesting <literal>preferred_state</literal> and setting
   <literal>verbose</literal>:
  </para>
  <para>
   <programlisting role="php">
    <![CDATA[
<?php
$pref = PEAR2\Pyrus\Config::current()->preferred_state;
PEAR2\Pyrus\Config::current()->verbose = 3;
?>
    ]]>
   </programlisting>
  </para>
 </section>
 <section xml:id="pyrus.extending.configuration.special">
  <title>Special variables available</title>
  <para>
   In addition to the configuration variables, Pyrus also defines a few
   other values that are available, and cannot be used as the names
   of custom configuration variables:
   <itemizedlist>
    <listitem>
     <para>
      <literal>path</literal> - the complete <constant>PATH_SEPARATOR</constant>
      separated list of cascading directories this configuration represents.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>location</literal> - the writable pyrus installation this configuration
      represents
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>registry</literal> - the registry corresponding to the configuration
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>pluginregistry</literal> - the registry corresponding to the
      location that <link linkend="pyrus.plugins">plugins</link> are installed
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>channelregistry</literal> - the channel registry corresponding to
      the configuration
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>systemvars</literal> - an array of names of system configuration
      variables, built-in and custom
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>uservars</literal> - an array of names of user configuration
      variables, built-in and custom
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>channelvars</literal> - an array of channel-specific configuration
      variables, built-in and custom
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>mainsystemvars</literal> - an array of names of built-in
      system variables
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>mainuservars</literal> - an array of names of built-in user
      variables
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>mainchannelvars</literal> - an array of names of built-in
      channel-specific variables
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>userfile</literal> - path to the user configuration file in use
      by this configuration.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>customsystemvars</literal> - an array of names of custom
      system variables
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>customuservars</literal> - an array of names of custom user
      variables
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>customchannelvars</literal> - an array of names of custom
      channel-specific variables
     </para>
    </listitem>
   </itemizedlist>
  </para>
 </section>
</section>

  
<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="lillet" xml:id="pyrus.extending.installation">
 <info><title>Leveraging Pyrus's installation API</title></info>

 <section xml:id="pyrus.extending.installation.intro">
  <info><title>Introduction</title></info>
  <para>
   Pyrus provides a very simple API for performing installation tasks.  This
   API begins with the ability to pass any packagename that can be
   specified on the command-line to a <literal>PEAR2\Pyrus\Package</literal>
   object:
  </para>
  <para>
   <programlisting role="php">
    <![CDATA[
<?php
// examples of the range of valid package names
$package = new \PEAR2\Pyrus\Package('package.xml');
$package = new \PEAR2\Pyrus\Package('/full/path/to/package.xml');
$package = new \PEAR2\Pyrus\Package('Package-1.2.3.tgz');
$package = new \PEAR2\Pyrus\Package('/full/path/to/Package-1.2.3.zip');
$package = new \PEAR2\Pyrus\Package('RemotePackage');
$package = new \PEAR2\Pyrus\Package('RemotePackage-alpha');
$package = new \PEAR2\Pyrus\Package('RemotePackage-1.2.3');
$package = new \PEAR2\Pyrus\Package('channelname/RemotePackage');
$package = new \PEAR2\Pyrus\Package('http://example.com/RemotePackage-1.2.3.phar');
?>
    ]]>
   </programlisting>
  </para>
  <para>
   If there is a problem with the package name as passed to the constructor,
   an exception is thrown.  This can be any of a wide variety of exceptions
   ranging from a <literal>PEAR2\Pyrus\PackageFile\Exception</literal> for
   invalid package.xml, a <literal>PEAR2\Pyrus\Package\Exception</literal> for
   higher-level errors (file does not exist, invalid abstract package name),
   a <literal>PEAR2\Pyrus\Package\InstalledException</literal> if an abstract
   remote package was requested and a newer version is installed, and
   a <literal>PEAR2\Pyrus\Channel\Exception</literal> if any problems with
   retrieving remote REST information occur.  Also possible are
   <literal>PEAR2\Pyrus\Package\Phar\Exception</literal> for errors relating
   to local <literal>tar</literal>, <literal>tgz</literal>, <literal>zip</literal>
   or <literal>phar</literal> archives.
  </para>
 </section>
 <section xml:id="pyrus.extending.installation.install">
  <info><title>Installing and Uninstalling packages</title></info>
  <para>
   Once you have a valid package object, installation is very simple.  Pyrus
   conducts all installation activities within a transaction, meaning that all
   changes are applied nearly simultaneously, and any failure mid-transaction
   does not leave an invalid installation lying around.
  </para>
  <para>
   <programlisting role="php">
    <![CDATA[
<?php
// import the class names into the current scope
// this step is optional, you can also use the full class names
// like PEAR2\Pyrus\Installer::begin()
use PEAR2\Pyrus\Installer as Installer,
    PEAR2\Pyrus\Package as Package;

try {
    $p1 = new Package('package.xml');
    $p2 = new Package('Package.tgz');
    $p3 = new Package('pear2/RemotePackage');

    // here is the meat of the installation transaction
    Installer::begin();

    Installer::prepare($p1);
    Installer::prepare($p2);
    Installer::prepare($p3);

    Installer::commit();
} catch (\Exception $e) {
    echo "Install failed\n";
}
?>
    ]]>
   </programlisting>
  </para>
  <para>
   Uninstalling a package is even simpler:
  </para>
  <para>
   <programlisting role="php">
    <![CDATA[
<?php
// import the class names into the current scope
// this step is optional, you can also use the full class names
// like PEAR2\Pyrus\Uninstaller::begin()
use PEAR2\Pyrus\Uninstaller as Uninstaller;

try {
    $p1 = new Package('package.xml');
    $p2 = new Package('Package.tgz');
    $p3 = new Package('pear2/RemotePackage');

    // here is the meat of the installation transaction
    Uninstaller::begin();

    Uninstaller::prepare('pear2.php.net/Package1');
    Uninstaller::prepare('pear.php.net/Package');
    Uninstaller::prepare('__uri/Package');

    Uninstaller::commit();
} catch (\Exception $e) {
    echo "Uninstall failed\n";
}
?>
    ]]>
   </programlisting>
  </para>
 </section>
</section>

  
<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="lillet" xml:id="pyrus.extending.registry">
 <info><title>Working with installed packages and channels: The Registry API</title></info>

 <section xml:id="pyrus.extending.registry.intro">
  <info><title>Introduction</title></info>
  <para>
   Pyrus provides a very simple API for accessing its registry.  Pyrus stores
   meta-information on installed packages in redundant registries.  There are
   three kinds of registries that Pyrus recognizes, <literal>Sqlite3</literal>,
   <literal>Xml</literal> and the legacy <literal>Pear1</literal> registry.  A
   pyrus-based installation can have up to all three kinds of registries
   redundantly storing the installed packages and the known channels.  By default
   the <literal>Sqlite3</literal> registry is the primary registry used for
   querying information, with the <literal>Xml</literal> registry as a backup.
  </para>
  <para>
   When Pyrus is used to manage an installation, it checks to see which
   registries are already present, if any, and will use the existing registries.
   This fact can be used to provide more flexible installation options.  For
   instance, Pyrus can be used to manage an existing legacy PEAR installation
   without any special configuration, it will simply detect that the legacy
   registry is present and use it.  If a package is extracted into a bundled
   location, Pyrus will detect its extracted package.xml as belonging to the
   Xml registry, and will use only that registry for installation purposes,
   which allows upgrading the extracted package and avoids placing any
   absolute paths into the installation.
  </para>
  <para>
   Pyrus provides full atomic installation transactions for all of its
   registry types, including the legacy Pear1 registry, unlike the PEAR
   installer.  In addition, each registry provides a single method which
   can be used to remove it from disk, and there is also a single method which
   can be used for converting from one registry type to another.  Another method
   is available for repairing a corrupted registry from one of its redundant
   registries.
  </para>
  <para>
   Pyrus provides a separate logical registry for storing channels from the registry
   that stores packages.  Each registry handles this slightly differently.  The
   Sqlite3 registry, for instance, stores all information in a single database.
   The Xml registry stores information in separate files, like the legacy Pear1
   registry.
  </para>
 </section>
 <section xml:id="pyrus.extending.registry.basic">
  <info><title>Basic Registry principles</title></info>
  <para>
   All registry classes implement the <literal>PEAR2\Pyrus\IChannel</literal>
   interface, and all channelregistry classes implement the
   <literal>PEAR2\Pyrus\ChannelRegistry</literal> interface.  The
   <literal>PEAR2\Pyrus\Registry</literal> class acts as an aggregator of
   underlying registries, and implements the ability to cascade to parent
   registries, as does the <literal>PEAR2\Pyrus\ChannelRegistry</literal>
   class.
  </para>
  <para>
   The simplest way to retrieve a registry object is to use the one strongly
   tied to the <link linkend="pyrus.extending.configuration">PEAR2\Pyrus\Config</link>
   object:
  </para>
  <programlisting role="php">
   <![CDATA[
<?php
$reg = PEAR2\Pyrus\Config::current()->registry;
$creg = PEAR2\Pyrus\Config::current()->channelregistry;
?>
   ]]>
  </programlisting>
  <para>
   Accessing a specific installed package retrieves an object that is
   API-identical to a <link linkend="pyrus.extending.packagefile">PackageFile</link>
   object.  The registry is implemented logically as an associative array.
   By requesting a package's logical name, which is <literal>channel/packagename</literal>,
   we get an object that can be manipulated just as if it were the package prior
   to installation
  </para>
  <programlisting role="php">
   <![CDATA[
<?php
$package = PEAR2\Pyrus\Config::current()->registry->package['pear2.php.net/PEAR2_Pyrus_Developer'];
$remotepackage = new PEAR2\Pyrus\Package('pear2.php.net/PEAR2_Pyrus_Developer');
// both packages can be queried with the same API
?>
   ]]>
  </programlisting>
  <para>
   The same principle applies to channels:
  </para>
  <programlisting role="php">
   <![CDATA[
<?php
$channel = PEAR2\Pyrus\Config::current()->channelregistry['pear2.php.net'];
$localchannel = new PEAR2\Pyrus\ChannelFile('channel.xml');
// both channels can be queried with the same API
?>
   ]]>
  </programlisting>
  <para>
   Iteration also works with both just as it would for an array:
  </para>
  <programlisting role="php">
   <![CDATA[
<?php
foreach (PEAR2\Pyrus\Config::current()->registry->package as $name => $package) {
    // $name is channel/package
    // $package is a packagefile object
}
foreach (PEAR2\Pyrus\Config::current()->channelregistry as $name => $channel) {
    // $name is the channel name
    // $channel is a channelfile object
}
?>
   ]]>
  </programlisting>
 </section>
 <section xml:id="pyrus.extending.registry.installation">
  <info><title>Installation-related API tasks</title></info>
  <para>
   There are 4 installation-related methods, as well as 3 transaction methods.
   These methods are:
   <itemizedlist>
    <listitem>
     <simpara>
      <function>install</function> and <function>replace</function>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <function>uninstall</function>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <function>exists</function>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <function>begin</function>, <function>commit</function> and
      <function>rollback</function>.
     </simpara>
    </listitem>
   </itemizedlist>
   The <function>install</function> method registers a package as installed,
   and sets its date/time to the current time so that the installation time
   can be tracked.  The <function>replace</function> method registers a package
   as installed, but does not modify its date/time.  This is useful for
   repairing a corrupted entry, or simply storing a package as it is.  Both
   methods accept a <literal>PEAR2\Pyrus\IPackageFile</literal> object.  A
   packagefile object can be retrieved from a <literal>PEAR2\Pyrus\Package</literal>
   object by calling its <function>getPackageFileObject</function> method.
   A <literal>PEAR2\Pyrus\Registry\Exception</literal> is thrown on any errors.
  </para>
  <para>
   The <function>uninstall</function> method accepts two parameters, the
   name of the package, and the package's channel.  A
   <literal>PEAR2\Pyrus\Registry\Exception</literal> is thrown on any errors.
  </para>
  <para>
   The <function>exists</function> method also accepts two parameters, and
   returns <constant xmlns="http://docbook.org/ns/docbook">TRUE</constant> or <constant xmlns="http://docbook.org/ns/docbook">FALSE</constant> depending on whether the package exists.  If
   severe errors occur such as registry corruption, a
   <literal>PEAR2\Pyrus\Registry\Exception</literal> object is thrown.
  </para>
  <para>
   Note that array access can also be used to handle installation-related tasks:
  </para>
  <programlisting role="php">
   <![CDATA[
<?php
$reg = PEAR2\Pyrus\Config::current()->registry;

$package = new PEAR2\Pyrus\Package('/path/to/package.xml');

// equivalent to $reg->install($package)
$reg->package[] = $package;

// equivalent to $reg->uninstall('Foo', 'pear2.php.net')
unset($reg->package['pear2.php.net/Foo']);

// equivalent to $reg->exists('Foo', 'pear2.php.net');
isset($reg->package['pear2.php.net/Foo']);
?>
   ]]>
  </programlisting>
  <para>
   When performing any installation or uninstallation task, it is recommended
   to use the registry's built-in transaction support.  The
   <literal>Sqlite3</literal> registry uses the database's native transaction
   support.  Both the <literal>Xml</literal> and <literal>Pear1</literal>
   registries use Pyrus's <literal>PEAR2\Pyrus\AtomicFileTransaction</literal>
   for its transaction support.  Thus, it is always best to do a transaction
   by first enabling the registry transaction, and then the atomic file transaction
   within this registry transaction:
  </para>
  <programlisting role="php">
   <![CDATA[
<?php
$reg = PEAR2\Pyrus\Config::current()->registry;
$package = new PEAR2\Pyrus\Package('Whatever');
try {
    $reg->begin();
    PEAR2\Pyrus\AtomicFileTransaction::begin();
    $reg->install($package);
    PEAR2\Pyrus\AtomicFileTransaction::commit();
    $reg->commit();
} catch (Exception $e) {
    $reg->rollback();
    PEAR2\Pyrus\AtomicFileTransaction::rollback();
    throw $e;
}
?>
   ]]>
  </programlisting>
  <para>
   If using the <link linkend="pyrus.extending.installation">Installer API</link>,
   the transactions and installation to registry is all automatic, this code is
   only needed for customizing installation.
  </para>
 </section>
 <section xml:id="pyrus.extending.registry.querying">
  <info><title>Specialized querying of the registry</title></info>
  <para>
   Other methods for querying the registry include:
   <itemizedlist>
    <listitem>
     <simpara>
      <function>info</function>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <function>listPackages</function>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <function>getDependentPackages</function>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <function>detectFileConflicts</function>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <function>detectRegistries</function>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <function>removeRegistry</function>
     </simpara>
    </listitem>
   </itemizedlist>
  </para>
  <section xml:id="pyrus.extending.registry.querying.info">
   <title><function>info</function></title>
   <para>
    The <function>info</function> method provides a way of peeking at
    a single attribute of a package.  When used with the <literal>Sqlite3</literal>
    registry, it is extremely efficient both in terms of memory use and speed.
    Both the <literal>Xml</literal> and <literal>Pear1</literal> registries are
    far slower because they must load the complete packagefile into memory for
    every query.  For these registries, it is better to simply retrieve a
    packagefile and query it using the
    <link linkend="pyrus.extending.packagefile">PackageFile API</link>.
   </para>
   <para>
    Parameters to <function>info</function> are the package name, package channel,
    and the field name to retrieve.
   </para>
   <para>
    All of the
    <link linkend="pyrus.extending.packagefile.basic">Basic package.xml properties</link>
    can be directly accessed using <function>info</function>.  In addition, two
    special properties, <literal>installedfiles</literal> and <literal>dirtree</literal>
    are available.
   </para>
   <para>
    <literal>installedfiles</literal> returns a list of files and their properties
    as they have been installed.  Here is a sample return value:
   </para>
   <programlisting role="php">
    <![CDATA[
<?php
array(
      '/full/path/todocs/PEAR2_SimpleChannelServer/pear2.php.net/examples/update_channel.php' =>
      array(
        'role' => 'doc',
        'name' => 'examples/update_channel.php',
        'installed_as' => '/full/path/to/docs/PEAR2_SimpleChannelServer/pear2.php.net/examples/update_channel.php',
        'relativepath' => 'PEAR2_SimpleChannelServer/pear2.php.net/examples/update_channel.php',
        'configpath' => '/full/path/to/docs',
           ),
      // ... and so on
     );
?>
    ]]>
   </programlisting>
   <para>
    <literal>dirtree</literal> returns a list of every directory that would have
    been created if installing the package in a new installation.  This can
    be used to prune empty directories after uninstalling.  Here is a sample
    return value:
   </para>
   <programlisting role="php">
    <![CDATA[
<?php
array (
      '/full/path/to/php/PEAR2/SimpleChannelServer/REST',
      '/full/path/to/php/PEAR2/SimpleChannelServer/Categories',
      '/full/path/to/php/PEAR2/SimpleChannelServer',
      '/full/path/to/php/PEAR2',
      '/full/path/to/php',
      '/full/path/to/docs/PEAR2_SimpleChannelServer/pear2.php.net/examples',
      '/full/path/to/docs/PEAR2_SimpleChannelServer/pear2.php.net',
      '/full/path/to/docs/PEAR2_SimpleChannelServer',
      '/full/path/to/docs',
      '/full/path/to/bin',
    );
?>
    ]]>
   </programlisting>
  </section>
  <section xml:id="pyrus.extending.registry.querying.listpackages">
   <title><function>listPackages</function></title>
   <para>
    This method accepts a channel name as an argument, and returns an array
    of the names of installed packages from that channel.
   </para>
  </section>
  <section xml:id="pyrus.extending.registry.querying.getdependentpackages">
   <title><function>getDependentPackages</function></title>
   <para>
    <function>getDependentPackages</function> requires a single argument,
    a <literal>PEAR2\Pyrus\IPackageFile</literal> object.
    This method returns an array of <literal>PEAR2\Pyrus\Package</literal>
    objects representing installed packages that depend upon the package
    passed in.  If the optional second boolean parameter is set to true
    (which it is by default), performance is improved when querying an
    <literal>Sqlite3</literal> database by returning packages containing only
    the name of the package and its dependencies.
   </para>
  </section>
  <section xml:id="pyrus.extending.registry.querying.detectfileconflicts">
   <title><function>detectFileConflicts</function></title>
   <para>
    This method is used to implement file conflict detection to prevent
    overwriting installed files with those from another package.  It accepts a
    single argument, a <literal>PEAR2\Pyrus\IPackageFile</literal> object.
    The <literal>Pear1</literal> registry is the most efficient at this
    operation (at the expense of drastically decreased efficiency at installation or
    uninstallation), the <literal>Sqlite3</literal> is the next most
    efficient, and the <literal>Xml</literal> registry is the least efficient,
    and in fact is so inefficient, this method should only be called
    on an Xml registry that is for a very small installation.
   </para>
  </section>
  <section xml:id="pyrus.extending.registry.querying.detectregistries">
   <title><function>detectRegistries</function></title>
   <para>
    This static method accepts a string containing the path to check for registries,
    and returns an array containing the names of registries
    found.  The possible return values include <literal>Sqlite3</literal>,
    <literal>Xml</literal> and <literal>Pear1</literal>.  Note that only a call
    to <function>PEAR2\Pyrus\Registry::detectRegistries</function> will return
    a list of all registries found.  A call to
    <function>PEAR2\Pyrus\Registry\Sqlite3::detectRegistries</function> will
    only return either <literal>array()</literal> or
    <literal>array('Sqlite3')</literal> depending on whether the registry exists.
   </para>
  </section>
  <section xml:id="pyrus.extending.registry.querying.removeregistry">
   <title><function>removeRegistry</function></title>
   <para>
    This static method accepts a string containing the path to remove a registry
    from.  A call to <function>PEAR2\Pyrus\Registry::removeRegistry</function>
    will completely remove all traces of a PEAR installation.  A call to
    an individual registry's removeRegistry, such as a call to
    <function>PEAR2\Pyrus\Registry\Pear1::removeRegistry</function> will only
    remove that registry from the installation path.
   </para>
  </section>
 </section>
 <section xml:id="pyrus.extending.registry.channelregistry">
  <info><title>Channel registry</title></info>
  <para>
   
  </para>
 </section>
</section>

 </chapter>

 </book>

 <book xml:id="developers">
  <title>PEAR Developer Guide</title>



  <part xml:id="guide-developers">
   <title>PEAR Developer Guide</title>
   
<chapter xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="guide.developers.package2"><info><title>The package definition file <filename>package.xml</filename>, version 2.0</title><titleabbrev><filename>package.xml 2.0</filename></titleabbrev></info>
  
  

  <section xml:id="guide.developers.package2.intro"><info><title>A quick and dirty guide to version 2.0 of the package definition file <filename>package.xml</filename></title><titleabbrev>Introduction</titleabbrev></info>
   
   

   <simpara>
    The package definition file <filename>package.xml</filename> is,
    as the name already implies, a well-formed XML file that contains
    all information about a PEAR package.  Version 2.0 contains several important
    enhancements over version 1.0, including
   </simpara>
   <para>
    <itemizedlist>
     <listitem>
      <para>
       Channel support
      </para>
     </listitem>
     <listitem>
      <para>
       Binary PECL packages support (not fully implemented in PEAR 1.4.0)
      </para>
     </listitem>
     <listitem>
      <para>
       More specific dependency resolution
      </para>
     </listitem>
    </itemizedlist>
   </para>
   <simpara>
    For those of you with an existing package.xml version 1.0, you can create an approximate
    equivalent package using the
   </simpara>
   <para>
    <screen>
     <userinput>
$ pear convert
     </userinput>
    </screen>
   </para>

   <simpara>
    command.  Note that as of version 1.6.0,
    <classname>PEAR_PackageFileManager</classname> supports package.xml
    2.0 with the PEAR_PackageFileManager2 class.
   </simpara>
   <simpara>
    PECL developers: for more information on pecl-specific features,
    <link linkend="guide.developers.package2.pecl">read here</link>.
   </simpara>

   <note>
   <para>
    <filename>package.xml</filename> version 2.0 is supported from PEAR 1.4 on.
    As of 2007-04, PEAR 1.4 or greater is used in more than 99.8% of all
    installations in the wild that downloaded packages - there is no need
    to support v1.0 for backwards compatibility anymore.
   </para>
   </note>

   <section xml:id="guide.developers.package2.example"><info><title>An example file with all elements</title></info>
    

    <para>
     <programlisting role="xml">
&lt;?xml version="1.0"?&gt;
&lt;package version="2.0" xmlns="http://pear.php.net/dtd/package-2.0"
    xmlns:tasks="http://pear.php.net/dtd/tasks-1.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://pear.php.net/dtd/tasks-1.0
http://pear.php.net/dtd/tasks-1.0.xsd
http://pear.php.net/dtd/package-2.0
http://pear.php.net/dtd/package-2.0.xsd"&gt;
 &lt;name&gt;PEAR&lt;/name&gt;
 <link linkend="guide.developers.package2.channel">&lt;channel&gt;</link>pear.php.net&lt;/channel&gt;
 <link linkend="guide.developers.package2.extends">&lt;extends&gt;</link>OldPackage&lt;/extends&gt;
 &lt;summary&gt;Any one-line summary&lt;/summary&gt;
 &lt;description&gt;any static long description.
 This text should not change very much between releases, use the "notes" tag
 for release notes
 &lt;/description&gt;
 <link linkend="guide.developers.package2.developers">&lt;lead&gt;</link>
  &lt;name&gt;Greg Beaver&lt;/name&gt;
  &lt;user&gt;cellog&lt;/user&gt;
  &lt;email&gt;cellog@php.net&lt;/email&gt;
  &lt;active&gt;yes&lt;/active&gt;
 &lt;/lead&gt;
 &lt;date&gt;2005-02-26&lt;/date&gt;
 &lt;time&gt;20:30:13&lt;/time&gt; &lt;-- note: &lt;time&gt; is optional --&gt;
 <link linkend="guide.developers.package2.version">&lt;version&gt;</link>
  &lt;release&gt;1.4.0a2&lt;/release&gt;
  &lt;api&gt;1.4.0&lt;/api&gt;
 &lt;/version&gt;
 <link linkend="guide.developers.package2.stability">&lt;stability&gt;</link>
  &lt;release&gt;alpha&lt;/release&gt;
  &lt;api&gt;alpha&lt;/api&gt;
 &lt;/stability&gt;
 <link linkend="guide.developers.package2.license">&lt;license uri="</link>http://www.php.net/license/"&gt;PHP License&lt;/license&gt;
 &lt;notes&gt;
 Put release notes here.
 They can be multi-line
 &lt;/notes&gt;
 <link linkend="guide.developers.package2.contents">&lt;contents&gt;</link>
  <link linkend="guide.developers.package2.dir">&lt;dir name="/"&gt;</link>
   &lt;dir name="PEAR"&gt;
    &lt;dir name="ChannelFile"&gt;
     <link linkend="guide.developers.package2.file">&lt;file name="Parser.php" role="php" /&gt;</link>
    &lt;/dir&gt; &lt;!-- /PEAR/ChannelFile --&gt;
    &lt;file name="Dependency2.php" role="php"&gt;
     &lt;tasks:replace from="@PEAR-VER@" to="version" type="package-info"/&gt;
    &lt;/file&gt;
   &lt;/dir&gt; &lt;!-- /PEAR --&gt;
   &lt;dir name="scripts" baseinstalldir="/"&gt;
    &lt;file name="pear.bat" role="script"&gt;
     <link linkend="guide.developers.package2.tasks.replace">&lt;tasks:replace from="@bin_dir@" to="bin_dir" type="pear-config" /&gt;</link>
     &lt;tasks:replace from="@php_bin@" to="php_bin" type="pear-config" /&gt;
     &lt;tasks:replace from="@include_path@" to="php_dir" type="pear-config" /&gt;
     <link linkend="guide.developers.package2.tasks.windowseol">&lt;tasks:windowseol/&gt;</link>
    &lt;/file&gt;
    &lt;file name="pecl.bat" role="script"&gt;
     &lt;tasks:replace from="@bin_dir@" to="bin_dir" type="pear-config" /&gt;
     &lt;tasks:replace from="@php_bin@" to="php_bin" type="pear-config" /&gt;
     &lt;tasks:replace from="@include_path@" to="php_dir" type="pear-config" /&gt;
     &lt;tasks:windowseol/&gt;
    &lt;/file&gt;
    &lt;file name="pear.sh" role="script"&gt;
     &lt;tasks:replace from="@php_bin@" to="php_bin" type="pear-config" /&gt;
     &lt;tasks:replace from="@php_dir@" to="php_dir" type="pear-config" /&gt;
     &lt;tasks:replace from="@pear_version@" to="version" type="package-info" /&gt;
     &lt;tasks:replace from="@include_path@" to="php_dir" type="pear-config" /&gt;
     <link linkend="guide.developers.package2.tasks.unixeol">&lt;tasks:unixeol/&gt;</link>
    &lt;/file&gt;
    &lt;file name="pecl.sh" role="script"&gt;
     &lt;tasks:replace from="@php_bin@" to="php_bin" type="pear-config" /&gt;
     &lt;tasks:replace from="@php_dir@" to="php_dir" type="pear-config" /&gt;
     &lt;tasks:replace from="@pear_version@" to="version" type="package-info" /&gt;
     &lt;tasks:replace from="@include_path@" to="php_dir" type="pear-config" /&gt;
     &lt;tasks:unixeol/&gt;
    &lt;/file&gt;
    &lt;file name="pearcmd.php" role="php"&gt;
     &lt;tasks:replace from="@php_bin@" to="php_bin" type="pear-config" /&gt;
     &lt;tasks:replace from="@php_dir@" to="php_dir" type="pear-config" /&gt;
     &lt;tasks:replace from="@pear_version@" to="version" type="package-info" /&gt;
     &lt;tasks:replace from="@include_path@" to="php_dir" type="pear-config" /&gt;
    &lt;/file&gt;
    &lt;file name="peclcmd.php" role="php"&gt;
     &lt;tasks:replace from="@php_bin@" to="php_bin" type="pear-config" /&gt;
     &lt;tasks:replace from="@php_dir@" to="php_dir" type="pear-config" /&gt;
     &lt;tasks:replace from="@pear_version@" to="version" type="package-info" /&gt;
     &lt;tasks:replace from="@include_path@" to="php_dir" type="pear-config" /&gt;
     &lt;tasks:footask/&gt;
    &lt;/file&gt;
   &lt;/dir&gt; &lt;!-- /scripts --&gt;
   &lt;file name="package.dtd" role="data" /&gt;
   &lt;file name="postinstall.php" role="php"&gt;
    <link linkend="guide.developers.package2.tasks.postinstallscript">&lt;tasks:postinstallscript/&gt;</link>
   &lt;/file&gt;
   &lt;file name="template.spec" role="foo" /&gt;
  &lt;/dir&gt; &lt;!-- / --&gt;
 &lt;/contents&gt;
 <link linkend="guide.developers.package2.compatible">&lt;compatible&gt;</link>
  &lt;name&gt;FooPackage&lt;/name&gt;
  &lt;channel&gt;pear.php.net&lt;/channel&gt;
  &lt;min&gt;1.3.0&lt;/min&gt;
  &lt;max&gt;1.5.0&lt;/max&gt;
 &lt;/compatible&gt;
 <link linkend="guide.developers.package2.dependencies">&lt;dependencies&gt;</link>
  &lt;required&gt;
   <link linkend="guide.developers.package2.dependencies.php">&lt;php&gt;</link>
    &lt;min&gt;4.2&lt;/min&gt;
    &lt;max&gt;6.0.0&lt;/max&gt;
   &lt;/php&gt;
   <link linkend="guide.developers.package2.dependencies.pearinstaller">&lt;pearinstaller&gt;</link>
    &lt;min&gt;1.4.0dev13&lt;/min&gt;
   &lt;/pearinstaller&gt;
   <link linkend="guide.developers.package2.dependencies.package.channel">&lt;package&gt;</link>
    &lt;name&gt;Archive_Tar&lt;/name&gt;
    &lt;channel&gt;pear.php.net&lt;/channel&gt;
    &lt;min&gt;1.1&lt;/min&gt;
    &lt;recommended&gt;1.2&lt;/recommended&gt;
   &lt;/package&gt;
   <link linkend="guide.developers.package2.dependencies.package.uri">&lt;package&gt;</link>
    &lt;name&gt;Foo&lt;/name&gt;
    &lt;uri&gt;http://www.example.com/Foo-1.2.0.tgz&lt;/uri&gt;
   &lt;/package&gt;
   <link linkend="guide.developers.package2.dependencies.extension">&lt;extension&gt;</link>
    &lt;name&gt;xml&lt;/name&gt;
   &lt;/extension&gt;
   <link linkend="guide.developers.package2.dependencies.os">&lt;os&gt;</link>
    &lt;name&gt;windows&lt;/name&gt;
    &lt;conflicts/&gt;
   &lt;/os&gt;
   <link linkend="guide.developers.package2.dependencies.arch">&lt;arch&gt;</link>
    &lt;pattern&gt;*-i?86-*-*&lt;/pattern&gt;
   &lt;/arch&gt;
  &lt;/required&gt;
  <link linkend="guide.developers.package2.dependencies.structure">&lt;optional&gt;</link>
   &lt;package&gt;
    &lt;name&gt;PEAR_Frontend_Web&lt;/name&gt;
    &lt;channel&gt;pear.php.net&lt;/channel&gt;
    &lt;min&gt;0.5.0&lt;/min&gt;
   &lt;/package&gt;
   &lt;package&gt;
    &lt;name&gt;PEAR_Frontend_Gtk&lt;/name&gt;
    &lt;channel&gt;pear.php.net&lt;/channel&gt;
    &lt;min&gt;0.4.0&lt;/min&gt;
   &lt;/package&gt;
  &lt;/optional&gt;
  &lt;group name="remoteinstall" hint="adds the ability to install packages to a remote ftp server"&gt;
   &lt;package&gt;
    &lt;name&gt;Net_FTP&lt;/name&gt;
    &lt;channel&gt;pear.php.net&lt;/channel&gt;
    &lt;min&gt;1.3.0RC1&lt;/min&gt;
    &lt;recommended&gt;1.3.0&lt;/recommended&gt;
   &lt;/package&gt;
  &lt;/group&gt;
  &lt;group name="webinstaller" hint="PEAR's web-based installer"&gt;
   &lt;package&gt;
    &lt;name&gt;PEAR_Frontend_Web&lt;/name&gt;
    &lt;channel&gt;pear.php.net&lt;/channel&gt;
    &lt;min&gt;0.5.0&lt;/min&gt;
   &lt;/package&gt;
  &lt;/group&gt;
  &lt;group name="gtkinstaller" hint="PEAR's PHP-GTK-based installer"&gt;
   &lt;package&gt;
    &lt;name&gt;PEAR_Frontend_Gtk&lt;/name&gt;
    &lt;channel&gt;pear.php.net&lt;/channel&gt;
    &lt;min&gt;0.4.0&lt;/min&gt;
   &lt;/package&gt;
  &lt;/group&gt;
 &lt;/dependencies&gt;
 <link linkend="guide.developers.package2.usesrole">&lt;usesrole&gt;</link>
  &lt;role&gt;foo&lt;/role&gt;
  &lt;package&gt;Foo&lt;/package&gt;
  &lt;channel&gt;pear.example.com&lt;/channel&gt;
 &lt;/usesrole&gt;
 <link linkend="guide.developers.package2.usestask">&lt;usestask&gt;</link>
  &lt;task&gt;footask&lt;/task&gt;
  &lt;package&gt;Footask&lt;/package&gt;
  &lt;channel&gt;pear.example.com&lt;/channel&gt;
 &lt;/usestask&gt;
 <link linkend="guide.developers.package2.release">&lt;phprelease&gt;</link>
  &lt;installconditions&gt;
   &lt;os&gt;
    &lt;name&gt;windows&lt;/name&gt;
   &lt;/os&gt;
  &lt;/installconditions&gt;
  &lt;filelist&gt;
   &lt;install as="pear.bat" name="scripts/pear.bat" /&gt;
   &lt;install as="pecl.bat" name="scripts/pecl.bat" /&gt;
   &lt;install as="pearcmd.php" name="scripts/pearcmd.php" /&gt;
   &lt;install as="peclcmd.php" name="scripts/peclcmd.php" /&gt;
   &lt;ignore name="scripts/pear.sh" /&gt;
   &lt;ignore name="scripts/pecl.sh" /&gt;
  &lt;/filelist&gt;
 &lt;/phprelease&gt;
 &lt;phprelease&gt;
  &lt;filelist&gt;
   &lt;install as="pear" name="scripts/pear.sh" /&gt;
   &lt;install as="pecl" name="scripts/pecl.sh" /&gt;
   &lt;install as="pearcmd.php" name="scripts/pearcmd.php" /&gt;
   &lt;install as="peclcmd.php" name="scripts/peclcmd.php" /&gt;
   &lt;ignore name="scripts/pear.bat" /&gt;
   &lt;ignore name="scripts/pecl.bat" /&gt;
  &lt;/filelist&gt;
 &lt;/phprelease&gt;
 &lt;changelog&gt;
  &lt;release&gt;
   &lt;version&gt;
    &lt;release&gt;1.3.5&lt;/release&gt;
    &lt;api&gt;1.3.0&lt;/api&gt;
   &lt;/version&gt;
   &lt;stability&gt;
    &lt;release&gt;stable&lt;/release&gt;
    &lt;api&gt;stable&lt;/api&gt;
   &lt;/stability&gt;
   &lt;date&gt;2005-02-26&lt;/date&gt;
   &lt;license uri="http://www.php.net/license/3_0.txt"&gt;PHP License&lt;/license&gt;
   &lt;notes&gt;
 * fix Bug #3505: pecl can't install PDO
 * enhance pear run-tests dramatically
 * fix Bug #3506: pear install should export the pear version into the environment

   &lt;/notes&gt;
  &lt;/release&gt;
  &lt;release&gt;
   &lt;version&gt;
    &lt;release&gt;1.4.0a1&lt;/release&gt;
    &lt;api&gt;1.4.0&lt;/api&gt;
   &lt;/version&gt;
   &lt;stability&gt;
    &lt;release&gt;alpha&lt;/release&gt;
    &lt;api&gt;alpha&lt;/api&gt;
   &lt;/stability&gt;
   &lt;date&gt;2005-02-26&lt;/date&gt;
   &lt;license uri="http://www.php.net/license/3_0.txt"&gt;PHP License&lt;/license&gt;
   &lt;notes&gt;
  This is a major milestone release for PEAR.  In addition to several killer features,
  every single element of PEAR has a regression test, and so stability is much higher
  than any previous PEAR release, even with the alpha label.

  New features in a nutshell:
  * full support for channels
  * pre-download dependency validation
  * new package.xml 2.0 format allows tremendous flexibility while maintaining BC
  * support for optional dependency groups and limited support for sub-packaging
  * robust dependency support
  * full dependency validation on uninstall
  * support for binary PECL packages
  * remote install for hosts with only ftp access - no more problems with
    restricted host installation
  * full support for mirroring
  * support for bundling several packages into a single tarball
  * support for static dependencies on a url-based package

  Specific changes from 1.3.5:
  * Implement request #1789: SSL support for xml-rpc and download
  * Everything above here that you just read
   &lt;/notes&gt;
  &lt;/release&gt;
 &lt;/changelog&gt;
&lt;/package&gt;
    </programlisting>
   </para>
   </section>
  </section>
  <section xml:id="guide.developers.package2.peclinfo"><info><title>Special information for PECL developers</title></info>
   

   
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="guide.developers.package2.pecl">
 <refnamediv>
  <refname>extsrcrelease and extbinrelease changes for PECL developers</refname>
  <refpurpose>PECL-specific details of package.xml 2.0</refpurpose>
 </refnamediv>
 <refsection xml:id="guide.developers.package2.pecl.intro"><info><title>Special extension package tags</title></info>
  
  <para>
   Most of the tags for PECL-style PHP extension releases are identical to those for
   PEAR-style PHP script releases.  There are a few extsrc/extbin-specific tags that
   all PECL developers must know about.
  </para>
  <para>
   <table xml:id="guide.developers.package2.pecl.intro.chart"><title>PECL extsrc/extbin-specific tags in package.xml 2.0</title>
    
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Tag</entry>
       <entry>Description of usage</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
        &lt;providesextension&gt;
       </entry>
       <entry>
        The &lt;providesextension&gt; tag must be right after &lt;dependencies&gt;.  This
        tag tells the installer the name of the extension provided by the package, allowing
        different package names from the extension.  This could be important for binary packages
        (such as PDO and PDO_windows or something along those lines).
        <programlisting role="xml">
         <![CDATA[
<providesextension>PDO</providesextension>
         ]]>
        </programlisting>
       </entry>
      </row>
      <row>
       <entry>
        &lt;srcpackage&gt; or &lt;srcuri&gt;
       </entry>
       <entry>
        &lt;srcpackage&gt; or &lt;srcuri&gt; must follow &lt;providesextension&gt;.
        Extension binary packages must define either a &lt;srcpackage&gt; tag (for package.xml
        containing <link linkend="guide.developers.package2.channel">&lt;channel&gt;</link>) or
        a &lt;srcuri&gt; tag (for package.xml containing
        <link linkend="guide.developers.package2.uri">&lt;uri&gt;</link>).
        <programlisting role="xml">
         <![CDATA[
<name>PDO_windowsbin</name>
<channel>pecl.php.net</channel>
<!-- snip -->
<providesextension>PDO</providesextension>
<srcpackage>PDO</srcpackage>
         ]]>
        </programlisting>
        or,
        <programlisting role="xml">
         <![CDATA[
<name>Foo_windowsbin</name>
<uri>http://www.example.com/Foo_windowsbin-1.5.0.tgz</uri>
<!-- snip -->
<providesextension>Foo</providesextension>
<srcuri>http://www.example.com/Foo-1.5.0.tgz</srcuri>
         ]]>
        </programlisting>
       </entry>
      </row>
      <row>
       <entry>
        &lt;configureoption&gt;
       </entry>
       <entry>
        The &lt;configureoption&gt; tag is used to ask a user a specific
        question, which is then used to influence the building of the extension.
        Any configure option beginning with <quote>with</quote> is assumed
        to be a question about enabling a feature.  Other options have the user's
        response automatically passed to <command>configure</command>.  The
        following configureoptions:
        <programlisting role="xml">
         <![CDATA[
<configureoption name="with-blah" prompt="enable blah?" default="yes"/>
<configureoption name="foo" prompt="what foo to use?" default="bar"/>
         ]]>
        </programlisting>
        will generate a configure line similar to:
        <screen>--with-blah --foo=bar</screen> if the user accepts the default
        values.
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </para>
 </refsection>
 </refentry>

  </section>
  <section xml:id="guide.developers.package2.tags"><info><title>Detailed Tag Reference for package.xml version 2.0</title></info>
   

   <para>
    Each tag that needs further explanation is documented here (unfinished)
   </para>

   
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="guide.developers.package2.channel">
 <refnamediv>
  <refname>&lt;channel&gt;</refname>
  <refpurpose>What is a channel?</refpurpose>
 </refnamediv>
 <refsection xml:id="guide.developers.package2.channel.intro"><info><title>Quick introduction to channels</title></info> 
  
  <para>
   Channels are new in PEAR 1.4.0.  Channels are a systemized way of differentiating between
   different download sources.  One such download source is pear.php.net, another is pecl.php.net,
   and there are several third party channels slowly springing up around the net.
  </para>
  <para>
   The &lt;channel&gt; tag should contain the full channel name, not any alias (don't use
   "pear", use "pear.php.net".
  </para>
  <para>
   A good rule of thumb to use when determining what channel name to use is "where do
   I upload my releases to?"  If the answer is pear.php.net, that is your package's channel.
   If the answer is pecl.php.net, then that is your channel.
  </para>
  <para>
   If you aren't running a channel server and wish to serve your packages as well as allow
   other packages to remotely depend on your package, the new uri-based package distribution
   method is the best choice, see the &lt;uri&gt; tag documentation link below.
  </para>
  <refsection><info><title>See also:</title></info>
   
   <para>
    <link linkend="guide.developers.package2.uri">&lt;uri&gt;</link>
   </para>
  </refsection>
 </refsection>
 </refentry>

   
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="guide.developers.package2.extends">
 <refnamediv>
  <refname>&lt;extends&gt;</refname>
  <refpurpose>Superseding a package</refpurpose>
 </refnamediv>
 <refsection xml:id="guide.developers.package2.extends.intro"><info><title>Saying goodbye to an old package</title></info>
  
  <para>
   By adding an &lt;extends&gt; tag to your <filename>package.xml</filename>,
   you tell the world that your new package extends an old package in some way.
   The new package could supersede the old one, or give new functionality to
   it.
  </para>
  <example><info><title>Using extends</title></info>
   
   <programlisting role="xml">
...
 &lt;name&gt;Package_Name2&lt;/name&gt;
 &lt;channel&gt;pear.php.net&lt;/channel&gt;
 &lt;extends&gt;Package_Name&lt;/extends&gt;
 &lt;summary&gt;Any one-line summary&lt;/summary&gt;
...
   </programlisting>
  </example>

  <example><info><title>Examples for &lt;extends&gt; usage in PEAR</title></info>
   
   <itemizedlist>
    <listitem>
     <simpara>HTML_Common2 extends HTML_Common</simpara>
    </listitem>
    <listitem>
     <simpara>HTML_Progress2 extends HTML_Progress</simpara>
    </listitem>
    <listitem>
     <simpara>MDB2 extends MDB</simpara>
    </listitem>
    <listitem>
     <simpara>MDB2_Schema extends MDB2</simpara>
    </listitem>
   </itemizedlist>
  </example>

 </refsection>
 </refentry>

   
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="guide.developers.package2.uri">
 <refnamediv>
  <refname>&lt;uri&gt;</refname>
  <refpurpose>When should I use &lt;uri&gt;?</refpurpose>
 </refnamediv>
 <refsection xml:id="guide.developers.package2.uri.intro"><info><title>When to use &lt;uri&gt; instead of &lt;channel&gt;</title></info> 
  
  <para>
   If you do not have a channel server and wish to serve your packages so that others
   can depend on them, use &lt;uri&gt;.  This should contain a static uri that links
   to a single package version's downloadable .tgz
  </para>
  <para>
   If you do not need to allow external remote dependencies, then simply use the pear.php.net
   channel as your package's channel.
  </para>
  <para>
   For instance, if you wish to serve package Foo version 1.1.0 from www.example.com, use the
   uri "http://www.example.com/Foo-1.1.0".  Note that the uri must contain the
   full path MINUS THE EXTENSION.  Provide both Foo-1.1.0.tgz and Foo-1.1.0.tar for users without
   gzip.
  </para>
  <refsection><info><title>See also:</title></info>
   
   <para>
   <link linkend="guide.developers.package2.channel">&lt;channel&gt;</link>
   </para>
  </refsection>
 </refsection>
 </refentry>

   
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="guide.developers.package2.developers">
 <refnamediv>
  <refname>&lt;lead&gt;, &lt;developer&gt;, &lt;contributor&gt;, and &lt;helper&gt;</refname>
  <refpurpose>Developer documentation for a release</refpurpose>
 </refnamediv>
 <refsection xml:id="guide.developers.package2.developers.purpose"><info><title>Documenting who develops a package</title></info> 
  
  <para>
   In package.xml 1.0, a developer was documented using the &lt;maintainer&gt; tag inside of
   a redundant &lt;maintainers&gt; container tag.  This has been simplified in package.xml 2.0
   both to slightly speed parsing and to make validation of the xml simpler.  Now, the contents
   of the &lt;role&gt; tag has been extracted as 4 tags to describe the maintainers of a package.
  </para>
  <para>
   In addition, a new internal tag &lt;active&gt; has been added, so that you can honor retired
   developers' work without having to remove them altogether from package.xml.
  </para>
  <para>
   <emphasis>WARNING:</emphasis> tag order is important.  List leads followed by developers followed
   by contributors and finally helpers.
  </para>
 </refsection>
 </refentry>

   
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="guide.developers.package2.version">
 <refnamediv>
  <refname>&lt;version&gt;</refname>
  <refpurpose>versioning in package.xml 2.0</refpurpose>
 </refnamediv>
 <refsection xml:id="guide.developers.package2.version.purpose"><info><title>Documenting release version and API version</title></info>
  
  <para>
   In package.xml 1.0, the version was simply the version.  package.xml 2.0
   splits the concept of versioning into two components, release and api.
  </para>
  <para>
   The release version is the same familiar versioning concept from package.xml 1.0.
   This version is validated very carefully by the packager.
  </para>
  <para>
   The API version is informational only - the installer does not use it.  It can be used for
   a package-time replacement by the installer.  This can be very useful when implementing a
   reflective method such as <function>getApiVersion</function>.  In addition, the API version
   is very loosely validated, and only requires a version_compare()-compatible version number.
  </para>
 </refsection>
 </refentry>

   
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="guide.developers.package2.stability">
 <refnamediv>
  <refname>&lt;stability&gt;</refname>
  <refpurpose>specifying release and API stability</refpurpose>
 </refnamediv>
 <refsection xml:id="guide.developers.package2.stability.purpose"><info><title>Documenting release stability and API stability</title></info>
  
  <para>
   In package.xml 1.0, stability was known as "state" which is not the most
   accurate description.  package.xml 2.0 introduces the term stability and like version
   splits the concept of stability into two components, release and api.
  </para>
  <para>
   The release stability is the same familiar state from package.xml 1.0.  It can be one
   of:
  </para>
  <para>
   <orderedlist>
    <listitem>
     <para>
      snapshot - a frozen picture of development at a particular moment
     </para>
    </listitem>
    <listitem>
     <para>
      devel - a very new non-production release.  Devel should be used for extremely new,
      practically untested code.
     </para>
    </listitem>
    <listitem>
     <para>
      alpha - a new non-production release.  Alpha should be used for new code that
      has an unstable API or untested code.
     </para>
    </listitem>
    <listitem>
     <para>
      beta - a non-production release.  Beta should be used for code that has a stable API
      and is nearing a fully stable release.  Regresion tests and documentation should exist
      or soon follow to qualify as a beta release.  Release candidates should use the beta
      stability.
     </para>
    </listitem>
    <listitem>
     <para>
      stable - a production release.  Stable releases must have a stable API, and must have
      regression tests and documentation.
     </para>
    </listitem>
   </orderedlist>
  </para>
  <para>
   The API stability is informational only - the installer does not use it.
  </para>
 </refsection>
 </refentry>

   
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="guide.developers.package2.license">
 <refnamediv>
  <refname>&lt;license&gt;</refname>
  <refpurpose>specifying software license and optional reference to license text</refpurpose>
 </refnamediv>
 <refsection xml:id="guide.developers.package2.license.purpose"><info><title>Documenting release license</title></info>
  
  <para>
   In package.xml 1.0, the license tag only contained the name of the license.  In
   package.xml 2.0, there are two optional attributes, "uri" and "filesource".
   "uri" contains a uri that identifies the text of a license, such as
   "http://www.php.net/license/" for the PHP License.  "filesource"
   can be used to specify a LICENSE file within an actual package that contains the text of
   the license.
  </para>
  <para>
  </para>
 </refsection>
 </refentry>

   
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="guide.developers.package2.contents">
 <refnamediv>
  <refname>&lt;contents&gt;</refname>
  <refpurpose>specifying the contents of a release</refpurpose>
 </refnamediv>
 <refsection xml:id="guide.developers.package2.contents.purpose"><info><title>Documenting release contents</title></info>
  
  <para>
   In package.xml 1.0, the contents tag was &lt;filelist&gt;.  The purpose of the
   tag changed dramatically in package.xml 2.0, warranting a name change.  Now, &lt;filelist&gt;
   can be found in the <link linkend="guide.developers.package2.release">release</link> section
   of the package.xml.
  </para>
  <para>
   &lt;contents&gt; is used to describe the contents of a tarball.  Nothing further.  All
   files in the contents tag will be placed into the tarball regardless of whether they
   eventually get installed by the PEAR installer.  This fact can be used to create a very
   versatile tarball, one that can be directly unzipped and work out of the box as well as
   be installed by the PEAR installer and work out of the box.
  </para>
  <para>
   For most release types, contents contains a single &lt;dir&gt; tag that then either
   contains nested dir tags and/or &lt;file&gt; tags.
  </para>
 </refsection>
 </refentry>

   
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="guide.developers.package2.dir">
  <refnamediv>
    <refname>&lt;dir&gt;</refname>

    <refpurpose>documenting a directory in the &lt;contents&gt;
    tag</refpurpose>
  </refnamediv>

  <refsection xml:id="guide.developers.package2.dir.purpose">
    <info>
      <title>Documenting directories</title>
    </info>

    <para>
     The <literal>&lt;dir&gt;</literal> tag describes a directory in the
     package sources.
     A <literal>&lt;dir&gt;</literal> tag may contain other
     <literal>&lt;dir&gt;</literal> tags as well as
     <link linkend="guide.developers.package2.file"><literal>&lt;file&gt;</literal></link>
     tags.
    </para>

    <note>
      <para>All files must be contained in a single top-level &lt;dir&gt; tag.
      For simple packages, simply use &lt;dir name="/"&gt; as the directory
      name.</para>
    </note>
  </refsection>

  <refsection xml:id="guide.developers.package2.dir.attributes">
    <info>
      <title>Attributes</title>
    </info>

    <table xml:id="guide.developers.package2.dir.attributes.required">
      <title>Required attributes</title>

      <tgroup cols="2">
        <thead>
          <row>
            <entry>Attribute name</entry>

            <entry>Description</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry><literal>name</literal></entry>

            <entry>Name of the directory in the sources</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <table xml:id="guide.developers.package2.dir.attributes.optional">
      <title>Optional attributes</title>

      <tgroup cols="2">
        <thead>
          <row>
            <entry>Attribute name</entry>

            <entry>Description</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry><literal>baseinstalldir</literal></entry>

            <entry>Relative location where all files and subdirectories will
            be installed</entry>
          </row>
        </tbody>
      </tgroup>
    </table>
  </refsection>

  <refsection xml:id="guide.developers.package2.dir.examples">
    <info>
      <title>Examples</title>
    </info>

    <para>An excerpt of the <literal>&lt;contents&gt;</literal> tag of a real
    package.xml:</para>

    <programlisting role="xml"><![CDATA[ <contents>
  <dir name="/">
   <dir name="examples">
    <file name="authors.php" role="doc" />
   </dir>
   <dir name="HTML">
    <dir name="Template">
     <file name="PHPLIB.php" role="php" />
     <dir name="PHPLIB">
      <!-- more files -->
     </dir>
    </dir>
  </dir>
 </contents>]]></programlisting>

    <para>
     The <literal>baseinstalldir</literal> attribute is mostly used when
     the directory structure in the package source tree does not match the
     layout when installed (e.g. when the <filename>QuickForm/</filename>
     directory needs to be installed as
     <filename>HTML/QuickForm/</filename>:
    </para>

    <programlisting role="xml"><![CDATA[ <contents>
  <dir name="/" baseinstalldir="HTML">
   <dir name="QuickForm">
    <file name="Element.php" role="php" />
    <!-- would be installed as HTML/QuickForm/Element.php -->
   </dir>
  </dir>
</contents>]]></programlisting>
  </refsection>
</refentry>

   
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="guide.developers.package2.file">
  <refnamediv>
    <refname>&lt;file&gt;</refname>

    <refpurpose>documenting a file in the &lt;contents&gt; tag</refpurpose>
  </refnamediv>

  <refsection xml:id="guide.developers.package2.file.purpose">
    <info>
      <title>Describing files</title>
    </info>

    <para>
     The <tag class="starttag">file</tag> tag describes a file in a
     directory in the package sources.
     File tags may only occur as children of
     <tag class="starttag"><link linkend="guide.developers.package2.dir">dir</link></tag>
     tags.
    </para>

    <para>
     <link linkend="guide.developers.package2.tasks">File Tasks</link>
     can be used to modify files at package time or at installation.
    </para>

    <refsection xml:id="guide.developers.package2.file.attributes">
      <info>
        <title>Attributes</title>
      </info>

      <table xml:id="guide.developers.package2.file.attributes.required">
        <title>Required attributes</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>Attribute name</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><literal>name</literal></entry>

              <entry>Name of the file in the sources</entry>
            </row>

            <row>
              <entry><literal>role</literal></entry>

              <entry>
               Type of the file.
               See <link linkend="guide.developers.package2.file.roles">roles</link>.
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <table xml:id="guide.developers.package2.file.attributes.optional">
        <title>Optional attributes</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>Attribute name</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><literal>baseinstalldir</literal></entry>

              <entry>Relative location where all files and subdirectories will
              be installed</entry>
            </row>

            <row>
              <entry><literal>md5sum</literal></entry>

              <entry>
               MD5 hash about file contents.This is automatically
               generated when executing <command>pear package</command>, so you
               should never set it manually.
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <note>
        <para>
         Previous optional attributes (<filename>package.xml</filename> v1)
         <tag class="attribute">platform</tag> and
         <tag class="attribute">install-as</tag> have been replaced by the
         <link linkend="guide.developers.package2.release.purpose">release tags</link>.
        </para>

        <para>
         Specifically, <tag class="starttag">install</tag> is used to
         specify <tag class="attribute">install-as</tag>, and the
         <tag class="starttag">ignore</tag> tag can be used in conjunction
         with <tag class="starttag">installconditions</tag> to exclude packages from
         being installed on particular platforms.
        </para>
      </note>
    </refsection>

    <refsection xml:id="guide.developers.package2.file.roles">
      <info>
        <title>Roles</title>
      </info>

      <para>
       The <tag class="attribute">role</tag> attribute in the
       <tag class="starttag">file</tag> tag defines what type the file has and in
       which location it should be installed.
      </para>

      <table>
        <title>Possible values</title>

        <tgroup cols="3">
          <thead>
            <row>
              <entry>Role value</entry>

              <entry>Description</entry>

              <entry>Destination dir</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><tag class="attvalue">php</tag></entry>

              <entry>PHP source file</entry>

              <entry><varname>$php_dir</varname> (your include path)</entry>
            </row>

            <row>
              <entry><tag class="attvalue">doc</tag></entry>

              <entry>Documentation or example file</entry>

              <entry><filename>$doc_dir/Package_Name/</filename></entry>
            </row>

            <row>
              <entry><tag class="attvalue">data</tag></entry>

              <entry>Package related data files (graphics, data tables, CSS
              etc.)</entry>

              <entry><varname>$data_dir</varname><filename>/Package_Name/</filename></entry>
            </row>

            <row>
              <entry><tag class="attvalue">www</tag></entry>

              <entry>Files for the HTTPd document root</entry>

              <entry><varname>$www_dir</varname><filename>/</filename></entry>
            </row>

            <row>
              <entry><tag class="attvalue">test</tag></entry>

              <entry>Package related test files (unit-tests etc)</entry>

              <entry><varname>$test_dir</varname><filename>/Package_Name/</filename></entry>
            </row>

            <row>
              <entry><tag class="attvalue">script</tag></entry>

              <entry>Package related shell scripts</entry>

              <entry>the PHP binary directory (<varname>$bin_dir</varname>) or
              <constant>PHP_PEAR_BIN_DIR</constant> if defined</entry>
            </row>

            <row>
              <entry><tag class="attvalue">ext</tag></entry>

              <entry>Extension, dynamically loadable library</entry>

              <entry>the PHP extension directory (<varname>$ext_dir</varname>)
              or <constant>PHP_PEAR_EXTENSION_DIR</constant> if
              defined</entry>
            </row>

            <row>
              <entry><tag class="attvalue">src</tag> / <tag class="attvalue">extsrc</tag></entry>

              <entry>C or C++ source code</entry>

              <entry>not copied directly - used to build a extension</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>
       Directory locations like <varname>$php_dir</varname> are
       configurable in PEAR. <!--You can use
       <command>pear <link linkend="guide.users.commandline.config">config-show</link></command>
       or
       <command>pear <link linkend="guide.users.commandline.config">config-get</link> php_dir</command>
       to retrieve their values.-->
      </para>
    </refsection>

    <refsection xml:id="guide.developers.package2.file.examples">
      <info>
        <title>Examples</title>
      </info>

      <programlisting><![CDATA[ <contents>
  <dir name="/">
   <dir name="examples">
    <!-- gets installed as $doc_dir/Package_Name/examples/authors.php -->
    <file name="authors.php" role="doc" />
    <file name="authors.tpl" role="doc" />
    <file name="README"      role="doc" />
   </dir>

   <dir name="HTML">
    <dir name="Template">
     <!-- gets installed as $php_dir/HTML/Template/PHPLIB.php -->
     <file name="PHPLIB.php"     role="php" />
     <dir  name="PHPLIB">
      <file name="Generator.php" role="php" />
      <file name="Helper.php"    role="php" />
      <file name="Tool.php"      role="php" />
      <file name="Validator.php" role="php" />
     </dir>
    </dir>
   </dir>
   <dir name="tests">
    <file name="AllTests.php"      role="test" />
    <file name="GeneratorTest.php" role="test" />
    <file name="HelperTest.php"    role="test" />
    <file name="ValidatorTest.php" role="test" />
   </dir>
  </dir>
 </contents>]]></programlisting>
    </refsection>
  </refsection>
</refentry>

   
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="guide.developers.package2.tasks">
 <refnamediv>
  <refname>tasks for &lt;file&gt;s</refname>
  <refpurpose>specialized file installation and manipulation</refpurpose>
 </refnamediv>
 <refsection xml:id="guide.developers.package2.tasks.overview"><info><title>Using tasks to customize file installation</title></info>
  
  <para>
   Tasks provide a flexible and customizable way to manipulate file contents or to perform
   complex installation tasks (hence the name "tasks").  By default, PEAR comes
   with 4 tasks, but customized tasks can be added simply by adding a file into the
   PEAR/Tasks directory that follows the conventions of existing tasks.  This page does
   not describe how to create a custom task, only how to use them in package.xml.
  </para>
  <para>
   There are 3 basic tasks and 1 complex task distributed with PEAR.  The basic tasks are
   "tasks:replace", "tasks:windowseol", and "tasks:unixeol".  The complex task
   is "tasks:postinstallscript".  "tasks:replace" is nearly identical to the old
   &lt;replace&gt; tag from package.xml 1.0, and does a text search-and-replace of a file's
   contents.  "tasks:windowseol" and "tasks:unixeol" manipulate the line endings of
   a file to ensure that the correct line endings are in place for critical files like DOS
   .bat batch files and unix shell scripts.  "tasks:postinstallscript" allows users to
   choose to run a script to perform further installation functions.
  </para>
  <refsection xml:id="guide.developers.package2.tasks.replace"><info><title>&lt;tasks:replace&gt; - customizing file contents</title></info>
   
   <para>
    The replace task has 3 required attributes:
   </para>
   <para>
    <orderedlist>
     <listitem>
      <para>
       <emphasis>type</emphasis> - This must be either package-info or pear-config.  package-info
       replacements extract information from package.xml itself to use as the replacement text.
       pear-config replacements use the value of a configuration variable (as displayed by 
       <screen>pear config-show</screen>) as the text for replacement.
      </para>
     </listitem>
     <listitem>
      <para>
       <emphasis>from</emphasis> - Text to search for in a file.  Traditionally, this text
       is enclosed in "@" to differentiate it from normal text, as in from="@version@"
      </para>
     </listitem>
     <listitem>
      <para>
       <emphasis>to</emphasis> - Abstract item to use as a replacement for all occurrences of
       "from".  package-info replacements can be one of api-state, api-version, channel,
       date, description, license, license-uri, name, notes, release_date, release-license, release_notes,
       state, summary, time, version, and for some packages extends, providesextension, srcpackage, and srcuri.
      </para>
     </listitem>
    </orderedlist>
   </para>
   <para>
    Note that package-info replacements are performed at packaging time, so files contain
    package-info replacements inside a .tgz/.tar release.  pear-config replacements can only
    occur on the installation system, and are performed at install-time.
   </para>
  </refsection>
  <refsection xml:id="guide.developers.package2.tasks.windowseol"><info><title>&lt;tasks:windowseol&gt; - converting line endings to \r\n</title></info>
   
   <para>
    This task can be used to enable packaging of windows-specific files (like DOS batch files)
    on a non-windows system, such as unix systems that convert line endings to \n.  Note that this task
    is performed at package-time, as well as at install-time, so files will contain the correct line
    endings inside a .tgz/.tar release.
   </para>
  </refsection>
  <refsection xml:id="guide.developers.package2.tasks.unixeol"><info><title>&lt;tasks:unixeol&gt; - converting line endings to \n</title></info>
   
   <para>
    This task can be used to enable packaging of unix-specific files (like sh shell scripts)
    on a non-unix system, such as windows systems that convert line endings to \r\n.  Note that this task
    is performed at package-time, as well as at install-time, so files will contain the correct line
    endings inside a .tgz/.tar release.
   </para>
  </refsection>
  <refsection xml:id="guide.developers.package2.tasks.postinstallscript"><info><title>&lt;tasks:postinstallscript&gt; - extreme customization</title></info>
   
   <para>
    The postinstallscript task informs the installer that the file it references is a post-installation
    script.
   </para>
   <para>
    For security reasons, post-install scripts must be manually executed by the users, and as such
    the installer has special code that is separate from other tasks.
   </para>
   <para>
    The &lt;postinstallscript&gt; tag may define parameters that are used by the installer to
    retrieve user input.  In order to support both the web installer and the command-line installer,
    all processing of input is performed by PEAR and passed to the post-install script in a
    strict format.  All you need to do is define the parameters using xml inside the
    &lt;postinstallscript&gt; tag.
   </para>
   <para>
    Here is the xml representing a simple post-install script with parameters:
   </para>
   <para>
    <programlisting role="xml">
    <![CDATA[
<tasks:postinstallscript>
 <tasks:paramgroup>
  <tasks:id>first</tasks:id>
  <tasks:param>
   <tasks:name>test</tasks:name>
   <tasks:prompt>Testing Thingy</tasks:prompt>
   <tasks:type>string</tasks:type>
  </tasks:param>
 </tasks:paramgroup>
</tasks:postinstallscript>
    ]]>
    </programlisting>
   </para>
   <para>
    Note that the only type recognized at this stage is "string" but others will follow.
    A more complex example follows:
   </para>
   <para>
    <programlisting role="xml">
    <![CDATA[
<tasks:postinstallscript>
 <tasks:paramgroup>
  <tasks:id>first</tasks:id>
  <tasks:instructions>The first group of questions relates
   primarily to your favorite color.  Answer wisely.
  </tasks:instructions>
  <tasks:param>
   <tasks:name>test</tasks:name>
   <tasks:prompt>Testing Thingy</tasks:prompt>
   <tasks:type>string</tasks:type>
   <tasks:default>hi</tasks:default>
  </tasks:param>
  <tasks:param>
   <tasks:name>test2</tasks:name>
   <tasks:prompt>Testing Thingy 2</tasks:prompt>
   <tasks:type>string</tasks:type>
  </tasks:param>
 </tasks:paramgroup>
 <tasks:paramgroup>
  <tasks:id>second</tasks:id>
  <tasks:name>first::test</tasks:name>
  <tasks:conditiontype>preg_match</tasks:conditiontype>
  <tasks:value>g+</tasks:value>
  <tasks:param>
   <tasks:name>test</tasks:name>
   <tasks:prompt>Testing Thingy a</tasks:prompt>
   <tasks:type>string</tasks:type>
   <tasks:default>hi</tasks:default>
  </tasks:param>
  <tasks:param>
   <tasks:name>test2</tasks:name>
   <tasks:prompt>Testing Thingy b</tasks:prompt>
   <tasks:type>string</tasks:type>
  </tasks:param>
 </tasks:paramgroup>
</tasks:postinstallscript>
    ]]>
    </programlisting>
   </para>
   <para>
    This post-installation script has two parameter groups.  The first parameter group
    has special instructions that are displayed to the user to assist in answering the
    required prompts.  After the first group is processed,
    the second group is processed (naturally). However, in this case, the second group is a
    conditional parameter group. A conditional parameter group examines the user input from
    previous parameter groups and only displays its parameter prompts if a single parameter
    fits a test. The condition is defined by three tags, &lt;tasks:name&gt;, &lt;tasks:conditiontype&gt;,
    and &lt;tasks:value&gt;.  Note that all three tags are required or xml validation will fail.
   </para>
   <para>
    &lt;tasks:name&gt; is the parameter name from a previous parameter group. The format of name is
    groupID::parameterName, so as you see above, "first::test" refers to the
    &lt;tasks:param&gt; test from the &lt;tasks:paramgroup&gt; first.
   </para>
   <para>
    &lt;tasks:conditiontype&gt; determines how the parameter input function will process the value of
    the parameter specified in &lt;tasks:name&gt;, and can be one of three values, "=" "!="
    or "preg_match".
   </para>
   <para>
    <itemizedlist>
     <listitem>
      <para>
       =: This (obviously) tests whether the parameters value is equal to the &lt;tasks:value&gt; tag
      </para>
     </listitem>
     <listitem>
      <para>
       !=: This (obviously) tests whether the parameters value is not equal to the &lt;tasks:value&gt; tag
      </para>
     </listitem>
     <listitem>
      <para>
       preg_match: This uses the content of the &lt;tasks:value&gt; tag as if it were the stuff between
       / and / in a <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.php.net/preg_match"><function>preg_match</function></link>
       function call. Do NOT include // brackets in
       the regular expression.  In the &lt;tasks:paramgroup&gt; second, the value "g+" will become:
       <programlisting role="php">
       <![CDATA[
<?php
preg_match('/g+/', first::test value)
?>
      ]]>
       </programlisting>
      </para>
     </listitem>
    </itemizedlist>
   </para>
  </refsection>
 </refsection>
 </refentry>

   
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="guide.developers.package2.compatible">
 <refnamediv>
  <refname>&lt;compatible&gt;</refname>
  <refpurpose>Alleviating strict versioning with &lt;compatible&gt;</refpurpose>
 </refnamediv>
 <refsection xml:id="guide.developers.package2.compatible.intro"><info><title>Working with &lt;recommended&gt; dependency versions and &lt;compatible&gt;</title></info> 
  
  <para>
   The &lt;compatible&gt; tag is designed to be used with a &lt;package&gt; dependency that
   contains a &lt;recommended&gt; version tag from package pear.example.com/Bar version 1.3.0 like so:
  </para>
  <para>
   <programlisting role="xml">
    <![CDATA[
<package>
 <name>Foo</name>
 <channel>pear.example.com</channel>
 <min>1.0.0</min>
 <recommended>1.5.2</recommended>
</package>
    ]]>
   </programlisting>
  </para>
  <para>
   The above dependency can be translated into English as follows: "Use the package
   pear.example.com/Foo, but only versions 1.0.0 or newer.  If pear.example.com/Foo is not
   installed, install version 1.5.2.  If pear.example.com/Foo is installed and is not version
   1.5.2, fail unless --force is specified, or pear.example.com/Foo is compatible with me."
  </para>
  <para>
   That last clause "...or pear.example.com/Foo is compatible with me." is controlled by the
   &lt;compatible&gt; tag.  If package Foo version 1.5.3's package.xml has a &lt;compatible&gt; like so:
  </para>
  <para>
   <programlisting role="xml">
    <![CDATA[
<compatible>
 <name>Bar</name>
 <channel>pear.example.com</channel>
 <min>1.2.0</min>
 <max>1.3.0</max>
 <exclude>1.2.9</exclude>
</compatible>
    ]]>
   </programlisting>
  </para>
  <para>
   This will instruct the installer that pear.example.com/Foo version 1.5.3 is compatible with
   pear.example.com/Bar versions 1.2.0 to 1.3.0 inclusive, but is not compatible with 1.2.9.
  </para>
  <para>
   It is very important to note that only <emphasis>existing</emphasis> versions that have been
   tested with the package should be mentioned in the &lt;compatible&gt; tag.  Future versions
   of pear.example.com/Bar should simply upgrade the &lt;recommended&gt; tag.
  </para>
  <para>
   &lt;compatible&gt; may contain three versioning tags.  The required &lt;min&gt; and &lt;max&gt;
   are used to define the range of tested and compatible versions, and &lt;exclude&gt; is used to
   exclude any versions within the range.  In the example above, 1.3.0 and 1.2.0 are the highest and
   lowest versions that may be excluded.  There can be an unlimited number of &lt;compatible&gt; tags
   inside a package.xml.
  </para>
  <refsection><info><title>See also:</title></info>
   
   <para>
    <link linkend="guide.developers.package2.dependencies.package">&lt;package&gt; dependencies</link>
   </para>
  </refsection>
 </refsection>
 </refentry>

   
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="guide.developers.package2.dependencies">
 <refnamediv>
  <refname>&lt;dependencies&gt;</refname>
  <refpurpose>Dependency Specification in package.xml 2.0</refpurpose>
 </refnamediv>
 <refsection xml:id="guide.developers.package2.dependencies.intro"><info><title>Introduction to dependencies in package.xml 2.0</title></info> 
  
  <para>
   Dependencies can be tricky to manage.  Using code written by other people
   requires a robust and simple mechanism to manage the risk of breaking your code
   because of bugs in the external package, or worse, an unexpected API change.
   PEAR excels at dependency handling, which mitigates these risks.
   As a PEAR developer, it is crucial to understand how to
   specify a dependency on other packages as well as the system requirements of
   your package.
  </para>
  <para>
   In package.xml 1.0, dependencies are relatively simple, but not as powerful.  Specifying
   a dependency on a package for applications was actually dangerous.  If you wished to limit an installed
   version of a package to a single version, it would mean preventing upgrade at any cost.  package.xml
   2.0 provides a simple way to enforce stricter dependency versioning without making upgrades onerous.
  </para>
  <para>
   package.xml 1.0 supports two kinds of dependencies, required and optional.  package.xml 2.0
   also supports these two dependency types, but introduces a new kind of dependency concept: an
   optional dependency group (documented <link linkend="guide.developers.package2.dependencies.groups">here</link>).  
  </para>
  <para>
   package.xml 1.0 only supported php, package, and extension dependencies.  package.xml 2.0
   supports dependencies on php, package, extension, os, architecture, and PEAR installer.  In
   addition, package.xml 2.0 supports depending on a static package located at a url, and depending
   on a package that provides an extension to PHP like PECL packages.
  </para>
  <para>
   The PEAR installer dependency is not a dependency on the PEAR package, but a dependency on the
   currently running PEAR installer, and is more similar to a PHP dependency in that it requires
   the specified version to be running in memory.  This is very useful for circumventing difficult
   bugs in the PEAR installer that render a package install useless.
  </para>
  <refsection xml:id="guide.developers.package2.dependencies.structure"><info><title>Structure of &lt;dependencies&gt;</title></info>
   
   <para>
    The &lt;dependencies&gt; tag re-organizes dependencies into groups and "extracts"
    attributes into tags.  It also un-abbreviates words for clarity and human-readability.
    The following excerpt of a package.xml version 1.0:
   </para>
   <para>
    <programlisting role="xml">
     <![CDATA[
<deps>
 <dep type="pkg" rel="ge" version="1.3.1">Archive_Tar</dep>
 <dep type="php" rel="ge" version="4.2.0"/>
 <dep type="pkg" rel="has" optional="yes">PEAR_Frontend_Web</dep>
</deps>
     ]]>
    </programlisting>
   </para>
   <para>
    Approximately translates into this format in package.xml 2.0:
   </para>
   <para>
    <programlisting role="xml">
     <![CDATA[
<dependencies>
 <required>
  <pearinstaller>
   <min>1.4.8</min>
  </pearinstaller>
  <php>
   <min>4.2.0</min>
  </php>
  <package>
   <name>Archive_Tar</name>
   <channel>pear.php.net</channel>
   <min>1.3.1</min>
  </package>
 </required>
 <optional>
  <package>
   <name>PEAR_Frontend_Web</name>
   <channel>pear.php.net</channel>
  </package>
 </optional>
</dependencies>
     ]]>
    </programlisting>
   </para>
   <para>
    These changes were made to simplify xml validation and parsing.  Note that unlike package.xml
    1.0, the &lt;pearinstaller&gt; and &lt;php&gt; dependencies are required in all package.xml.
    In addition the &lt;min&gt; tag is required in both &lt;pearinstaller&gt; and
    &lt;php&gt; dependencies.
   </para>
  </refsection>
  <refsection xml:id="guide.developers.package2.dependencies.groups">
   <info><title>Optional Dependency Groups</title></info>
   <para>
    Optional dependency groups define feature sets that are not required, but
    should be installed in a block.  These feature sets consist of &lt;package&gt;
    and &lt;extension&gt; dependencies.  For instance, if a package can optionally
    perform operations on a remote shell, it would create an optional dependency
    group named <literal>remoteshell</literal> with dependencies on the
    <literal>ssh2</literal> PECL extension and the (fictional)
    <literal>SSH_RemoteShell</literal> package.  The dependency group could look
    like this in package.xml:
   </para>
   <para>
    <programlisting role="xml">
     <![CDATA[
<group name="remoteshell" hint="Add support for Remote Shell Operations">
 <package>
  <name>SSH_RemoteShell</name>
  <channel>pear.php.net</channel>
 </package>
 <extension>
  <name>ssh2</name>
 </extension>
</group>
     ]]>
    </programlisting>
   </para>
   <para>
    To install this dependency group, the user would simply use
    <literal>pear install Packagename#remoteshell</literal>.
   </para>
  </refsection>
  <refsection xml:id="guide.developers.package2.dependencies.pearinstaller"><info><title>&lt;pearinstaller&gt; dependencies</title></info>
   
   <para>
    The &lt;pearinstaller&gt; dependency defines the minimum version of PEAR that can properly
    parse and install the package.xml containing it.  As with all dependency tags that support
    versioning, these 4 tags are supported to define versioning:
   </para>
   <para>
    <itemizedlist>
     <listitem>
      <para>
       &lt;min&gt; - minimum version of PEAR required to install this package.xml.  This tag is
       required in all package.xml &lt;pearinstaller&gt; dependencies.
      </para>
     </listitem>
     <listitem>
      <para>
       &lt;max&gt; - maximum version of PEAR installer supported.  Use with caution!  This tag
       will prevent the package from being installed by anyone with a newer version of PEAR!
      </para>
     </listitem>
     <listitem>
      <para>
       &lt;recommended&gt; - recommended version of PEAR installer.  This tag is used for strict
       version control.  The installer will refuse to install a package without the --force
       option unless the version exactly matches recommended.  This can be used to provide a level
       of extra security, as a package can be set to install using a version that is known to work
       without limiting future upgrades.
      </para>
     </listitem>
     <listitem>
      <para>
       &lt;exclude&gt; - incompatible versions of PEAR installer.  Use this to prevent the package
       from being installed by any PEAR version that cannot properly install the package.  Multiple
       &lt;exclude&gt; tags may be used to exclude more than one version.
      </para>
     </listitem>
    </itemizedlist>
   </para>
  </refsection>
  <refsection xml:id="guide.developers.package2.dependencies.php"><info><title>&lt;php&gt; dependencies</title></info>
   
   <para>
    As with all dependency tags that support
    versioning, these 4 tags are supported to define versioning:
   </para>
   <para>
    <itemizedlist>
     <listitem>
      <para>
       &lt;min&gt; - minimum version of PHP required to install this package.xml.  This tag is
       required in all package.xml &lt;php&gt; dependencies.
      </para>
     </listitem>
     <listitem>
      <para>
       &lt;max&gt; - maximum version of PHP supported.
      </para>
     </listitem>
     <listitem>
      <para>
       &lt;exclude&gt; - incompatible versions of PHP.  Use this to prevent the package
       from being installed by any PHP version that cannot properly work with the package.  Multiple
       &lt;exclude&gt; tags may be used to exclude more than one version.
      </para>
     </listitem>
    </itemizedlist>
   </para>
  </refsection>
  <refsection xml:id="guide.developers.package2.dependencies.subpackage"><info><title>&lt;subpackage&gt; dependencies</title></info>
   
   <para>
    Subpackage dependencies share the same xml format as package dependencies.  The subpackage
    dependency should only be used if a package is split into more than one package.  In other
    words, if the child package contains the same files as any earlier version of the parent
    package, the child package would normally conflict with the parent package because it
    would be attempting to overwrite the parent package's files with its own files.
   </para>
   <para>
    A simple example should make this clear.  Package Foo 1.0.0 contains Foo.php and Foo/Bar.php.
    Package Foo's developers decide to split Foo into two packages: Foo and Foo_Bar.  Foo 1.1.0
    contains foo.php, and Foo_Bar 0.1.0 contains Foo/Bar.php.  Foo_Bar 0.1.0 conflicts directly
    with Foo 1.0.0, as both contain the file Foo/Bar.php.
   </para>
   <para>
    If Foo has a subpackage dependency on Foo_Bar, then the installer will ignore the conflict
    between Foo 1.0.0's Foo/Bar.php and Foo_Bar 0.1.0's Foo/Bar.php just as it ignores the conflict
    between Foo 1.0.0's Foo.php and Foo 1.1.0's Foo.php.
   </para>
  </refsection>
  <refsection xml:id="guide.developers.package2.dependencies.package"><info><title>&lt;package&gt; dependencies</title></info>
   
   <para>
    Understandably, the &lt;package&gt; dependency is PEAR's most complex dependency.  PEAR 1.4.0
    supports 3 different kinds of package dependencies:
   </para>
   <para>
    <orderedlist>
     <listitem>
      <para>
       Normal, traditional channel server-based package dependencies (same idea as package.xml 1.0).
      </para>
     </listitem>
     <listitem>
      <para>
       Dependencies on packages that provide PHP extensions (like <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://pecl.php.net/">PECL</link>
       packages).  (These can be both server-based and uri-based dependencies)
      </para>
     </listitem>
     <listitem>
      <para>
       Static, non-traditional uri-based package dependencies.
      </para>
     </listitem>
    </orderedlist>
   </para>
   <refsection xml:id="guide.developers.package2.dependencies.package.channel"><info><title>channel-based &lt;package&gt; depedendencies</title></info>
    
    <para>
     The most common kind of package dependency is a channel-based dependency.  This dependency
     from package.xml version 1.0:
    </para>
    <para>
     <programlisting role="xml">
      <![CDATA[
<deps>
 <dep type="pkg" rel="has">PEAR</dep>
</deps>
      ]]>
     </programlisting>
    </para>
    <para>
     translates to this dependency in package.xml version 2.0:
    </para>
    <para>
     <programlisting role="xml">
      <![CDATA[
<dependencies>
 <required>
<!-- ... -->
  <package>
   <name>PEAR</name>
   <channel>pear.php.net</channel>
  </package>
 </required>
</dependencies>
      ]]>
     </programlisting>
    </para>
    <para>
     Note that &lt;channel&gt; is a required tag for all typical package dependencies.  Use pear.php.net
     for all packages that were packaged using package.xml 1.0, regardless of where they are downloaded
     from.
    </para>
    <para>
     As with all dependency tags that support versioning, all standard versioning tags
     are supported (min, max, recommended, exclude).  In addition, the &lt;conflicts&gt;
     tag is supported to create a negative dependency.
    </para>
    <para>
     <itemizedlist>
      <listitem>
       <para>
        &lt;min&gt; - minimum version of a dependency.  If the dependency package is installed, and
        is older than this version, installation will fail.
       </para>
      </listitem>
      <listitem>
       <para>
        &lt;max&gt; - maximum version of a dependency.  If the dependency package is installed, and
        is newer than this version, installation will fail.
       </para>
      </listitem>
      <listitem>
       <para>
        &lt;recommended&gt; - recommended version of a dependency.  This tag is used for strict
        version control.  The installer will refuse to install a package without the --force
        option unless the version exactly matches recommended.  This can be used to provide a level
        of extra security, as a package can be set to install using a version that is known to work
        without limiting future upgrades.
       </para>
       <para>
        Note that use of the <link linkend="guide.developers.package2.compatible">&lt;compatible&gt;</link>
        tag in the dependency's package.xml can be used
        to circumvent the installer's strictness.  In essence, the &lt;compatible&gt; tag tells the
        installer that a dependent package is compatible with the current package, even though
        it is not the recommended version.
       </para>
      </listitem>
      <listitem>
       <para>
        &lt;exclude&gt; - incompatible versions of a package.  Multiple
        &lt;exclude&gt; tags may be used to exclude more than one version of a dependency.
       </para>
      </listitem>
     <listitem>
      <para>
       &lt;conflicts&gt; - Negates the dependency.  If the package is installed, it cannot
       satisfy the requirements of the dependency or installation will fail.
      </para>
     </listitem>
     </itemizedlist>
    </para>
    <para>
     Here is a rough chart describing how to convert from package.xml 1.0 "rel" attributes
     to a package.xml 2.0 equivalent.
    </para>
    <para>
     <table xml:id="guide.developers.package2.dependencies.package.convert"><title>Converting package.xml 1.0 package dependencies to package.xml 2.0</title>
      
      <tgroup cols="2">
       <thead>
        <row>
         <entry>1.0</entry>
         <entry>2.0 equivalent</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>
          <programlisting role="xml">
           <![CDATA[<dep type="pkg" rel="has">Foo</dep>]]>
          </programlisting>
         </entry>
         <entry>
          <programlisting role="xml">
           <![CDATA[
<package>
 <name>Foo</name>
 <channel>pear.php.net</channel>
</package>
           ]]>
          </programlisting>
         </entry>
        </row>
        <row>
         <entry>
          <programlisting role="xml">
           <![CDATA[<dep type="pkg" rel="ge" version="1.0.0">Foo</dep>]]>
          </programlisting>
         </entry>
         <entry>
          <programlisting role="xml">
           <![CDATA[
<package>
 <name>Foo</name>
 <channel>pear.php.net</channel>
 <min>1.0.0</min>
</package>
           ]]>
          </programlisting>
         </entry>
        </row>
        <row>
         <entry>
          <programlisting role="xml">
           <![CDATA[<dep type="pkg" rel="gt" version="1.0.0">Foo</dep>]]>
          </programlisting>
         </entry>
         <entry>
          <programlisting role="xml">
           <![CDATA[
<package>
 <name>Foo</name>
 <channel>pear.php.net</channel>
 <min>1.0.0</min>
 <exclude>1.0.0</exclude>
</package>
           ]]>
          </programlisting>
         </entry>
        </row>
        <row>
         <entry>
          <programlisting role="xml">
           <![CDATA[<dep type="pkg" rel="le" version="1.0.0">Foo</dep>]]>
          </programlisting>
         </entry>
         <entry>
          <programlisting role="xml">
           <![CDATA[
<package>
 <name>Foo</name>
 <channel>pear.php.net</channel>
 <max>1.0.0</max>
</package>
           ]]>
          </programlisting>
         </entry>
        </row>
        <row>
         <entry>
          <programlisting role="xml">
           <![CDATA[<dep type="pkg" rel="ge" version="1.0.0">Foo</dep>]]>
          </programlisting>
         </entry>
         <entry>
          <programlisting role="xml">
           <![CDATA[
<package>
 <name>Foo</name>
 <channel>pear.php.net</channel>
 <max>1.0.0</max>
 <exclude>1.0.0</exclude>
</package>
           ]]>
          </programlisting>
         </entry>
        </row>
        <row>
         <entry>
          <programlisting role="xml">
           <![CDATA[
<dep type="pkg" rel="ge" version="1.0.0">Foo</dep>
<dep type="pkg" rel="le" version="1.9.0">Foo</dep>
           ]]>
          </programlisting>
         </entry>
         <entry>
          <programlisting role="xml">
           <![CDATA[
<package>
 <name>Foo</name>
 <channel>pear.php.net</channel>
 <min>1.0.0</min>
 <max>1.9.0</max>
</package>
           ]]>
          </programlisting>
         </entry>
        </row>
        <row>
         <entry>
          <programlisting role="xml">
           <![CDATA[
<dep type="pkg" rel="not">Foo</dep>
           ]]>
          </programlisting>
         </entry>
         <entry>
          <programlisting role="xml">
           <![CDATA[
<package>
 <name>Foo</name>
 <channel>pear.php.net</channel>
 <conflicts/>
</package>
           ]]>
          </programlisting>
         </entry>
        </row>
       </tbody>
      </tgroup>
     </table>
    </para>
   </refsection>
   <refsection xml:id="guide.developers.package2.dependencies.package.uri"><info><title>uri-based &lt;package&gt; dependencies</title></info>
    
    <para>
     Let's look at uri-based package dependencies.  Here is a simple example:
    </para>
    <para>
     <programlisting role="xml">
      <![CDATA[
<package>
 <name>Foo<name>
 <uri>http://www.example.com/Foo-1.3.0</uri>
</package>
      ]]>
     </programlisting>
    </para>
    <para>
     This dependency tells the installer to fetch http://www.example.com/Foo-1.3.0.tgz or
     http://www.example.com/Foo-1.3.0.tar (both must be available!) if the package Foo
     is not installed.  All uri packages must contain a
     <link linkend="guide.developers.package2.uri">&lt;uri&gt;</link> tag rather than a
     <link linkend="guide.developers.package2.channel">&lt;channel&gt;</link> tag and will
     automatically belong to the pseudo-channel "__uri", but that is not important to
     the discussion of how to format the xml to create the uri-based package dependency.
    </para>
    <para>
     uri-based package dependencies cannot contain any versioning information, as this is irrelevant:
     there is only one version possible with a static uri.  uri-based dependencies can contain the
     &lt;conflicts/&gt; tag to specify an absolute conflict with the package, and the
     &lt;providesextension&gt; tag to specify an extension provided by the static package.
    </para>
   </refsection>
   <refsection xml:id="guide.developers.package2.dependencies.package.phporext"><info><title>PEAR-style &lt;package&gt; dependencies vs. PECL-style &lt;package&gt; dependencies</title></info>
    
    <para>
     package.xml 2.0 supports differentiating
     <link linkend="guide.developers.package2.release">release types</link>, and as such also
     supports dependencies on PECL-style packages that use the extbinrelease or extsrcrelease type.
    </para>
    <para>
     To specify a dependency on a PHP extension that <emphasis>can be</emphasis> distributed as
     a PECL package, but could also be bundled with PHP by default, such as the PDO extension,
     use this dependency style:
    </para>
    <para>
     <programlisting role="xml">
      <![CDATA[
<package>
 <name>PDO</name>
 <channel>pecl.php.net</channel>
 <min>0.3.1</min>
 <providesextension>PDO</providesextension>
</package>
      ]]>
     </programlisting>
    </para>
    <para>
     The magic is in the &lt;providesextension&gt; tag.  This tag tells the installer to take this
     process when validating the dependency:
     <orderedlist>
      <listitem>
       <para>
        Is the extension "PDO" present in memory?  If so, is it version 0.3.1 or higher?
       </para>
      </listitem>
      <listitem>
       <para>
        If not, is the user also installing pecl.php.net/PDO at the same time as this package?  If
        so, is it version 0.3.1 or higher?
       </para>
      </listitem>
      <listitem>
       <para>
        If not, is pecl.php.net/PDO installed, and is the version 0.3.1 or higher?
       </para>
      </listitem>
     </orderedlist>
    </para>
    <para>
     If any of the three conditions above validate in the order specified, the dependency will be
     satisfied and installation will continue.  This system allows users to use a different php.ini
     to install PHP extensions and also provides a fail-safe system to depend on extensions.
    </para>
    <warning>
     <simpara>
      &lt;providesextension&gt;, like all other extension-related functions in PHP, is case-sensitive.
      Do not use "pdo" for the "PDO" extension, or your dependency will always
      fail.
     </simpara>
    </warning>
   </refsection>
  </refsection>
  <refsection xml:id="guide.developers.package2.dependencies.extension"><info><title>&lt;extension&gt; dependencies</title></info>
   
   <para>
    As with all dependency tags that support versioning, all standard versioning tags
    are supported (min, max, recommended, exclude).  In addition, the &lt;conflicts&gt;
    tag is supported to create a negative dependency.
   </para>
   <para>
    <itemizedlist>
     <listitem>
      <para>
       &lt;min&gt; - minimum version of PHP extension to install this package.xml.
      </para>
     </listitem>
     <listitem>
      <para>
       &lt;max&gt; - maximum version of PHP extension supported.
      </para>
     </listitem>
     <listitem>
      <para>
       &lt;recommended&gt; - recommended version of PHP extension.  This tag is used for strict
       version control.  The installer will refuse to install a package without the --force
       option unless the version exactly matches recommended.  This can be used to provide a level
       of extra security, as a package can be set to install using a version that is known to work
       without limiting future upgrades.
      </para>
     </listitem>
     <listitem>
      <para>
       &lt;exclude&gt; - incompatible versions of PHP extension.  Multiple
       &lt;exclude&gt; tags may be used to exclude more than one version.
      </para>
     </listitem>
     <listitem>
      <para>
       &lt;conflicts&gt; - Negates the dependency.  If the extension is present, it cannot
       satisfy the requirements of the dependency or installation will fail.
      </para>
     </listitem>
    </itemizedlist>
   </para>
  </refsection>
  <refsection xml:id="guide.developers.package2.dependencies.os"><info><title>&lt;os&gt; dependencies</title></info>
   
   <para>
    The OS dependency is used to restrict a package to both a particular class of OSes (like unix) and to
    a specific OS (like darwin, or freebsd).  Here is an example:
   </para>
   <para>
    <programlisting role="xml">
     <![CDATA[
<os>
 <name>linux</name>
</os>
     ]]>
    </programlisting>
   </para>
   <para>
    To specify that a package can be installed on every OS except the one specified, use the
    &lt;conflicts/&gt; tag:
   </para>
   <para>
    <programlisting role="xml">
     <![CDATA[
<os>
 <name>windows</name>
 <conflicts/>
</os>
     ]]>
    </programlisting>
   </para>
   <para>
    Possible OS values are:
    <itemizedlist>
     <listitem><simpara>windows</simpara></listitem>
     <listitem><simpara>unix</simpara></listitem>
     <listitem><simpara>linux</simpara></listitem>
     <listitem><simpara>freebsd</simpara></listitem>
     <listitem><simpara>darwin (use for Mac OS X)</simpara></listitem>
     <listitem><simpara>sunos</simpara></listitem>
     <listitem><simpara>irix</simpara></listitem>
     <listitem><simpara>hpux</simpara></listitem>
     <listitem><simpara>aix</simpara></listitem>
    </itemizedlist>
   </para>
   <para>
    In addition, any esoteric OS that supports the
    <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.php.net/php_uname"><function>php_uname</function></link> function can be used.
    Note that the "unix" OS is defined as any of linux, freebsd, darwin, sunos, irix, hpux,
    or aix.
   </para>
  </refsection>
  <refsection xml:id="guide.developers.package2.dependencies.arch"><info><title>&lt;arch&gt; dependencies</title></info>
   
   <para>
    The arch dependency is used to restrict a package to a specific os and processor architecture.
    Here is an example:
   </para>
   <para>
    <programlisting role="xml">
     <![CDATA[
<arch>
 <pattern>linux-*-i386-*</pattern>
</arch>
     ]]>
    </programlisting>
   </para>
   <para>
    To specify that a package can be installed on every architecture except the one specified, use the
    &lt;conflicts/&gt; tag:
   </para>
   <para>
    <programlisting role="xml">
     <![CDATA[
<arch>
 <pattern>linux-*-i?86-*</pattern>
 <conflicts/>
</arch>
     ]]>
    </programlisting>
   </para>
   <para>
    The arch pattern is defined by the <function>OS_Guess-&gt;matchSignature</function> method, and
    is as follows: sysname[-release[-cpu[-extra]]].  All segments within [] are optional,
    and the wildcard "*" can be used in all segments instead of a value.  In addition, the
    "?" wildcard can be used to specify a single character that can match any value.
    i?86 will match i386, i686, i586 and so on.
   </para>
   <para>
    sysname is the same as the os dependency, except unix is not supported.
   </para>
   <para>
    release is the version of the operating system.
   </para>
   <para>
    cpu is the specific cpu, and is typically i?86, sparc, powerpc.
   </para>
   <para>
    extra is any other stuff on the end of <function>php_uname</function>, including the glibc version
   </para>
  </refsection>
 </refsection>
 </refentry>

   
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="guide.developers.package2.usesrole">
 <refnamediv>
  <refname>&lt;usesrole&gt;</refname>
  <refpurpose>documenting custom file roles used in &lt;contents&gt;</refpurpose>
 </refnamediv>
 <refsection xml:id="guide.developers.package2.usesrole.purpose"><info><title>Documenting custom file roles</title></info>
  
  <para>
   Standard file roles provided by default with PEAR are:
  </para>
  <para>
   <itemizedlist>
    <listitem>
     <para>
      php
     </para>
    </listitem>
    <listitem>
     <para>
      data
     </para>
    </listitem>
    <listitem>
     <para>
      doc
     </para>
    </listitem>
    <listitem>
     <para>
      test
     </para>
    </listitem>
    <listitem>
     <para>
      script
     </para>
    </listitem>
    <listitem>
     <para>
      src
     </para>
    </listitem>
    <listitem>
     <para>
      ext
     </para>
    </listitem>
   </itemizedlist>
  </para>
  <para>
   If your package chooses to use a role provided by a third party that implements some
   more advanced file installation handling, all you need to do is specify the role in
   the xml for the &lt;file&gt; tag that contains it like so:
  </para>
  <para>
   <programlisting role="xml">
    <![CDATA[
<file role="foo"/>
    ]]>
   </programlisting>
  </para>
  <para>
   However, if a user does not have the package installed that provides the custom role
   "foo", then the error message on installation will simply say "unknown
   role 'foo'", which is not very helpful.
  </para>
  <para>
   The &lt;usesrole&gt; tag instead prompts the installer to tell the user "this package
   uses the custom role 'foo', install package pear.example.com/Foo to use"
  </para>
  <para>
   <programlisting role="xml">
    <![CDATA[
<usesrole>
 <role>foo</role>
 <package>Foo</package>
 <channel>pear.example.com</channel>
</usesrole>
    ]]>
   </programlisting>
  </para>
  <para>
   Note that static URI packages (channel-less packages) are also supported:
  </para>
  <para>
   <programlisting role="xml">
    <![CDATA[
<usesrole>
 <role>foo</role>
 <uri>http://pear.example.com/Foo-1.2.0</uri>
</usesrole>
    ]]>
   </programlisting>
  </para>
 </refsection>
 </refentry>

   
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="guide.developers.package2.usestask">
 <refnamediv>
  <refname>&lt;usestask&gt;</refname>
  <refpurpose>documenting custom tasks used in &lt;contents&gt;</refpurpose>
 </refnamediv>
 <refsection xml:id="guide.developers.package2.usestask.purpose"><info><title>Documenting custom file tasks</title></info>
  
  <para>
   Standard file tasks provided by default with PEAR are documented in
   <link linkend="guide.developers.package2.tasks">this location</link>.
  </para>
  <para>
   If your package chooses to use a task provided by a third party, all you need to do
   is specify the task as part of the xml for the &lt;file&gt; tag that contains it like so:
  </para>
  <para>
   <programlisting role="xml">
    <![CDATA[
<file role="php">
 <tasks:foo/>
</file>
    ]]>
   </programlisting>
  </para>
  <para>
   However, if a user does not have the package installed that provides the custom task
   "foo", then the error message on installation will simply say "unknown
   task 'foo'", which is not very helpful.
  </para>
  <para>
   The &lt;usestask&gt; tag instead prompts the installer to tell the user "this package
   uses the custom task 'foo', install package pear.example.com/Foo to use"
  </para>
  <para>
   <programlisting role="xml">
    <![CDATA[
<usestask>
 <task>foo</task>
 <package>Foo</package>
 <channel>pear.example.com</channel>
</usestask>
    ]]>
   </programlisting>
  </para>
  <para>
   Note that static URI packages (channel-less packages) are also supported:
  </para>
  <para>
   <programlisting role="xml">
    <![CDATA[
<usestask>
 <task>foo</task>
 <uri>http://pear.example.com/Foo-1.2.0</uri>
</usesrole>
    ]]>
   </programlisting>
  </para>
 </refsection>
 </refentry>

   
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="guide.developers.package2.release">
 <refnamediv>
  <refname>&lt;phprelease&gt;, &lt;extbinrelease&gt;, &lt;extsrcrelease&gt;, &lt;bundle&gt;</refname>
  <refpurpose>specifying the content type of a release</refpurpose>
 </refnamediv>
 <refsection xml:id="guide.developers.package2.release.purpose"><info><title>Documenting release type</title></info>
  
  <para>
   In package.xml 1.0, there was one release type.  package.xml 2.0 provides much finer
   control over the kind of release in order to provide three new release types: extension
   binary release, extension source release, and package bundle release.
  </para>
  <para>
   All of the normal release tags (phprelease, extsrcrelease, extbinrelease) may contain
   two optional sections, &lt;installconditions&gt; and &lt;filelist&gt;.  The purpose of these
   sections is to allow specification of different file install groups based on the target OS
   for installation, or other common install conditions.
  </para>
  <para>
   To be clear: in package.xml, there was 1 &lt;release&gt; tag.  package.xml 2.0 allows
   several adjacent release tags, each specifying a different install set.  This actually
   simplifies complex installation filesets by separating the contents listing of the tarball
   from how the installer should manipulate this listing.  Debugging installation file sets
   should be much simpler with this change.
  </para>
  <para>
   The &lt;filelist&gt; tag can contain only two possible tags, &lt;install&gt; and &lt;ignore&gt;.
   install has two required attributes, "name" and "as".  The install tag is used
   in the same manner as package.xml's install-as attribute for the &lt;file&gt;, to specify a new
   installation location for a file in the contents list.  The ignore tag is used to completely
   ignore a file.
  </para>
  <para>
   The &lt;installconditions&gt; tag can contain 4 tags whose format can be found in the
   &lt;dependencies&gt; section: &lt;php&gt;, &lt;extension&gt;, &lt;os&gt;, and &lt;arch&gt;.
   Each tag can appear exactly once except for the extension tag, which can appear limitless times.
  </para>
  <para>
   The php tag is used to specify a php version or range of versions that an install set should
   be valid with.
  </para>
  <para>
   The extension tag is used to specify extensions that must be present for an install set to
   be valid.
  </para>
  <para>
   The os tag is used to specify an OS that must be present for an install set to be valid.  Note
   that unix can be used to match all flavors, and linux can be used to match all linux-based OSes.
   Darwin should be used for Mac OS X, and * can be used to match all operating systems.
  </para>
  <para>
   The arch tag is used to specify a uname string or portion of a uname string that must match
   in order for the install set to be valid.
  </para>
  <refsection xml:id="guide.developers.package2.release.phprelease"><info><title>&lt;phprelease&gt;</title></info>
   
   <para>
    The phprelease release type is designed for PEAR-style PHP script package releases.
    It causes a few specific validation changes.  First of all,
    the <link linkend="guide.developers.package2.contents">&lt;contents&gt;</link> tag must
    contain &lt;file&gt; and &lt;dir&gt; tags.  The only valid roles for files are role="php",
    role="data", role="doc", and role="test" plus any custom roles
    that the user has installed for use in php releases.
   </para>
  </refsection>
  <refsection xml:id="guide.developers.package2.release.extsrcrelease"><info><title>&lt;extsrcrelease&gt;</title></info>
   
   <para>
    The extsrcrelease release type is for PECL-style PHP extension releases that must be compiled
    in order to be useable.  It causes a few specific validation changes.  First of all,
    the <link linkend="guide.developers.package2.contents">&lt;contents&gt;</link> tag must
    contain &lt;file&gt; and &lt;dir&gt; tags.  The only valid roles for files are role="src",
    role="data", role="doc", and role="test" plus any custom roles
    that the user has installed for use in extension source releases.
   </para>
   <para>
    In addition, the &lt;providesextension&gt; tag must be present in order to document the name of
    the extension this package provides must be in the package.xml as well.
   </para>
  </refsection>
  <refsection xml:id="guide.developers.package2.release.extbinrelease"><info><title>&lt;extbinrelease&gt;</title></info>
   
   <para>
    The extbinrelease release type is for PECL-style PHP Extension binary releases that are pre-compiled.
    It causes a few specific validation changes.  First of all,
    the <link linkend="guide.developers.package2.contents">&lt;contents&gt;</link> tag must
    contain &lt;file&gt; and &lt;dir&gt; tags.  The only valid roles for files are role="ext",
    role="data", role="doc", and role="test" plus any custom roles
    that the user has installed for use in extension binary releases.
   </para>
   <para>
    In addition, the &lt;srcpackage&gt; or &lt;srcuri&gt; and the &lt;providesextension&gt; tags
    must be present in order to document the package that provides extension source for this
    binary release, and the name of the extension this package provides must be in the package.xml as
    well.
   </para>
  </refsection>
  <refsection xml:id="guide.developers.package2.release.bundle"><info><title>&lt;bundle&gt;</title></info>
   
   <para>
    The bundle release type is designed to allow packaging several other package releases into a
    single bundle of packages that will all be installed at the same time.  This can be used to
    distribute a complete application as one tarball, or to distribute a library of packages in a
    single tarball.
   </para>
   <para>
    Unlike the other release types, a bundle release's
    <link linkend="guide.developers.package2.contents">&lt;contents&gt;</link> tag must contain
    only the &lt;bundledpackage&gt; tag.  The contents of the bundledpackage should be release names
    like "Foo-1.2.3.tgz"
   </para>
   <para>
    In addition, the &lt;bundle/&gt; tag must be empty.
   </para>
  </refsection>
 </refsection>
 </refentry>

  </section>
 </chapter>

   
<chapter xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="developers.packagedef">
    <info><title>The package definition file <filename>package.xml</filename> (deprecated)</title>
    <titleabbrev><filename>package.xml</filename></titleabbrev></info>
  
  

  <section xml:id="developers.packagedef.intro"><info><title>Introduction to the package definition file <filename>package.xml</filename></title><titleabbrev>Introduction</titleabbrev></info>
   
   

   <warning><info><title>package.xml version 1.0 is deprecated</title></info>
    
    <para>
     package.xml 1.0 is deprecated.
     You should really be using package.xml version 2.0.
     Documentation can be found at
     <link linkend="guide.developers.package2">package.xml 2.0 documentation</link>.
    </para>
    <para>
     As of 2007-04, More than 99.8% of all PEAR
     installations in the wild are capable of using package.xml 2.0
     files, so you should not worry about backwards compatibility.
    </para>
   </warning>

   <simpara>
    The package definition file <filename>package.xml</filename> is,
    as the name already implies, a well-formed XML file that contains
    all information about a PEAR package.
   </simpara>
   <simpara>
    This chapter will describe the allowed elements of the package
    definition file and it will discuss how to create such a file for
    your package.
   </simpara>

   <simpara>
   The PEAR_PackageFileManager
   package simplifies the creation of package.xml.
   You can install PEAR_PackageFileManager via the usual command
   </simpara>

    <para>
     <screen>
      <userinput>
$ pear install PEAR_PackageFileManager
      </userinput>
     </screen>
    </para>

   <section xml:id="developers.packagedef.elements"><info><title>Allowed elements</title></info>
    

    <para>
     The toplevel element in <filename>package.xml</filename> is the
     element <literal>&lt;package version="1.0"&gt;</literal>. The
     allowed sub elements are:
    </para>

    <itemizedlist>
     <listitem>
      <simpara>
       <literal>&lt;name&gt;</literal>: The name of the package.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       <literal>&lt;summary&gt;</literal>: Short summary of the
       package's description.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       <literal>&lt;description&gt;</literal>: Full length description
       of the package.
      </simpara>
     </listitem>

     <listitem>
      <para>
       <literal>&lt;maintainers&gt;</literal>: Information about the
       maintainers of the package.
       <itemizedlist>
        <listitem>
         <para>
          maintainer: Information about a single maintainer. (May be used
          multiple times.)
          <itemizedlist>
           <listitem>
            <simpara>
             <literal>&lt;user&gt;</literal>: The account name of the user.
            </simpara>
           </listitem>
           <listitem>
            <simpara>
             <literal>&lt;role&gt;</literal>: The role the user has
             during package development. (Can be either lead, developer,
             helper.)</simpara>
           </listitem>
           <listitem>
            <simpara>
             <literal>&lt;name&gt;</literal>: The realname of the user.
            </simpara>
           </listitem>
           <listitem>
            <simpara>
             <literal>&lt;email&gt;</literal>: The email address of the user.
            </simpara>
           </listitem>
          </itemizedlist>
         </para>
        </listitem>
       </itemizedlist>
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>&lt;release&gt;</literal>: Information about the current
       release.
       <itemizedlist>
        <listitem>
         <simpara>
          <literal>&lt;version&gt;</literal>: The version number of
          the release.
         </simpara>
        </listitem>
        <listitem>
         <simpara>
          <literal>&lt;state&gt;</literal>: The state of the release.
          (Can be one of stable, beta, alpha, devel, or snapshot.)
         </simpara>
        </listitem>
        <listitem>
         <simpara>
          <literal>&lt;date&gt;</literal>: The date when the release has
          been rolled.
         </simpara>
        </listitem>
        <listitem>
         <simpara>
          <literal>&lt;license&gt;</literal>: The license
          under which the code is available.
         </simpara>
        </listitem>
        <listitem>
         <simpara>
          <literal>&lt;notes&gt;</literal>: Releasenotes
         </simpara>
        </listitem>
        <listitem>
         <para>
          <literal>&lt;filelist&gt;</literal>
          <itemizedlist>
           <listitem>
            <simpara><literal>&lt;file name="xxx" role="xxx" /&gt;</literal>: Filename</simpara>
           </listitem>
           <listitem>
            <simpara>
             <literal>&lt;dir name="xxx" [role="xxx"]&gt;</literal>: Name
             of a subdirectory. This subdirectory can again contain
             <literal>&lt;file role="xxx"&gt;</literal> entries.
            </simpara>
           </listitem>
          </itemizedlist>
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>&lt;deps&gt;</literal>: List of dependencies of the
          package.
          <itemizedlist>
           <listitem>
            <para>
             <literal>
              &lt;dep type="xxx" rel="yyy" optional="yes"&gt;name&lt;/dep&gt;
             </literal>: For more information about dependencies, please
             see
             <link linkend="guide.developers.packagedef.deps">below</link>.
            </para>
           </listitem>
           </itemizedlist>
          </para>
         </listitem>
       </itemizedlist>
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>&lt;changelog&gt;</literal>: Changelog-like information
       about the package.
       <itemizedlist>
        <listitem>
         <para>
          <literal>&lt;release&gt;</literal>
          <itemizedlist>
           <listitem>
            <simpara>
             <literal>&lt;version&gt;</literal>: Version of the
             specific release.
            </simpara>
           </listitem>
           <listitem>
            <simpara>
             <literal>&lt;state&gt;</literal>: State of the specific
             release.
            </simpara>
           </listitem>
           <listitem>
            <simpara>
             <literal>&lt;date&gt;</literal>: Date when the specific
             release has been rolled.
            </simpara>
           </listitem>
           <listitem>
            <simpara>
             <literal>&lt;notes&gt;</literal>: Changelog information
            </simpara>
           </listitem>
          </itemizedlist>
         </para>
        </listitem>
       </itemizedlist>
      </para>
     </listitem>
    </itemizedlist>

   </section>

   <section xml:id="developers.packagedef.characters"><info><title>Allowed characters</title></info>
    
    <para>
     The letters allowed inside elements are A-Z and a-z.
     Other characters, such as <literal></literal>
     must use entities
     (in this case: <literal>&amp;eacute;</literal>).
    </para>
    <para>
     If you create your package.xml files using the
     PEAR_PackageFileManager, upgrade your PEAR installation
     to version 1.4.0a2 or greater and you won't have
     to worry about this because the file manager takes care
     of this automatically.
    </para>
    <para>
     If you write your package.xml files manually, you will
     need to enter the entities yourself.
     A list of the  most common entities can be found at:
     <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.evolt.org/article/A_Simple_Character_Entity_Chart/17/21234/">
      http://www.evolt.org/article/A_Simple_Character_Entity_Chart/17/21234/</link>
     If the characters you need aren't in that list, go to
     <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.oasis-open.org/docbook/xmlcharent/0.1/index.shtml">
      http://www.oasis-open.org/docbook/xmlcharent/0.1/index.shtml</link>
     and look at the other entity lists.
    </para>
   </section>

   <section xml:id="developers.packagedef.validating"><info><title>Validating</title></info>
     

     <para>
       In order to validate <filename>package.xml</filename> files one
       can use the <command>xmllint</command> tool that comes with
       <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.xmlsoft.org/">libxml2</link>.
     </para>
     <para>
       <command>
         xmllint --dtdvalid http://pear.php.net/dtd/package-1.0 --noout package.xml
       </command>
     </para>
   </section>

   <section xml:id="developers.packagedef.creating"><info><title>Creating a package definition file</title><titleabbrev>Creating the file</titleabbrev></info>
    
    

    <para>
     <example><info><title>Basic <filename>package.xml</filename></title></info>
      
      <programlisting role="xml">
<![CDATA[
<?xml version="1.0" encoding="ISO-8859-1" ?>
<package version="1.0">
 <name>Money_Fast</name>
 <summary>Make money fast.</summary>
 <description>
  This package helps you to make money pretty fast.
 </description>
 <license>PHP License</license>
 <maintainers>
  <maintainer>
   <user>foo</user>
   <name>Joe Foo</name>
   <email>foo@example.com</email>
   <role>lead</role>
  </maintainer>
 </maintainers>

 <release>
  <version>1.0</version>
  <date>2002-05-27</date>
  <state>stable</state>
  <notes>
   This is the first release.
  </notes>
  <filelist>
   <dir name="/" baseinstalldir="Money">
    <file role="php" name="Fast.php" />
   </dir>
  </filelist>
 </release>
</package>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     This <filename>package.xml</filename> can serve as a template for
     you as it already contains all necessary elements. In most cases
     you only need to change the character data between the tags in order
     to use the example in your package.
    </para>
    <para>
     <example><info><title>Example for nested directories</title></info>
      
      <programlisting role="xml">
<![CDATA[
<?xml version="1.0" encoding="ISO-8859-1" ?>

[...]

 <release>
  <version>1.0</version>
  <date>2002-07-23</date>
  <state>stable</state>
  <notes>
   This is the first release.
  </notes>
  <filelist>
   <dir name="/" baseinstalldir="Money">
    <file role="php" name="Fast.php" />
    <dir name="Calculator">
     <file name="Calculator.php" role="php" />
     <file name="Currency.php" role="php" />
     <file name="Stocks.php" role="php" />
    </dir>
    <dir name="docs">
     <file name="README.txt" role="doc" />
     <file name="tutorial.txt" role="doc" />
     <dir name="examples">
      <file name="NASDAQ.php" role="php" />
      <file name="DAX.php" role="php" />
     </dir>
    </dir>
   </dir>
  </filelist>
 </release>
</package>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     In this example you get to know a very handy feature: When you
     have a directory in your package that only contains files of
     the same type, you can add to role attribute even to the
     <literal>&lt;dir&gt;</literal> tag instead of adding it to every
     single <literal>&lt;file&gt;</literal> tag.
    </para>
    <para>
     With the knowledge you've acquired from this chapter you should now
     be able to produce a package definition file for your own package.
     If you still have questions concerning the topic, don't hesitate
     to ask on the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="mailto:pear-general@lists.php.net">mailinglist</link>.
    </para>
   </section>

   <section xml:id="developers.packagedef.roles"><info><title>The file roles</title></info>
    
    <para>
     The <literal>role</literal>-attribute in the &lt;file&gt; tag
     defines what type the file has and in which location it should
     be installed.
     <table><title>Possible values</title>
      
      <tgroup cols="3">
       <thead>
        <row>
         <entry>Value</entry>
         <entry/>
         <entry>Destination dir</entry>
        </row>
       </thead>
       <tbody>

        <row>
         <entry>php</entry>
         <entry>PHP source file</entry>
         <entry>the directory is determined by the package name</entry>
        </row>

        <row>
         <entry>ext</entry>
         <entry>Extension, dynamically loadable library</entry>
         <entry>the PHP extension directory or
          <constant>PHP_PEAR_EXTENSION_DIR</constant>
          if defined</entry>
        </row>

        <row>
         <entry>doc</entry>
         <entry>Documentation file</entry>
         <entry>{PEAR_documentation_dir}/Package_Name/</entry>
        </row>

        <row>
         <entry>data</entry>
         <entry>Package related data files (graphics, data tables etc)</entry>
         <entry>{PEAR_data_dir}/Package_Name/</entry>
        </row>

        <row>
         <entry>test</entry>
         <entry>Package related test files (unit-tests etc)</entry>
         <entry>{PEAR_test_dir}/Package_Name/</entry>
        </row>

        <row>
         <entry>script</entry>
         <entry>Package related shell scripts</entry>
         <entry>the PHP binary directory or
          <constant>PHP_PEAR_BIN_DIR</constant>
          if defined</entry>
        </row>

        <row>
         <entry>src and extsrc</entry>
         <entry>C or C++ source code</entry>
         <entry>not copied directly - used to build a
         extension</entry>
        </row>

       </tbody>
      </tgroup>
     </table>
    </para>

   </section>
   <section xml:id="guide.developers.packagedef.deps"><info><title>Defining Dependencies</title></info>
    

    <para>
     The PEAR Package Manager supports checking for
     different system capabilities. You define those
     dependencies with the <literal>&lt;dep&gt;</literal> tag:
     <example><info><title><filename>package.xml</filename> with dependencies</title></info>
      
      <simpara>
       The following example shows how to specify dependencies for
       PHP 4.3.0 or better and <classname>XML_Parser</classname> 1.0.
      </simpara>
      <programlisting role="xml">
       <![CDATA[
<?xml version="1.0" encoding="ISO-8859-1" ?>

[...]
 </release>
 <deps>
  <dep type="php" rel="ge" version="4.3.0" />
  <dep type="pkg" rel="has" version="1.0">XML_Parser</dep>
 </deps>
</package>
       ]]>
      </programlisting>
     </example>
    </para>
    <section><info><title>The <literal>type</literal>-attribute</title></info>
     
     <para>
      The following <literal>type</literal>s are supported:
     <table><title>type values</title>
      
      <tgroup cols="4">
       <thead>
        <row>
         <entry>Value</entry>
         <entry/>
         <entry>Meaning</entry>
         <entry>Example</entry>
        </row>
       </thead>
       <tbody>

        <row>
         <entry>pkg</entry>
         <entry>Package</entry>
         <entry>depends on a certain Package</entry>
         <entry><quote>HTML_Flexy</quote></entry>
        </row>

        <row>
         <entry>ext</entry>
         <entry>Extension</entry>
         <entry>depends on a certain PHP extension</entry>
         <entry><quote>curl</quote></entry>
        </row>

        <row>
         <entry>php</entry>
         <entry>PHP</entry>
         <entry>depends on a certain PHP version</entry>
         <entry><quote>4.2</quote></entry>
        </row>

        <row>
         <entry>prog</entry>
         <entry>Program</entry>
         <entry>
          depends on a certain Program available in the
          system path.  This is not supported in the PEAR installer.
         </entry>
         <entry><quote>latex</quote></entry>
        </row>

        <row>
         <entry>os</entry>
         <entry>Operating System</entry>
         <entry>depends on a certain OS version</entry>
         <entry><quote>Linux</quote></entry>
        </row>

        <row>
         <entry>sapi</entry>
         <entry>Server API</entry>
         <entry>depends on a certain Server API.  This is not supported in the PEAR installer.</entry>
         <entry><quote>Apache</quote></entry>
        </row>

        <row>
         <entry>zend</entry>
         <entry>Zend</entry>
         <entry>depends on a certain version of the Zend API.
          This is not supported in the PEAR installer.</entry>
         <entry><quote>2</quote></entry>
        </row>
       </tbody>
      </tgroup>
     </table>

    </para>
    <warning>
     <simpara>
      The DTD for the package definition file supports
      further types, but those are not supported yet.
     </simpara>
    </warning>
   </section>
   <section><info><title>The <literal>rel</literal>-attribute</title></info>
    
    <para>
     The <literal>rel</literal>-attribute
     defines the relationship between the existing
     capability and the required.
    </para>
     <table><title>rel values</title>
      
      <tgroup cols="4">
       <thead>
        <row>
         <entry>Value</entry>
         <entry/>
         <entry>Meaning</entry>
         <entry>Can be used with</entry>
        </row>
       </thead>
       <tbody>

        <row>
         <entry>has</entry>
         <entry>has</entry>
         <entry>
          the existing capability must have the
          requirement - version-attribute is
          ignored
         </entry>
         <entry>pkg, ext, php, prog, os, sapi, zend</entry>
        </row>

        <row>
         <entry>eq</entry>
         <entry>equal</entry>
         <entry>
          the existing capability must exactly match the
          version value
         </entry>
         <entry>pkg, ext, php, prog, os, sapi, zend</entry>
        </row>

        <row>
         <entry>lt</entry>
         <entry>less than</entry>
         <entry>
          the existing capability must be less than the version value
         </entry>
         <entry>pkg, ext, php, zend</entry>
        </row>

        <row>
         <entry>le</entry>
         <entry>less than or equal</entry>
         <entry>
          the existing capability must be less than or equal to the
          version value
         </entry>
         <entry>pkg, ext, php, zend</entry>
        </row>

        <row>
         <entry>gt</entry>
         <entry>greater than</entry>
         <entry>
          the existing capability must be greater than the version
          value
         </entry>
         <entry>pkg, ext, php, zend</entry>
        </row>

        <row>
         <entry>ge</entry>
         <entry>greater than or equal</entry>
         <entry>
          the existing capability must greater than or equal to the
          version value
         </entry>
         <entry>pkg, ext, php, zend</entry>
        </row>

        <row>
         <entry>not</entry>
         <entry>conflicting dependency</entry>
         <entry>
          the dependency conflicts with the package, the two cannot co-exist.
          version is ignored.
         </entry>
         <entry>ext, php</entry>
        </row>

       </tbody>
      </tgroup>
     </table>
     <para>
      <literal>Has</literal> will be used if no other value has been
      defined.  Note that rel is required in PEAR 1.4.0 and newer.
     </para>
    </section>
    <section><info><title>The <literal>version</literal>-attribute</title></info>
     

     <para>
      The attribute <literal>version</literal> defines the version
      that is used to compare.
     </para>
    </section>
    <section><info><title>The <literal>optional</literal>-attribute</title></info>
     

     <para>
      The attribute <literal>optional</literal> can be used when
      a dependency is not required but having the package installed
      can bring enhanced functionalities.  The only legal values are "yes"
      and "no".  If the optional attribute is not present, a dependency is
      required.
      When <literal>optional="yes"</literal> is used, this attribute
      will result in installation messages similar to the following messages:
     </para>
    <para>
     <screen>
      <userinput>
$ pear install &lt;package&gt;
Optional dependencies:
Package `XML_Tree' is recommended to utilize some features.
Package `MDB' is recommended to utilize some features.
      </userinput>
     </screen>
    </para>
    </section>
   </section>
  </section>
 </chapter>

  </part>



  <part xml:id="developers-core">
   <title>PEAR Installer: Core components (Installer API, error handling)</title>
   
<chapter xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear"><info><title>PEAR base classes</title></info>
 
 

 <para>
  The Core section provides information about the base classes in PEAR
 </para>
 
 
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear.pear"><info><title>PEAR</title><titleabbrev>PEAR base and error handling class</titleabbrev></info>
  
  

  <para>
   <classname>PEAR</classname> provides functions for handling errors and sets
   the behaviour in case of error.  And, it gives package developers a set of
   functions to make their lives easier.
  </para>

  
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear.pear.intro">
   <refnamediv>
    <refname>Introduction</refname>
    <refpurpose>
     How to handle the PEAR base class (destructors, error handling)
    </refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <synopsis>require_once "PEAR.php";</synopsis>
    <synopsis>class <replaceable>classname</replaceable> extends <classname>PEAR</classname> { ... }</synopsis>
   </refsynopsisdiv>
   <refsection><info><title>Description</title></info>
    
    <simpara>
     The PEAR base class provides standard functionality that is used
     by most PEAR classes.  Normally you never make an instance of the
     PEAR class directly, you use it by subclassing it.
    </simpara>
    <para>
     Its key features are:
     <itemizedlist>
      <listitem>
       <simpara>request-shutdown object "destructors"</simpara>
      </listitem>
      <listitem>
       <simpara>error handling</simpara>
      </listitem>
     </itemizedlist>
    </para>
   </refsection>
   <refsection xml:id="destructors"><info><title>PEAR "destructors"</title></info>
    
    <simpara>
     If you inherit <classname>PEAR</classname> in a class called
     <replaceable>ClassName</replaceable>, you can define a method in
     it called _<replaceable>ClassName</replaceable> (the
     class name with an underscore prepended) that will be invoked
     when the request is over.  This is not a destructor in the sense
     that you can "delete" an object and have the destructor called,
     but in the sense that PHP gives you a callback in the object
     when PHP is done executing.  See <link linkend="example.destructors">the example</link> below.
    </simpara>
    <para>
     <warning xml:id="destructors.warning"><info><title>Important!</title></info>
      
      <para>
       In order for destructors to work properly, you must
       instantiate your class with the "=&amp; new" operator like
       this:
       <programlisting role="php">
<![CDATA[
$obj =& new MyClass();
]]>
       </programlisting>
      </para>
      <simpara>
       If you only use "= new", the object registered in PEAR's
       shutdown list will be a copy of the object at the time the
       constructor is called, and it will be this copy's "destructor"
       that will be called upon request shutdown.
      </simpara>
     </warning>
    </para>
   </refsection>
   <refsection xml:id="error-handling"><info><title>PEAR Error Handling</title></info>
    
    <simpara>
     PEAR's base class also provides a way of passing around more
     complex errors than a true/false value or a numeric code.  A
     PEAR error is an object that is either an instance of the class
     <classname>PEAR_Error</classname>, or some class inheriting
     <classname>PEAR_Error</classname>.
    </simpara>
    <simpara>
     One of the design criteria of PEAR's errors is that it should not
     force a particular type of output on the user, it should be
     possible to handle errors without any output at all if that is
     desirable. This makes it possible to handle errors gracefully,
     also when your output format is different from HTML (for example
     WML or some other XML format).
    </simpara>
    <simpara>
     The error object can be configured to do a number of things when
     it is created, such as printing an error message, printing the
     message and exiting, raising an error with PHP's
     <function>trigger_error</function> function, invoke a callback,
     or none of the above.  This is typically specified in
     <classname>PEAR_Error</classname>'s constructor, but all of the
     parameters are optional, and you can set up defaults for errors
     generated from each object based on the
     <classname>PEAR</classname> class. See the <link linkend="example.error1">PEAR error examples</link> for how
     to use it and the <classname>PEAR_Error</classname> reference
     for the full details.
    </simpara>
   </refsection>
   <refsection><info><title>Examples</title></info>
    
    <para>
     The example below shows how to use the PEAR's "poor man's kinda
     emulated destructors" to implement a simple class that holds the
     contents of a file, lets you append data to the object and
     flushes the data back to the file at the end of the request:
     <example xml:id="example.destructors"><info><title>PEAR: emulated destructors</title></info>
      
      <programlisting role="php">
<![CDATA[
require_once "PEAR.php";

class FileContainer extends PEAR
{
    var $file = '';
    var $contents = '';
    var $modified = 0;

    function FileContainer($file)
    {
        $this->PEAR(); // this calls the parent class constructor
        $fp = fopen($file, "r");
        if (!is_resource($fp)) {
            return;
        }
	$this->file = $file;
        while ($data = fread($fp, 2048)) {
            $this->contents .= $data;
    	}
        fclose($fp);
    }

    function append($str)
    {
        $this->contents .= $str;
        $this->modified++;
    }

    // The "destructor" is named like the constructor
    // but with an underscore in front.
    function _FileContainer()
    {
        if ($this->modified) {
            $fp = fopen($this->file, "w");
            if (!is_resource($fp)) {
                return;
            }
            fwrite($fp, $this->contents);
            fclose($fp);
        }
    }
}

$fileobj =& new FileContainer("testfile");
$fileobj->append("this ends up at the end of the file\n");

// When the request is done and PHP shuts down, $fileobj's
// "destructor" is called and updates the file on disk.
]]>
      </programlisting>
     </example>
     <note>
      <simpara>
       PEAR "destructors" use PHP's shutdown callbacks
       (<function>register_shutdown_function</function>), and
       in PHP &lt; 4.1, you can't output anything from these when
       PHP is running in a web server.  So anything printed in a
       "destructor" gets lost except when PHP is used in
       command-line mode. In PHP 4.1 and higher, output can
       be also generated in the destructor.
      </simpara>
      <simpara>
       Also, see the <link linkend="destructors.warning">warning</link> about how to
       instantiate objects if you want to use the destructor.
      </simpara>
     </note>
    </para>
    <simpara>
     The next examples illustrate different ways of using PEAR's error
     handling mechanism.
    </simpara>
    <para>
     <example xml:id="example.error1"><info><title>PEAR error example (1)</title></info>
      
      <programlisting role="php">
<![CDATA[
function mysockopen($host = "localhost", $port = 8090)
{
    $fp = fsockopen($host, $port, $errno, $errstr);
    if (!is_resource($fp)) {
        return new PEAR_Error($errstr, $errno);
    }
    return $fp;
}

$sock = mysockopen();
if (PEAR::isError($sock)) {
    print "mysockopen error: ".$sock->getMessage()."\n";
}
]]>
      </programlisting>
     </example>
    </para>
    <simpara>
     This example shows a wrapper to <function>fsockopen</function>
     that delivers the error code and message (if any) returned by
     fsockopen in a PEAR error object.  Notice that
     <function>PEAR::isError</function> is used to detect whether a
     value is a PEAR error.
    </simpara>
    <simpara>
     PEAR_Error's mode of operation in this example is simply
     returning the error object and leaving the rest to the user
     (programmer).  This is the default error mode.
    </simpara>
    <simpara>
     In the next example we're showing how to use default error modes:
    </simpara>
    <para>
     <example xml:id="example.error2"><info><title>PEAR error example (2)</title></info>
      
      <programlisting role="php">
<![CDATA[
class TCP_Socket extends PEAR
{
    var $sock;

    function TCP_Socket()
    {
        $this->PEAR();
    }

    function connect($host, $port)
    {
        $sock = fsockopen($host, $port, $errno, $errstr);
        if (!is_resource($sock)) {
            return $this->raiseError($errstr, $errno);
        }
    }
}

$sock = new TCP_Socket;
$sock->setErrorHandling(PEAR_ERROR_DIE);
$sock->connect('localhost', 8090);
print "still alive\n";
]]>
      </programlisting>
     </example>
    </para>
    <simpara>
     Here, we set the default error mode to
     <constant>PEAR_ERROR_DIE</constant>, and since we don't specify
     any error mode in the raiseError call (that'd be the third
     parameter), raiseError uses the default error mode and exits if
     fsockopen fails.
    </simpara>
   </refsection>
   <refsection><info><title>Global Variables Used</title></info>
    
    <para>
     The PEAR class uses some global variables to register global
     defaults, and an object list used by the "destructors".  All of
     the global variables associated with the PEAR class have a
     <literal>_PEAR_</literal> name prefix.
    </para>
    <para>
     <variablelist>
      <varlistentry>
       <term>$_PEAR_default_error_mode</term>
       <listitem>
	<simpara>
	 If no default error mode is set in an object, this mode will
	 be used.  Must be one of
	 <constant>PEAR_ERROR_RETURN</constant>,
	 <constant>PEAR_ERROR_PRINT</constant>,
	 <constant>PEAR_ERROR_TRIGGER</constant>,
	 <constant>PEAR_ERROR_DIE</constant> or
	 <constant>PEAR_ERROR_CALLBACK</constant>.
	</simpara>
	<para>
	 Don't set this variable directly, call
	 <function>PEAR::setErrorHandling</function> as a static
	 method like this:
	 <informalexample>
	  <programlisting role="php">
<![CDATA[
PEAR::setErrorHandling(PEAR_ERROR_DIE);
]]>
      </programlisting>
	 </informalexample>
	</para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>$_PEAR_default_error_options</term>
       <listitem>
	<simpara>
	 If the error mode is <constant>PEAR_ERROR_TRIGGER</constant>,
	 this is the error level (one of
	 <constant>E_USER_NOTICE</constant>,
	 <constant>E_USER_WARNING</constant> or
	 <constant>E_USER_ERROR</constant>).
	</simpara>
	<para>
	 Don't set this variable directly, call
	 <function>PEAR::setErrorHandling</function> as a static
	 method like this:
	 <informalexample>
	  <programlisting role="php">
<![CDATA[
PEAR::setErrorHandling(PEAR_ERROR_TRIGGER, E_USER_ERROR);
]]>
      </programlisting>
	 </informalexample>
	</para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>$_PEAR_default_error_callback</term>
       <listitem>
	<simpara>
	 If no <replaceable>options</replaceable> parameter is used
	 when an error is raised and the error mode is
	 <constant>PEAR_ERROR_CALLBACK</constant>, the value of this
	 variable is used as the callback.  This means that you can
	 switch the error mode temporarily and return to callback mode
	 without specifying the callback function again.  A string
	 value represents a function, a two-element array with an
	 object at index 0 and a string at index 1 represents a
	 method.
	</simpara>
	<para>
	 Again, don't set this variable directly, call
	 <function>PEAR::setErrorHandling</function> as a static
	 method like this:
	 <informalexample>
	  <programlisting role="php">
<![CDATA[
PEAR::setErrorHandling(PEAR_ERROR_CALLBACK, "my_error_handler");
]]>
      </programlisting>
	 </informalexample>
	</para>
	<para>
	 Here is an example of how you can switch back and forth
	 without specifying the callback function again:
	 <informalexample>
	  <programlisting role="php">
<![CDATA[
PEAR::setErrorHandling(PEAR_ERROR_CALLBACK, "my_function_handler");
do_some_stuff();
PEAR::setErrorHandling(PEAR_ERROR_DIE);
do_some_critical_stuff();
PEAR::setErrorHandling(PEAR_ERROR_CALLBACK);
// now we're back to using my_function_handler again
]]>
</programlisting>
	 </informalexample>
	</para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>
  </refentry>

  
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear.pear.constants">
   <refnamediv>
    <refname>Constants</refname>
    <refpurpose>Predefined Constants</refpurpose>
   </refnamediv>
   <refsection xml:id="core.pear.pear.constants.pear-error-callback"><info><title><constant>PEAR_ERROR_CALLBACK</constant></title></info>
    
    <simpara>
     PEAR error handling related.
    </simpara>
    <para>
     See <link xmlns="http://docbook.org/ns/docbook" linkend="core.pear.pear-error"><classname>PEAR_Error</classname></link>,
     <link linkend="core.pear.pear.seterrorhandling"><function>
       setErrorHandling</function></link>
    </para>
   </refsection>         
   <refsection xml:id="core.pear.pear.constants.pear-error-die"><info><title><constant>PEAR_ERROR_DIE</constant></title></info>
    
    <simpara>
     PEAR error handling related.
    </simpara>
    <para>
     See <link xmlns="http://docbook.org/ns/docbook" linkend="core.pear.pear-error"><classname>PEAR_Error</classname></link>,
     <link linkend="core.pear.pear.seterrorhandling"><function>
       setErrorHandling</function></link>
    </para>
   </refsection>  
   <refsection xml:id="core.pear.pear.constants.pear-error-print"><info><title><constant>PEAR_ERROR_PRINT</constant></title></info>
    
    <simpara>
     PEAR error handling related.
    </simpara>
    <para>
     See <link xmlns="http://docbook.org/ns/docbook" linkend="core.pear.pear-error"><classname>PEAR_Error</classname></link>,
     <link linkend="core.pear.pear.seterrorhandling"><function>
       setErrorHandling</function></link>
    </para>
   </refsection>         
   <refsection xml:id="core.pear.pear.constants.pear-error-return"><info><title><constant>PEAR_ERROR_RETURN</constant></title></info>
    
    <simpara>
     PEAR error handling related.
    </simpara>
    <para>
     See <link xmlns="http://docbook.org/ns/docbook" linkend="core.pear.pear-error"><classname>PEAR_Error</classname></link>,
     <link linkend="core.pear.pear.seterrorhandling"><function>
       setErrorHandling</function></link>
    </para>
   </refsection>      
   <refsection xml:id="core.pear.pear.constants.pear-error-trigger"><info><title><constant>PEAR_ERROR_TRIGGER</constant></title></info>
    
    <simpara>
     PEAR error handling related.
    </simpara>
    <para>
     See <link xmlns="http://docbook.org/ns/docbook" linkend="core.pear.pear-error"><classname>PEAR_Error</classname></link>,
     <link linkend="core.pear.pear.seterrorhandling"><function>
       setErrorHandling</function></link>
    </para>
   </refsection>   
  </refentry>
  
  
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear.pear.pear">
   <refnamediv>
    <refname>PEAR::PEAR()</refname>
    <refpurpose>constructor (package developer related)</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>void <function>PEAR::PEAR</function></funcdef>
      <paramdef choice="opt">
       string <parameter>
        $errorClass = PEAR_Error</parameter>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
   </refsynopsisdiv>
   <refsection xml:id="core.pear.pear.pear.desc">
    <title xmlns="http://docbook.org/ns/docbook">Description</title>
    <para>
     If you want to use the deconstructor functionality provide by PEAR,
     you have to call <function>$this-&gt;PEAR</function> in the 
     constructor of <emphasis>your</emphasis> class.
    </para>
   </refsection>   
   <refsection xml:id="core.pear.pear.pear.parameter">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <itemizedlist>
      <listitem>
       <para>
        <parameter>string $errorClass</parameter> - the name of the error class
        to use.
       </para>
      </listitem>      
     </itemizedlist>
    </para>
   </refsection>   
   <refsection xml:id="core.pear.pear.pear.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can be called
statically.</simpara>    
   </refsection>      
  </refentry>
    
  
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear.pear.-pear">
   <refnamediv>
    <refname>PEAR::_PEAR()</refname>
    <refpurpose>Deconstructor (package developer related)</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>void <function>PEAR::_PEAR</function></funcdef>
      <paramdef choice="req">
      </paramdef>
     </funcprototype>
    </funcsynopsis>
   </refsynopsisdiv>
   <refsection xml:id="core.pear.pear.-pear.desc">
    <title xmlns="http://docbook.org/ns/docbook">Description</title>
    <para>
     Does nothing right now,
     but is included for forward compatibility, so subclass
     destructors should always call it.      
    </para>
   </refsection>   
  </refentry>
      
  
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear.pear.getstaticproperty">
   <refnamediv>
    <refname>PEAR::getStaticProperty()</refname>
    <refpurpose>handle static properties (package developer related)</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>mixed <function>&amp;PEAR::getStaticProperty</function></funcdef>
      <paramdef choice="req">
       string <parameter>$class</parameter>
      </paramdef>
      <paramdef choice="req">
       string <parameter>$var</parameter>
      </paramdef>      
     </funcprototype>
    </funcsynopsis>
   </refsynopsisdiv>
   <refsection xml:id="core.pear.pear.getstaticproperty.desc">
    <title xmlns="http://docbook.org/ns/docbook">Description</title>
    <para>
     If you have a class that's mostly/entirely static, and you need static
     properties, you can use this method to simulate them. Eg. in your method(s)
     do this: 
     <programlisting role="php">
     <![CDATA[
     $myVar = &PEAR::getStaticProperty('myVar');
     ]]>
    </programlisting>
     You <emphasis>must</emphasis> use a reference, or they will not persist!
    </para>
   </refsection>   
   <refsection xml:id="core.pear.pear.getstaticproperty.parameter">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <itemizedlist>
      <listitem>
       <para>
        <parameter>string $class</parameter> - the name of your class, where you
        call <function>getStaticProperty</function>
       </para>
      </listitem>
      <listitem>
       <para>
        <parameter>string $var</parameter> the variable to retrieve.
       </para>
      </listitem>            
     </itemizedlist>
    </para>
   </refsection>   
   <refsection xml:id="core.pear.pear.getstaticproperty.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>
    <para>
     <parameter>mixed</parameter> -
     A reference to the variable. If not set, it will be 
     auto initialised to <constant xmlns="http://docbook.org/ns/docbook">NULL</constant>.
    </para>
   </refsection>      
   <refsection xml:id="core.pear.pear.getstaticproperty.example">
    <title xmlns="http://docbook.org/ns/docbook">Example</title>
    <example><info><title>Using <function>getStaticProperty</function></title></info>
     
     <programlisting role="php">
      <![CDATA[
<?php

require_once 'PEAR.php';

class myClass {

function setValue( $set) 
{
 $foo = &PEAR::getStaticProperty('myClass', "foo");
 $foo = $set;
}

function view()
{
 print PEAR::getStaticProperty('myClass', "foo");
}

}

myClass::setValue('value = foo');
myClass::view();
?>      
      ]]>
     </programlisting>
     <para>
      This would print
     </para>       
     <programlisting>
      value = foo
     </programlisting>
    </example>
   </refsection>         
  </refentry>

  
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear.pear.registershutdownfunc">
   <refnamediv>
    <refname>PEAR::registerShutdownFunc()</refname>
    <refpurpose>set a shutdown function for static classes (package developer related)</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>void <function>PEAR::registerShutdownFunc</function></funcdef>
      <paramdef choice="req">
       array <parameter>$func</parameter>
      </paramdef>
      <paramdef choice="opt">
       array <parameter>$var = array()</parameter>
      </paramdef>      
     </funcprototype>
    </funcsynopsis>
   </refsynopsisdiv>
   <refsection xml:id="core.pear.pear.registershutdownfunc.desc">
    <title xmlns="http://docbook.org/ns/docbook">Description</title>
    <para>
     The indicated function is called, before the PHP interpreter will
     be finished.
    </para>
   </refsection>   
   <refsection xml:id="core.pear.pear.registershutdownfunc.parameter">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <itemizedlist>
      <listitem>
       <para>
        <parameter>array $func</parameter> - the name of the class and of the
        function to ccore.
       </para>
      </listitem>
      <listitem>
       <para>
        <parameter>array $var</parameter> - possible required function
        parameters. The parameters are handed over to the function in accordance with their
        succession of the array.
       </para>
      </listitem>            
     </itemizedlist>
    </para>
   </refsection>   
   <refsection xml:id="core.pear.pear.registershutdownfunc.example">
    <title xmlns="http://docbook.org/ns/docbook">Example</title>
    <example><info><title>Using <function>registerShutdownFunc</function></title></info>
     
     <programlisting role="php">
      <![CDATA[
<?php

require_once 'PEAR.php';

class myClass {

function myClass() 
{
 PEAR::registerShutdownFunc(array('myClass', 'shutdown'), 
                            array('param1', 'param2'));
}

function shutdown( $param1, $param2)
{
 // do something before we will die
}

}

?>      
      ]]>
     </programlisting>
    </example>
   </refsection>         
  </refentry>

  
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear.pear.iserror">
   <refnamediv>
    <refname>PEAR::isError()</refname>
    <refpurpose>checks for a <classname>PEAR_Error</classname> object</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>boolean <function>PEAR::isError</function></funcdef>
      <paramdef choice="req">
       mixed <parameter>$data</parameter>
      </paramdef>
      <paramdef choice="opt">
       mixed <parameter>$msgcode</parameter>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
   </refsynopsisdiv>
   <refsection xml:id="core.pear.pear.iserror.desc">
    <title xmlns="http://docbook.org/ns/docbook">Description</title>
    <para>
     <function>isError</function> examines whether a variable is a
     <classname>PEAR_Error</classname> object and - optional - 
     contains a specific error message or code.       
    </para>
   </refsection>   
   <refsection xml:id="core.pear.pear.iserror.parameter">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">mixed</type>
        <parameter>$data</parameter>
       </term>
       <listitem>
        <para>
         variable to check
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">mixed</type>
        <parameter>$msgcode</parameter>
       </term>
       <listitem>
        <para>
         additional error message or error code to check
        </para>
       </listitem>
      </varlistentry>      
     </variablelist>
    </para>
   </refsection>   
   <refsection xml:id="core.pear.pear.iserror.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>
    <para>
     <parameter>mixed</parameter> - returns <constant xmlns="http://docbook.org/ns/docbook">TRUE</constant>, if the variable was a
     <classname>PEAR_Error</classname> and, if given, contains 
     <parameter>$msgcode</parameter> 
    </para>
   </refsection>      
  </refentry>

  
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear.pear.raiseerror">
   <refnamediv>
    <refname>PEAR::raiseError()</refname>
    <refpurpose>Create a new <link xmlns="http://docbook.org/ns/docbook" linkend="core.pear.pear-error"><classname>PEAR_Error</classname></link> object and optionally specify error-handling instructions</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>PEAR_Error <function>PEAR::raiseError</function></funcdef>
      <paramdef choice="req">
       mixed <parameter>$message</parameter>
      </paramdef>
      <paramdef choice="opt">
       int <parameter>$code</parameter>
      </paramdef>
      <paramdef choice="opt">
       int <parameter>$mode</parameter>
      </paramdef>
      <paramdef choice="opt">
       int|array <parameter>$options</parameter>
      </paramdef>
      <paramdef choice="opt">
       mixed <parameter>$userinfo</parameter>
      </paramdef>
      <paramdef choice="opt">
       string <parameter>$error_class</parameter>
      </paramdef>
      <paramdef choice="opt">
       boolean <parameter>$skipmsg</parameter>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
   </refsynopsisdiv>
   <refsection xml:id="core.pear.pear.raiseerror.desc">
    <title xmlns="http://docbook.org/ns/docbook">Description</title>
    <para>
     <function>raiseError</function>        
    </para>
   </refsection>   
   <refsection xml:id="core.pear.pear.raiseerror.parameter">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
        <parameter>$message</parameter>
       </term>
       <listitem>
        <para>
         Error message string or PEAR_Error object.
         The default message is <literal>unknown error</literal>
         if left blank.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">integer</type>
        <parameter>$code</parameter>
       </term>
       <listitem>
        <para>
         Error code.  It is recommended to use an error code for even the simplest
         errors, in order to simplify error handling and processing.
        </para>
       </listitem>
      </varlistentry>      
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">integer</type>
        <parameter>$mode</parameter>
       </term>
       <listitem>
        <para>
         Error mode.  This is one of <constant>PEAR_ERROR_RETURN</constant>,
         <constant>PEAR_ERROR_PRINT</constant>,
         <constant>PEAR_ERROR_TRIGGER</constant>,
         <constant>PEAR_ERROR_DIE</constant>,
         <constant>PEAR_ERROR_CALLBACK</constant>, or
         <constant>PEAR_ERROR_EXCEPTION</constant>.  See <link linkend="core.pear.pear.seterrorhandling"><function>setErrorHandling</function></link>
         for detailed information and examples of the meaning of these constants.
        </para>
       </listitem>
      </varlistentry>      
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">mixed</type>
        <parameter>$options</parameter>
       </term>
       <listitem>
        <para>
         Error options.  This depends on the value of <parameter>$mode</parameter>,
         and is documented in <link linkend="core.pear.pear.seterrorhandling"><function>setErrorHandling</function></link>.
        </para>
       </listitem>
      </varlistentry>      
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">mixed</type>
        <parameter>$userinfo</parameter>
       </term>
       <listitem>
        <para>
         Optional user information.  This can be used to store any error-specific
         information, and has an unspecified format.
        </para>
       </listitem>
      </varlistentry>      
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
        <parameter>$error_class</parameter>
       </term>
       <listitem>
        <para>
         Error class name to use as the error object.  The default error class
         is <link xmlns="http://docbook.org/ns/docbook" linkend="core.pear.pear-error"><classname>PEAR_Error</classname></link>.  Use this parameter to specify another class
         to use, such as a custom class extending <link xmlns="http://docbook.org/ns/docbook" linkend="core.pear.pear-error"><classname>PEAR_Error</classname></link>
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">boolean</type>
        <parameter>$skipmsg</parameter>
       </term>
       <listitem>
        <para>
         Use this parameter if you are using a custom class that does not
         accept an error message in its constructor.  <emphasis>Never</emphasis>
         use this parameter without the <parameter>$error_class</parameter>
         parameter - it will not work.
        </para>
       </listitem>
      </varlistentry>      
     </variablelist>
    </para>
   </refsection>   
   <refsection xml:id="core.pear.pear.raiseerror.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>
    <para>
     A <link xmlns="http://docbook.org/ns/docbook" linkend="core.pear.pear-error"><classname>PEAR_Error</classname></link> object is returned, unless PEAR_ERROR_DIE terminates
     execution or a PEAR_ERROR_EXCEPTION is never handled.
    </para>
   </refsection>      
  </refentry>

  
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear.pear.seterrorhandling">
   <refnamediv>
    <refname>PEAR::setErrorHandling()</refname>
    <refpurpose>sets handling of errors generated through PEAR packages</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>void <function>PEAR::setErrorHandling</function></funcdef>
      <paramdef choice="opt">
       integer <parameter>$mode</parameter>
       <initializer>null</initializer>
      </paramdef>
      <paramdef choice="opt">
       mixed <parameter>$options</parameter>
       <initializer>null</initializer>
      </paramdef>      
     </funcprototype>
    </funcsynopsis>
   </refsynopsisdiv>
   <refsection xml:id="core.pear.pear.seterrorhandling.desc">
    <title xmlns="http://docbook.org/ns/docbook">Description</title>
    <para>
     <function>setErrorHandling</function> can be invoked as both a standard
     object method ($obj-&gt;setErrorHandling) and as a static method
     (PEAR::setErrorHandling).  If called
     statically, <function>PEAR::setErrorHandling</function> sets the default
     error handling behaviour for all
     PEAR objects (global error handling behaviour). If called as an object method,
     <function>$obj-&gt;setErrorHandling</function> sets
     the default error handling for only that object (local error handling behaviour).
    </para>
   </refsection>   
   <refsection xml:id="core.pear.pear.seterrorhandling.parameter">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <itemizedlist>
      <listitem>
       <para>
        <parameter>integer $mode</parameter> - one of the following constants
        <itemizedlist>
         <listitem>
          <para>
           <constant>PEAR_ERROR_RETURN</constant> If an error occurs, a 
           <link xmlns="http://docbook.org/ns/docbook" linkend="core.pear.pear-error"><classname>PEAR_Error</classname></link> is returned from the error-generation
           method (normally <link linkend="core.pear.pear.raiseerror"><function>raiseError</function></link>.)
          </para>
         </listitem>
         <listitem>
          <para>
           <constant>PEAR_ERROR_PRINT</constant> Like <constant>
           PEAR_ERROR_RETURN</constant>, but an error message will be 
           printed additionally.
          </para>
         </listitem>         
         <listitem>
          <para>
           <constant>PEAR_ERROR_TRIGGER</constant> Like <constant>
           PEAR_ERROR_RETURN</constant>, but the PHP builtin-function
           <function>trigger_error</function> will be called in PEAR_Error's
           constructor with the error message.
          </para>
         </listitem>         
         <listitem>
          <para>
           <constant>PEAR_ERROR_DIE</constant> The script will terminate and
           an error message will be printed on instantiation of a PEAR_Error.
          </para>
         </listitem>         
         <listitem>
          <para>
           <constant>PEAR_ERROR_CALLBACK</constant> If a error occurs, the
           callback passed to <parameter>$options</parameter> is called.
          </para>
         </listitem>                  
         <listitem>
          <para>
           <constant>PEAR_ERROR_EXCEPTION</constant> If Zend Engine 2 is present,
           then an exception will be thrown using the <link xmlns="http://docbook.org/ns/docbook" linkend="core.pear.pear-error"><classname>PEAR_Error</classname></link> object.
          </para>
         </listitem>         
        </itemizedlist>         
       </para>
      </listitem>
      <listitem>
       <para>
        <parameter>mixed $options</parameter> - the value for <parameter>$options</parameter>
        depends on <parameter>$mode</parameter>
        <itemizedlist>
         <listitem>
          <para>
           <constant>PEAR_ERROR_PRINT</constant> and 
           <constant>PEAR_ERROR_DIE</constant> support
           an optional <function>printf</function> format string used 
           when printing the error message.  This format string should contain
           a single %s, which will be used to insert the error message into the
           string.  Use the string to enclose the error message with other
           useful information not included in the error message prefix or
           error message.
          </para>
         </listitem>
         <listitem>
          <para>
           <constant>PEAR_ERROR_TRIGGER</constant> requires an user error 
           level constant used by <function>trigger_error</function> (possible constants: <constant>E_USER_NOTICE</constant>, 
           <constant>E_USER_WARNING</constant> or 
           <constant>E_USER_ERROR</constant>).  Note that if the error constant
           is not one of these valid error constants, a PHP warning will be
           triggered.
          </para>
         </listitem>
         <listitem>
          <para>
           <constant>PEAR_ERROR_CALLBACK</constant> The callback must be a function
           name in the format described in the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.php.net/manual/language.pseudo-types.php">Pseudo-Type</link>
           section of the PHP manual (either a string, or an array). The callback must accept a single
           parameter, the <link xmlns="http://docbook.org/ns/docbook" linkend="core.pear.pear-error"><classname>PEAR_Error</classname></link> object generated by an error condition.
           Note that if the callback is not a valid callback, a PHP warning will
           be triggered.
          </para>
         </listitem>                  
        </itemizedlist>         
       </para>
      </listitem>      
     </itemizedlist>
    </para>
    <para>
     Here's an example of a few ways to use setErrorHandling:
     <programlisting role="php">
<![CDATA[
<?php
require_once 'PEAR.php';
// dummy error constant for this example
define('MYCLASS_ERROR_CODE', 1);

// demonstration of default global error handling
// in this case, all PEAR Errors will trigger a PHP warning
PEAR::setErrorHandling(PEAR_ERROR_TRIGGER, E_USER_WARNING);
// Note that the file and line number will be in the constructor of PEAR_Error
// in PEAR.php
PEAR::raiseError('test warning', MYCLASS_ERROR_CODE);

// this error specifies a mode, and overrides the default global error handling
$e = PEAR::raiseError('return only', MYCLASS_ERROR_CODE, PEAR_ERROR_RETURN);

PEAR::setErrorHandling(PEAR_ERROR_PRINT, "Gronk error: %s<br />\n");

// prints "Gronk error: test warning<br />\n"
PEAR::raiseError('test warning', MYCLASS_ERROR_CODE);

/**
 * Fake class to demonstrate error handling
 * @package myClass
 */
class myClass extends PEAR {
    /**
     * Demonstration of default local error handling
     */
    function myClass()
    {
        // object method callback
        $this->setErrorHandling(PEAR_ERROR_CALLBACK, array(&$this, 'handleErr'));
        // prints "custom handler...is working"
        PEAR::raiseError('custom handler', MYCLASS_ERROR_CODE);
        // static class method callback
        $this->setErrorHandling(PEAR_ERROR_CALLBACK,
            array('myClass', 'handleErrStatic'));
        PEAR::raiseError('custom handler', MYCLASS_ERROR_CODE);
        // function callback
        $this->setErrorHandling(PEAR_ERROR_CALLBACK, 'standardCallback');
        PEAR::raiseError('custom handler', MYCLASS_ERROR_CODE);
    }
    
    /**
     * Callback set by the constructor
     * @param PEAR_Error The error object
     */
    function handleErr($error)
    {
        $this->lastError = $error->getMessage();
        print $error->getMessage() . "...is working\n";
    }
    
    /**
     * Static callback set by the constructor
     *
     * Note that in PHP 5, $this is not set if the method is declared with
     * the "static" access modifier.  In PHP 4, $this is set, but is not
     * set to the myClass object, so don't use it!
     * @param PEAR_Error The error object
     * @static
     */
    function handleErrStatic($error)
    {
        print 'static ' . $error->getMessage() . "...is working\n";
    }
}

/**
 * @param PEAR_Error The error object
 */
function standardCallback($error)
{
    print 'normal function callback: ' . $error->getMessage();
}
// This causes the printing of three messages through error callbacks:
// "custom handler...is working"
// "static custom handler... is working"
// "normal function callback: custom handler"
$mine = new myClass;

PEAR::setErrorHandling(PEAR_ERROR_DIE);
// terminates the script with the error message "oops"
PEAR::raiseError('oops', MYCLASS_ERROR_CODE);
?>
]]>
     </programlisting>
    </para>
   </refsection>   
  </refentry>
  
  
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear.pear.expecterror">
   <refnamediv>
    <refname>PEAR::expectError()</refname>
    <refpurpose>
     add an error code for non-disabling temporary error handling
    </refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>           
     <funcsynopsisinfo>
      require_once 'PEAR.php';
     </funcsynopsisinfo>     
     <funcprototype>
      <funcdef>integer <function>PEAR::expectError</function></funcdef>
      <paramdef choice="opt">
       mixed <parameter>$errorCode = '*'</parameter>
      </paramdef>
     </funcprototype>        
    </funcsynopsis>
   </refsynopsisdiv>
   <refsection xml:id="core.pear.pear.expecterror.desc">
    <title xmlns="http://docbook.org/ns/docbook">Description</title>
    <para>
     This method is used to tell which errors you expect to get.
     Expected errors are always returned with error mode
     <constant>PEAR_ERROR_RETURN</constant>.  
     Expected error codes are stored in a stack,
     and this method pushes a new element onto it.  The list of
     expected errors are in effect until they are popped off the
     stack with the <function>popExpect</function> method.    
    </para>
   </refsection>
   <refsection xml:id="core.pear.pear.expecterror.parameter">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <itemizedlist>
      <listitem>
       <para>
        <parameter>mixed $errorCode</parameter> -
        the expected 
        <classname>PEAR_Error</classname> error code or
        an array of error codes. If set to <parameter>'*'</parameter>
        every error is expected.
       </para>
      </listitem>
     </itemizedlist>    
    </para>
   </refsection>
   <refsection xml:id="core.pear.pear.expecterror.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>    
    <para>
     <parameter>integer</parameter> - the size of the error code stack.
    </para>
   </refsection>   
   <refsection xml:id="core.pear.pear.expecterror.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>   
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
   <refsection xml:id="core.pear.pear.expecterror.see">
    <title xmlns="http://docbook.org/ns/docbook">See</title>        
    <para>
     <link linkend="core.pear.pear.popexpect">
      <function>popExpect</function>
     </link>
    </para>
   </refsection>   
  </refentry>
    
  
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear.pear.popexpect">
   <refnamediv>
    <refname>PEAR::popExpect()</refname>
    <refpurpose>
    removes the last error code for non-disabling temporary error handling
    </refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>           
     <funcsynopsisinfo>
      require_once 'PEAR.php';
     </funcsynopsisinfo>     
     <funcprototype>
      <funcdef>mixed <function>PEAR::popExpect</function></funcdef>
      <paramdef choice="req">
      </paramdef>
     </funcprototype>        
    </funcsynopsis>
   </refsynopsisdiv>
   <refsection xml:id="core.pear.pear.popexpect.desc">
    <title xmlns="http://docbook.org/ns/docbook">Description</title>
    <para>
     This method pops one element off the expected error codes
     stack.
    </para>
   </refsection>
   <refsection xml:id="core.pear.pear.popexpect.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>    
    <para>
     <parameter>mixed</parameter> -
     the removed error code or array of error
     codes
    </para>
   </refsection>   
   <refsection xml:id="core.pear.pear.popexpect.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>   
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
   <refsection xml:id="core.pear.pear.popexpect.see">
    <title xmlns="http://docbook.org/ns/docbook">See</title>        
    <para>
     <link linkend="core.pear.pear.expecterror">
      <function>expectError</function>
     </link>
    </para>
   </refsection>   
  </refentry>
      
  
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear.pear.loadextension">
   <refnamediv>
    <refname>PEAR::loadExtension()</refname>
    <refpurpose>OS independent PHP extension load</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>boolean <function>PEAR::loadExtension</function></funcdef>
      <paramdef choice="req">
       string <parameter>$ext</parameter>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
   </refsynopsisdiv>
   <refsection xml:id="core.pear.pear.loadextension.desc">
    <title xmlns="http://docbook.org/ns/docbook">Description</title>
    <para>
     Loads an extension by name
    </para>
   </refsection>   
   <refsection xml:id="core.pear.pear.loadextension.parameter">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
        <parameter>$ext</parameter>
       </term>
       <listitem>
        <para>
         The <emphasis>case-sensitive</emphasis> name of the PHP extension
         without filename suffix or <filename>php_</filename> prefix.
        </para>
       </listitem>
      </varlistentry>

     </variablelist>
    </para>
   </refsection>   
   <refsection xml:id="core.pear.pear.loadextension.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>
    <para>
     <parameter>boolean</parameter> - returns <constant xmlns="http://docbook.org/ns/docbook">TRUE</constant>, if
     extension could be loaded
    </para>
   </refsection>      
   <refsection xml:id="core.pear.pear.loadextension.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can be called
statically.</simpara>     
   </refsection>   
   <refsection xml:id="core.pear.pear.loadextension.exmaple">
    <title xmlns="http://docbook.org/ns/docbook">Example</title>
    <example><info><title>Loading the domxml-extension</title></info>
     
     <programlisting role="php">
     <![CDATA[
if(!PEAR::loadExtension("domxml")) {
 echo 'Could not load DomXML-Extension!';
 exit();
}
]]>
     </programlisting>
    </example>
   </refsection>
  </refentry>

 </section>

 
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear.pear-exception"><info><title>PEAR_Exception - PHP 5 and versions above</title><titleabbrev>PEAR_Exception</titleabbrev></info>
 
 
 <para>
  <classname>PEAR_Exception</classname> is the recommended error handling solution for PHP 5-based
  packages in PEAR.  PEAR_Exception is a lightweight wrapper above the
  built-in <classname>Exception</classname> class in PHP 5 that provides the
  ability to specify causes for errors, register observers, and many more
  features.
 </para>
<!-- Examples should always show recommended practice
 <para>Example usage (demonstration only, not recommended practice):
  <programlisting role="php">
<![CDATA[
<?php
require_once 'PEAR/Exception.php';
class MyPackage_Exception extends PEAR_Exception {}
try {
    throw new PEAR_Exception('exception 1');
} catch (MyPackage_Exception $e) {
	echo 'this is not executed';
} catch (PEAR_Exception $e) {
	echo 'this is executed';
}
try {
    throw new MyPackage_Exception('exception 2');
} catch (MyPackage_Exception $e) {
	echo 'this is executed';
} catch (PEAR_Exception $e) {
	echo 'this is not executed';
}
?>
]]>
  </programlisting>
 </para>
 -->
 <para>
  Exceptions in general should be used only for exceptional circumstances - for
  error conditions that require termination of execution.  PEAR_Exception should
  mainly be used for transmitting error information outside the existing package,
  and not for normal flow control.  Use <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.php.net/Control+Structures">
  Control Structures</link> in favor of exceptions wherever possible.
 </para>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear.pear-exception.intro">
 <refnamediv>
  <refname>
   Using PEAR_Exception for advanced error handling in PHP 5+
  </refname>
  <refpurpose>
   Using PEAR_Exception
  </refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <info>
   <author><personname><firstname>Gregory</firstname><surname>Beaver</surname></personname><personblurb><para>cellog@php.net</para></personblurb></author>
   <copyright>
    <year>2006</year>
    <holder>Gregory Beaver</holder>
   </copyright>
   <releaseinfo>PEAR_Exception PEAR 1.5.0a1</releaseinfo>
  </info>
  <simpara>Introduction to the usage of PEAR_Exception</simpara>
 </refsynopsisdiv>
 <refsection xml:id="core.pear.pear-exception.intro.intro"><info><title>Introduction</title></info>
  
  <para>
   This class is available as part of the
   <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://pear.php.net/package/pear">PEAR package</link>.
   Features include:
   <itemizedlist>
    <listitem>
     <para>
      Nestable exceptions (<programlisting role="php"><![CDATA[
      <?php throw new PEAR_Exception($msg, $prev_exception); ?>]]></programlisting>)
     </para>
    </listitem>
    <listitem>
     <para>
      Subject/Observer pattern, triggered when an exception is instantiated
     </para>
    </listitem>
    <listitem>
     <para>
      Clear, detailed and attractively formatted error messages
     </para>
    </listitem>
    <listitem>
     <para>
      Extra context information available compared to built-in Exception.
      For instance, a cause of the exception (PEAR_Error/PEAR_ErrorStack/another
      Exception).
     </para>
    </listitem>
    <listitem>
     <para>
      Exception cause can be a PEAR_Error object, PEAR_Exception object or an array of mixed
      PEAR_Exceptions/PEAR_ErrorStack warnings
     </para>
    </listitem>
    <listitem>
     <para>
      callbacks for specific exception classes and their children
     </para>
    </listitem>
   </itemizedlist>
  </para>
  <para>
   Usage example:
   <programlisting role="php">
    <![CDATA[
<?php
require_once 'PEAR/Exception.php';

class Test {
	function foo() {
		throw new PEAR_Exception('Error Message', ERROR_CODE);
    }
}

function myLogger($pear_exception) {
    echo $pear_exception->getMessage();
}
// each time a exception is thrown the 'myLogger' will be called
// (its use is completely optional)
PEAR_Exception::addObserver('myLogger');
$test = new Test;
try {
    $test->foo();
} catch (PEAR_Exception $e) {
    print $e;
}
?>
    ]]>
   </programlisting>
  </para>
  <para>
   API documentation is documented in the documentation for the PEAR package
   generated by phpDocumentor.  The class is very simple, examine the source
   in the PEAR package to get a better idea of how it works.
  </para>
 </refsection>
</refentry>

</section>

 
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear.pear-errorstack"><info><title>PEAR_ErrorStack</title><titleabbrev>PEAR_ErrorStack</titleabbrev></info>
 
 
 <para>
  <classname>PEAR_ErrorStack</classname> is an experimental error raising and handling implementation for PEAR that is designed
  to replace PEAR_Error when it has stabilized.  PEAR_ErrorStack is both backwards compatible with <classname>PEAR_Error</classname>
  and forward compatible with PHP 5's <classname>PEAR_Exception</classname> class.  There are many other features, all described
  in the Introduction.
 </para>
 <para>Usage:
  <programlisting role="php-highlighted">
1      // global error stack
2      $global_stack = &amp;PEAR_ErrorStack::<link linkend="core.pear.pear-errorstack.singleton">singleton</link>('MyPackage');
3      // local error stack
4      $local_stack = new <link linkend="core.pear.pear-errorstack.pear-errorstack">PEAR_ErrorStack</link>('MyPackage');
   </programlisting>
 </para>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear.pear-errorstack.intro">
 <refnamediv>
  <refname>
   Introduction to using PEAR_ErrorStack for advanced error handling
  </refname>
  <refpurpose>
   Using PEAR_ErrorStack to do both simple and advanced error handling
  </refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <info>
   <author><personname><firstname>Gregory</firstname><surname>Beaver</surname></personname><personblurb><para>cellog@php.net</para></personblurb></author>
   <copyright>
    <year>2003</year>
    <year>2004</year>
    <year>2005</year>
    <year>2006</year>
    <holder>Gregory Beaver</holder>
   </copyright>
   <releaseinfo>PEAR_ErrorStack 1.3.2 (beta)</releaseinfo>
  </info>
  <simpara>Introduction to the usage of PEAR_ErrorStack</simpara>
 </refsynopsisdiv>
 <refsection xml:id="core.pear.pear-errorstack.intro.intro"><info><title>Introduction</title></info>
  
  <para>
   This class is available as part of the
   <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://pear.php.net/package/pear">PEAR package</link>.
   Features include:
   <itemizedlist>
    <listitem><para>Fully unit-tested and documented</para></listitem>
    <listitem>
     <para>
      blazingly fast - blows PEAR_Error out of the water
     </para>
    </listitem>
    <listitem><para>Package-specific errors</para></listitem>
    <listitem>
     <para>
      Error levels (notice/warning/error/exception)
     </para>
    </listitem>
    <listitem>
     <para>
      Error context data is saved separate from error message
     </para>
    </listitem>
    <listitem>
     <para>
      Error cascading - parent errors can be specified
     </para>
    </listitem>
    <listitem>
     <para>
      Dynamic error message generation allows generation of multiple
      and distinct error messages from the same error object
     </para>
    </listitem>
    <listitem>
     <para>
      Sophisticated callbacks are available for error message generation,
      error context generation, and error handling functionality,
      see
      <link linkend="core.pear.pear-errorstack.intro.advanced.context">Error Context Display</link>,
      <link linkend="core.pear.pear-errorstack.intro.advanced.message">Custom Error Message Generation</link>,
      and
      <link linkend="core.pear.pear-errorstack.intro.advanced.callback">controlling error generation</link>
     </para>
    </listitem>
   </itemizedlist>
  </para>
  <para>
   PEAR_ErrorStack implements error raising and handling using a stack pattern.

   This has tremendous advantages over the PEAR_Error Implementation.

   PEAR_Error centralizes all error creation and handling in the
   constructor of the PEAR_Error object.

   Once an object has been created, all handling must have been completed,
   either through checking the return value of a method,
   or through a single global callback.

   In addition, it is nearly impossible to determine the source of an error,
   and the baggage of all of the PEAR base class's bulky,
   slow methods accompanies every error creation.
  </para>
  <para>
   <programlisting role="php">
<![CDATA[
<?php
// traditional PEAR_Error usage
require_once 'PEAR.php';
class myobj
{
    // there is no way to know where $err comes from
    function errorCallback($err)
    {
        $this->display($err->getMessage());
        $this->log($err->getMessage());
    }

    function log($msg)
    {
        error_log($msg, 3, 'somefile.log')
    }

    function display($msg)
    {
        echo $msg . '<br />';
    }
}

$myobj = new myobj;

// using a callback
PEAR::setErrorHandling(PEAR_ERROR_CALLBACK, array(&$myobj, 'errorCallback'));

$ret = SomePackage::doSomething();
if (PEAR::isError($ret)) {
    // do some handling - this error is also displayed and logged
}
PEAR::pushErrorHandling(PEAR_ERROR_RETURN);

$ret = SomePackage::doSomething();
if (PEAR::isError($ret)) {
    // do some handling - this error is not displayed or logged
}
PEAR::popErrorHandling();
?>]]>
   </programlisting>
  </para>
  <para>
   The PEAR_ErrorStack class has built in knowledge of the
   <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://pear.php.net/package/Log">Log</link> package,
   can easily differentiate and even automatically re-package errors
   with little to no difficulty.
  </para>
  <para>
   <programlisting role="php"><![CDATA[
<?php
// PEAR_ErrorStack error handling
require_once 'PEAR/ErrorStack.php';
require_once 'Log.php';
define('MYPACKAGE_ERROR_DBERROR', 1);
class myobj
{
    var $_stack;
    function myobj()
    {
        $this->_stack = &PEAR_ErrorStack::singleton('MyPackage');
    }

    function errorCallback($err)
    {
        switch($err['package']){
            case 'MyPackage':
                // tell the error stack to log the error only
                // it will not be pushed onto the stack
                return PEAR_ERRORSTACK_LOG;
                break;
            case 'InternalDbPackage':
                // re-package these errors as a mypackage error fit
                // for enduser consumption
                $this->_stack->push(MYPACKAGE_ERROR_DBERROR, 'error',
                    array('dbmessage' => $err['message'],
                          'dbcode' => $err['code'],
                          'We are having Connection problems, please' .
                          'try again in a few moments'),
                    '', $err); // include the error as re-packaged
                // tell the internal DB error stack to ignore this error,
                // as if it never happened
                return PEAR_ERRORSTACK_IGNORE;
                break;
        } // switch
    }
}

$myobj = &new myobj;
// separate error stacks for my package, and the internal DB package
$dbstack = &PEAR_ErrorStack::singleton('InternalDbPackage');
$mystack = &PEAR_ErrorStack::singleton('MyPackage');
// set up a file log using PEAR::Log
$log = &Log::Factory('file', 'somefile.log', 'MyPackage error log');
$mystack->setLogger($log);
// set up a default log to use for all error stacks
PEAR_ErrorStack::setDefaultLogger($log);

// any errors returned by MyPackage are logged
$ret = SomePackage::doSomething();

// Note that $ret need not be checked for any error condition - errors are
// totally separate from code
if ($dbstack->hasErrors()) {
    var_dump($dbstack->getErrors();
}

// sets a default callback for all errors
PEAR_ErrorStack::setDefaultCallback(array(&$myobj, 'errorCallback'));

// any db errors are transparently repackaged as
// user-friendly MyPackage errors now
$ret = SomePackage::doSomething();

?>]]>
   </programlisting>
  </para>
  <para>
   Why write a new error-handling routine when
   <link linkend="core.pear.pear-error"><classname>PEAR_Error</classname></link>
   already exists?

   There are several problems with <classname>PEAR_Error</classname>.

   Although an error message is present in an error class,
   processing this error message automatically is excessively
   difficult for computers.

   In addition, the error message cannot easily be translated once it has been placed into
   the <classname>PEAR_Error</classname>.

   There is also no standard facility for
   storing error-related data in the error class.

   On top of error message-related issues,
   there is no way to automatically determine which package a
   <classname>PEAR_Error</classname> object comes from,
   or the severity of an error.

   Fatal
   errors look exactly the same as non-fatal errors.
  </para>
  <para>
   The largest flaw with <classname>PEAR_Error</classname> object is the
   single-error type design.

   Every <classname>PEAR_Error</classname> object is just a
   <classname>PEAR_Error</classname> object.

   There is no differentiating between the severity of an error, or its origin.

   The only way to determine the severity is to use
   PEAR_ERROR_TRIGGER and E_USER_NOTICE/E_USER_WARNING/E_USER_ERROR
   constants from php's
   <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.php.net/manual-lookup.php?pattern=trigger_error">trigger_error</link>.

   But using this functionality does not justify 900 lines of
   code, simply because trigger_error() is built into PHP itself!
  </para>
  <para>
   Now, to start using your newly created error objects,
   change all of your
   <function>PEAR::raiseError</function>
   or <function>PEAR::throwError</function>
   calls from this...
  </para>
  <para>
   <programlisting role="php"><![CDATA[
<?php
require_once 'PEAR.php';
// old way:
$error_specific_info = 'bad';
$e = PEAR::raiseError("error message - very " . $error_specific_info .
    " way to do things", MYPACKAGE_ERROR_FOO);
// another old way:
$e = PEAR::throwError("error message - very " . $error_specific_info .
    " way to do things", MYPACKAGE_ERROR_FOO);
?>]]>
   </programlisting>
  </para>
  <para>...to something like this:</para>
  <para>
   <programlisting role="php"><![CDATA[
<?php
require_once 'PEAR/ErrorStack.php';
// new way
// version 1: stack instance access
$stack = &PEAR_ErrorStack::singleton('MyPackage');
$stack->push(MYPACKAGE_ERROR_DBERROR, 'error',
    array('query' => $query, 'dsn' => $dsn),
    'Critical Database Error: Contact Administrator immediately');
// version 2: static singleton access (slightly slower)
PEAR_ErrorStack::staticPush('MyPackage', MYPACKAGE_ERROR_DBERROR, 'error',
    array('query' => $query, 'dsn' => $dsn),
    'Critical Database Error: Contact Administrator immediately');
?>]]>
   </programlisting>
  </para>
  <para>
   For basic use, this is all that is needed to use the
   PEAR_ErrorStack package in place of PEAR_Error.
  </para>
 </refsection>
 <refsection xml:id="core.pear.pear-errorstack.intro.advanced"><info><title>Advanced Features</title></info>
  
  <refsection xml:id="core.pear.pear-errorstack.intro.advanced.context"><info><title>Error Context Display</title></info>
   
   <para>
    In some cases, you may want to customize error generation.
    For instance, for many exceptions, it is useful to include file,
    line number,
    and class/function context information in order to trace an error.

    A default option is available which will be sufficient for most cases,
    and that is
    <link linkend="core.pear.pear-errorstack.getfileline"><function>PEAR_ErrorStack::getFileLine</function></link>.
   </para>
   <para>
    Not all package errors occur in the PHP source file.

    For instance, compiling template
    engines errors can occur in the template source files.

    Database errors can occur in the text of a query,
    or internal to the database server.

    Internet package errors can occur on another server.

    All of this information can be included in an error
    message using a context grabbing callback.
   </para>
   <para>
    <programlisting role="php"><![CDATA[
<?php
require_once 'PEAR/ErrorStack.php';
class DatabaseClass
{
    var $_dbError;
    var $_dbErrorMsg;
    var $_dbQuery;
    var $_dbPos;
    /**
     * Context grabber for the Database package
     * @param integer Error Code
     * @param array   Error parameters passed into {@link PEAR_ErrorStack::push()}
     * @param array   Output of debug_backtrace() (not used in this callback)
     */
    function getErrorContext($code, $params, $backtrace)
    {
        $context = array(
            'errorcode' => $this->_dbError,
            'errormsg' => $this->_dbErrorMsg,
            'query' => $this->_dbQuery,
            'pos' => $this->_dbPos,
        );
        return $context;
    }
}
$db = new DatabaseClass;
PEAR_ErrorStack::staticSetContextCallback('Database', array(&$db, 'getErrorContext'));
?>]]>
    </programlisting>
   </para>
   <para>
    The context information is formatted to be easily
    processed by an external application.

    If you wish context information to be in the error message,
    the error message callback should be used to add the information
    in a human-readable format to the error message, as described
    in the next section.
   </para>
  </refsection>
  <refsection xml:id="core.pear.pear-errorstack.intro.advanced.message"><info><title>Custom Error Message Generation</title></info>
   
   <para>
    There are three methods of PEAR_ErrorStack designed for
    use with generating error messages efficiently.

    To use them, you must do one of three things:
    <itemizedlist>
     <listitem>
      <para>
       Call
       <link linkend="core.pear.pear-errorstack.seterrormessagetemplate"><function>PEAR_ErrorStack::setErrorMessageTemplate</function></link>,
       and set an array mapping error codes to error message templates, like so:
      </para>
      <para>
       <programlisting role="php"><![CDATA[
<?php
define('ERROR_ONE', 1);
define('ERROR_TWO', 2);
define('ERROR_THREE', 3);
define('ERROR_FOUR', 4);
require_once 'PEAR/ErrorStack.php';
$stack = &PEAR_ErrorStack::singleton('mypackage');
$messages = array(
    ERROR_ONE => 'The gronk number %num% dropped a %thing%',
    ERROR_TWO => 'The %list% items were missing',
    ERROR_THREE => 'I like chocolate, how about %you%?',
    ERROR_FOUR => 'and a %partridge% in a pear %tree%',
);
$stack->setErrorMessageTemplate($messages);
?>]]>
       </programlisting>
      </para>
      <para>
       Substitution is done using
       <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.php.net/manual-lookup.php?pattern=str_replace">str_replace</link>,
       and is very simple.

       Basically, if a variable name is enclosed in percent signs (%), it will
       be replaced with the value passed in the associative array.

       If an array
      <programlisting role="php">array('varname' =&gt; 'value');</programlisting>
       is passed to either method, all occurrences of %varname% will be replaced
       by value.
      </para>
      <para>
       In addition, if values are objects, the methods will search for a method
       named "<function>__toString</function>" and if found,
       will use that to convert the object to a string.

       If an array of strings is passed in, they will be joined by commas.
       <programlisting role="php"><![CDATA[
<?php
array('varname' => array('first', 'second', 'third'));
// this will become 'first, second, third'
?>]]>
       </programlisting>
      </para>
     </listitem>
     <listitem>
      <para>
       Call
       <link linkend="core.pear.pear-errorstack.setmessagecallback"><function>PEAR_ErrorStack::setMessageCallback</function></link>,
       and set a custom error message generating function or method.

       This is probably the best option for the majority of complex situations,
       as it allows users to override or even extend the existing error
       message callback using
       <link linkend="core.pear.pear-errorstack.getmessagecallback"><function>PEAR_ErrorStack::getMessageCallback</function></link>.

       For example:
       <programlisting role="php"><![CDATA[
<?php
require_once 'PEAR/ErrorStack.php';
class foo
{
    var $_oldcallback;
    function callback(&$stack, $err)
    {
        $message = call_user_func_array($this->_oldcallback, array(&$stack, $err));
        $message .= "File " . $err['context']['file'];
        return $message;
    }
}
$a = new foo;
$stack = &PEAR_ErrorStack::singleton('otherpackage');
$a->_oldcallback = $stack->getMessageCallback('otherpackage');
$stack->setMessageCallback(array(&$a, 'callback'));
?>]]>
       </programlisting>
      </para>
     </listitem>
     <listitem>
      <para>
       Extend PEAR_ErrorStack with your own class, and override
       <link linkend="core.pear.pear-errorstack.geterrormessagetemplate"><function>PEAR_ErrorStack::getErrorMessageTemplate</function></link>
       or
       <link linkend="core.pear.pear-errorstack.geterrormessage"><function>PEAR_ErrorStack::getErrorMessage</function></link>.

       To guarantee that this class will be used by other packages/applications,
       use this code right after the class declaration:
      </para>
      <para>
       <programlisting role="php"><![CDATA[
<?php
PEAR_ErrorStack::singleton('mypackage', false, null, 'MyPEAR_ErrorStack');
?>]]>
       </programlisting>
      </para>
     </listitem>
    </itemizedlist>
   </para>
  </refsection>
  <refsection xml:id="core.pear.pear-errorstack.intro.advanced.callback"><info><title>Controlling error generation</title></info>
   
   <para>
    There are many scenarios in which fine-grained control over error raising
    is absolutely necessary.

    A generic error handling callback means that every single error
    raised will be handled in the same error callback.

    Although PEAR_ErrorStack is designed to operate with independent
    callbacks for each package, generic error handling is possible through the
    <link linkend="core.pear.pear-errorstack.staticpushcallback"><function>PEAR_ErrorStack::staticPushCallback</function></link>
    method.

    This is no different from PEAR_Error's
    PEAR_ERROR_CALLBACK error handling mode.
   </para>
   <para>
    PEAR_ErrorStack's real strength comes from the callback itself.

    PEAR_Error's callback has no actual effect on the error message -
    all error handling must happen in the callback method or function itself.

    PEAR_ErrorStack's callback can influence the error
    through the use of three constants:
    <itemizedlist>
     <listitem>
      <para>
       <link linkend="core.pear.pear-errorstack.constants.details.errorstack---php"><constant>PEAR_ERRORSTACK_IGNORE</constant></link>
      </para>
     </listitem>
     <listitem>
      <para>
       <link linkend="core.pear.pear-errorstack.constants.details.errorstack---php"><constant>PEAR_ERRORSTACK_PUSH</constant></link>
      </para>
     </listitem>
     <listitem>
      <para>
       <link linkend="core.pear.pear-errorstack.constants.details.errorstack---php"><constant>PEAR_ERRORSTACK_LOG</constant></link>
      </para>
     </listitem>
    </itemizedlist>
   </para>
   <para>
    PEAR_ERRORSTACK_IGNORE informs the stack to ignore the error, as if it never occurred.  The error will be
    neither logged, nor pushed on the stack.  It will, however, be returned from <link linkend="core.pear.pear-errorstack.push"><function>PEAR_ErrorStack::push</function></link>
   </para>
   <para>
    PEAR_ERRORSTACK_PUSH informs the stack to push the error onto the error stack, but not to log the error.
   </para>
   <para>
    PEAR_ERRORSTACK_LOG informs the stack not to push the error onto the error stack, but only to log the error.
   </para>
   <para>
    <programlisting role="php"><![CDATA[
<?php
define('ERROR_CODE_ONE',1);
define('ERROR_CODE_TWO',2);
define('ERROR_CODE_THREE',3);
require_once 'PEAR/ErrorStack.php';
require_once 'Log.php';
function somecallback($err)
{
    switch($err['code']){
        case ERROR_CODE_ONE:
                return PEAR_ERRORSTACK_IGNORE;
                break;
        case ERROR_CODE_TWO:
                return PEAR_ERRORSTACK_PUSH;
                break;
        case ERROR_CODE_THREE:
                return PEAR_ERRORSTACK_LOG;
                break;
    } // switch
}
$log = &Log::factory('display');
$stack = &PEAR_ErrorStack::singleton('mypackage');
$stack->setLogger($log);
$stack->pushCallback('somecallback');
$stack->push(ERROR_CODE_ONE);
$stack->push(ERROR_CODE_TWO);
$stack->push(ERROR_CODE_THREE);
var_dump(PEAR_ErrorStack::staticGetErrors());

// simulate PEAR_ERROR_CALLBACK, with specific callback for mypackage
// every other package will only log errors, only mypackage's errors
// are pushed on the stack, conditionally
class myclass {
    function acallback($err)
    {
        return PEAR_ERRORSTACK_LOG;
    }
}
$stack2 = PEAR_ErrorStack::singleton('anotherpackage');
$stack3 = &PEAR_ErrorStack::singleton('thirdpackage');
PEAR_ErrorStack::setDefaultCallback(array('myclass', 'acallback'));
?>]]>
    </programlisting>
   </para>
   <refsection xml:id="core.pear.pear-errorstack.intro.advanced.callback.repackage"><info><title>Repackaging errors from one package to another</title></info>
    
    <para>
     The most obvious usage for an error callback involves a common scenario
     in many user-level applications that use system-level packages.

     If you write a Content Management System (CMS) with the PEAR DB package,
     it is usually a bad idea to display database-level errors when a user
     clicks on a link to add a message to a forum.

     PEAR_ErrorStack can be used to repackage this error as a MyPackage error.
    </para>
    <para>
     <programlisting role="php"><![CDATA[
<?php
define('MYPACKAGE_ERROR_DBDOWN',1);
require_once 'PEAR/ErrorStack.php';
function repackage($err)
{
    if ($err['package'] == 'DB') {
        $mystack = &PEAR_ErrorStack::singleton('mypackage');
        $mystack->push(MYPACKAGE_ERROR_DBDOWN, 'error', array('olderror' => $err));
        // ignore the DB error, but save it in the mypackage error, for logging
        return PEAR_ERRORSTACK_IGNORE;
    }
}
?>]]>
     </programlisting>
    </para>
   </refsection>
   <refsection xml:id="core.pear.pear-errorstack.intro.advanced.callback.silence"><info><title>Emulating the @ operator</title></info>
    
    <para>
     One of the difficult-to-use strengths of PEAR_Error involves the
     <link linkend="core.pear.pear.expecterror"><function>PEAR::expectError</function></link>
     method.

     With regular PHP errors, it is possible to silence them using
     the @ operator like so:
    </para>
    <para>
     <programlisting role="php"><![CDATA[
<?php
@file_get_contents();
?>]]>
     </programlisting>
    </para>
    <para>
     Emulating this behavior with PEAR_ErrorStack is simple.
    </para>
    <para>
     <programlisting role="php"><![CDATA[
<?php
define('ERROR_CODE_SOMETHING', 1);
require_once 'PEAR/ErrorStack.php';
function silence($err)
{
    // ignore all errors
    return PEAR_ERRORSTACK_IGNORE;
}
$stack = &PEAR_ErrorStack::singleton('mypackage');
$stack->pushCallback('silence');
$stack->push(ERROR_CODE_SOMETHING);
?>]]>
     </programlisting>
    </para>
    <para>
     PEAR_ErrorStack can take this one step further,
     and only log errors or only put errors on the error stack,
     using the other two constants.

     Finally, particular errors can be singled out, and all others ignored.
    </para>
    <para>
     <programlisting role="php"><![CDATA[
<?php
define('SOMEPACKAGE_ERROR_THING', 1);
require_once 'PEAR/ErrorStack.php';
function silenceSome($err)
{
    if ($err['package'] != 'somepackage') {
        // ignore all errors from other packages
        return PEAR_ERROR_IGNORE;
    }
    if ($err['code'] != SOMEPACKAGE_ERROR_THING) {
        // ignore all other error codes
        return PEAR_ERRORSTACK_IGNORE;
    }
}
$stack = &PEAR_ErrorStack::singleton('mypackage');
$stack->pushCallback('silenceSome');
$stack->push(ERROR_CODE_SOMETHING);
?>]]>
     </programlisting>
    </para>
   </refsection>
  </refsection>
 </refsection>
 <refsection xml:id="core.pear.pear-errorstack.intro.merging"><info><title>
   Backwards compatibility with PEAR_Error,
   Forward compatibility with PHP 5 Exception and PEAR_Exception
  </title></info>
  
  <para>
   <classname>PEAR_ErrorStack</classname>
   can also be programmed to automatically raise a PEAR_Error using
   <link linkend="core.pear.pear.raiseerror"><function>PEAR::raiseError</function></link>,
   simply pass in true to the PEAR_Error compatibility like so:
  </para>
  <para>
   <programlisting role="php"><![CDATA[
<?php
require_once 'PEAR/ErrorStack.php';
$stack = &PEAR_ErrorStack::singleton('mypackage', false, false, true);
?>]]>
   </programlisting>
  </para>
  <para>
   PEAR_ErrorStack can coordinate with the new PEAR_Exception class to
   convert into an exception with this code:

   You can set the exception class name that will be returned
   using the following code:
  </para>
  <para>
   <programlisting role="php"><![CDATA[
<?php
require_once 'PEAR/ErrorStack.php';
require_once 'PEAR/Exception.php';
$stack = &PEAR_ErrorStack::singleton('mypackage');
$stack->push(1, 'test error');
throw new PEAR_Exception('did not work', $stack->pop());
?>]]>
   </programlisting>
  </para>
 </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear.pear-errorstack.pear-errorstack">
   <refnamediv>
    <refname>constructor <function>PEAR_ErrorStack::PEAR_ErrorStack</function></refname>
    <refpurpose>Set up a new error stack instance</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/ErrorStack.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>void      constructor <function>PEAR_ErrorStack::PEAR_ErrorStack</function></funcdef>
      <paramdef choice="req">string <parameter>$package</parameter></paramdef>
      <paramdef choice="opt">callback <parameter> $msgCallback</parameter>
       <initializer>false</initializer>
      </paramdef>
      <paramdef choice="opt">callback <parameter> $contextCallback</parameter>
       <initializer>false</initializer>
      </paramdef>
      <paramdef choice="opt">boolean <parameter> $throwPEAR_Error</parameter>
       <initializer>false</initializer>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>

    <refsection xml:id="core.pear.pear-errorstack.pear-errorstack.bcwarning"><info><title>Backwards Compatibility Warning</title></info>
     
     <warning>
      <para>
       As of PEAR 1.3.2, PEAR_ErrorStack no longer instantiates and returns an Exception object in PHP5, and
       the last parameter has been removed.  Code that relies upon this behavior will break.
      </para>
     </warning>
    </refsection>
    <refsection xml:id="core.pear.pear-errorstack.pear-errorstack.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>Creates a new private PEAR_ErrorStack.  To access a universal stack, use <link linkend="core.pear.pear-errorstack.singleton"><function>PEAR_ErrorStack::singleton</function></link></para>
    </refsection>
   <refsection xml:id="core.pear.pear-errorstack.pear-errorstack.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
        <parameter>$package</parameter>
       </term>
       <listitem>
        <para>
         name of the package this error stack represents
        </para>
       </listitem>
      </varlistentry>     
     </variablelist>
     <variablelist>
      <varlistentry>
       <term>
        <type>callback</type>
        <parameter>$msgCallback</parameter>
       </term>
       <listitem>
        <para>
         callback used for error message generation
        </para>
       </listitem>
      </varlistentry>     
     </variablelist>
     <variablelist>
      <varlistentry>
       <term>
        <type>callback</type>
        <parameter>$contextCallback</parameter>
       </term>
       <listitem>
        <para>
         callback used for context generation, defaults to <link linkend="core.pear.pear-errorstack.getfileline"><function>getFileLine</function></link>
        </para>
       </listitem>
      </varlistentry>     
     </variablelist>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">boolean</type>
        <parameter>$throwPEAR_Error</parameter>
       </term>
       <listitem>
        <para>
         
        </para>
       </listitem>
      </varlistentry>     
     </variablelist>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
        <parameter>$exceptionClass</parameter>
       </term>
       <listitem>
        <para>
         exception class to instantiate if                  in PHP 5
        </para>
       </listitem>
      </varlistentry>     
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.pear.pear-errorstack.throws">
    <title xmlns="http://docbook.org/ns/docbook">Throws</title>
        <para>
      <emphasis>throws</emphasis> no exceptions thrown
    </para>
       </refsection>
   <refsection xml:id="core.pear.pear-errorstack.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear.pear-errorstack.geterrormessage">
   <refnamediv>
    <refname><function>PEAR_ErrorStack::getErrorMessage</function></refname>
    <refpurpose>Standard error message generation callback</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/ErrorStack.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>string      <function>PEAR_ErrorStack::getErrorMessage</function></funcdef>
      <paramdef choice="req">PEAR_ErrorStack <parameter>&amp;$stack</parameter></paramdef>
      <paramdef choice="req">array <parameter>$err</parameter></paramdef>
      <paramdef choice="opt">string|false<parameter> $template</parameter>
       <initializer>false</initializer>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>

    <refsection xml:id="core.pear.pear-errorstack.geterrormessage.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>This method may also be called by a custom error message generator 
      to fill in template values from the params array, simply  set the third
      parameter to the error message template string to use
     </para>
     <para>
      The special variable %__msg% is reserved: use it only to specify  where a message passed
      in by the user should be placed in the template,  like so:
     </para>
     <para>Error message: %msg% - internal error</para>
     <para>If the message passed like so:</para>
     <para>
      <programlisting role="php-highlighted">
&lt;?php
$stack-&gt;<link linkend="core.pear.pear-errorstack.push">push</link>(ERROR_CODE, 'error', array(), 'server error 500');
?&gt;
      </programlisting>
     </para>
     <para>The returned error message will be "Error message: server error 500 -  internal error"</para>

    </refsection>
   <refsection xml:id="core.pear.pear-errorstack.geterrormessage.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type>PEAR_ErrorStack</type>
        <parameter>&amp;$stack</parameter>
       </term>
       <listitem>
        <para>
         
        </para>
       </listitem>
      </varlistentry>     
     </variablelist>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">array</type>
        <parameter>$err</parameter>
       </term>
       <listitem>
        <para>
         
        </para>
       </listitem>
      </varlistentry>     
     </variablelist>
     <variablelist>
      <varlistentry>
       <term>
        <type>string|false</type>
        <parameter>$template</parameter>
       </term>
       <listitem>
        <para>
         Pre-generated error message template
        </para>
       </listitem>
      </varlistentry>     
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.pear.pear-errorstack.geterrormessage.throws">
    <title xmlns="http://docbook.org/ns/docbook">Throws</title>
        <para>
      <emphasis>throws</emphasis> no exceptions thrown
    </para>
       </refsection>

   <refsection xml:id="core.pear.pear-errorstack.geterrormessage.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function should be called
statically.</simpara>    
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear.pear-errorstack.geterrormessagetemplate">
   <refnamediv>
    <refname><function>PEAR_ErrorStack::getErrorMessageTemplate</function></refname>
    <refpurpose>Standard Error Message Template generator from error code</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/ErrorStack.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>string <function>PEAR_ErrorStack::getErrorMessageTemplate</function></funcdef>
      <paramdef choice="req">mixed <parameter>$code</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>

    <refsection xml:id="core.pear.pear-errorstack.geterrormessagetemplate.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>Standard Error Message Template generator from error code</para>
    </refsection>
   <refsection xml:id="core.pear.pear-errorstack.geterrormessagetemplate.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">mixed</type>
        <parameter>$code</parameter>
       </term>
       <listitem>
        <para>
         
        </para>
       </listitem>
      </varlistentry>     
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.pear.pear-errorstack.geterrormessagetemplate.throws">
    <title xmlns="http://docbook.org/ns/docbook">Throws</title>
        <para>
      <emphasis>throws</emphasis> no exceptions thrown
    </para>
       </refsection>
   <refsection xml:id="core.pear.pear-errorstack.geterrormessagetemplate.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear.pear-errorstack.geterrors">
   <refnamediv>
    <refname><function>PEAR_ErrorStack::getErrors</function></refname>
    <refpurpose>Retrieve all errors since last purge</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/ErrorStack.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>array      <function>PEAR_ErrorStack::getErrors</function></funcdef>
      <paramdef choice="opt">boolean <parameter> $purge</parameter>
       <initializer>false</initializer>
      </paramdef>
      <paramdef choice="opt">string|false <parameter> $level</parameter>
       <initializer>false</initializer>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>

    <refsection xml:id="core.pear.pear-errorstack.geterrors.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>Retrieve all errors since last purge, or filter all errors and only return errors of a particular error level,
      leaving the rest on the stack.
     </para>
    </refsection>
   <refsection xml:id="core.pear.pear-errorstack.geterrors.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">boolean</type>
        <parameter>$purge</parameter>
       </term>
       <listitem>
        <para>
         set in order to empty the error stack
        </para>
       </listitem>
      </varlistentry>     
     </variablelist>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
        <parameter>$level</parameter>
       </term>
       <listitem>
        <para>
         Level name to check for a particular severity. Use this to determine whether only a particular
         class of errors has occurred, such as whether any warnings have occurred (errors will be ignored)
        </para>
       </listitem>
      </varlistentry>     
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.pear.pear-errorstack.geterrors.throws">
    <title xmlns="http://docbook.org/ns/docbook">Throws</title>
        <para>
      <emphasis>throws</emphasis> no exceptions thrown
    </para>
       </refsection>
   <refsection xml:id="core.pear.pear-errorstack.geterrors.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear.pear-errorstack.getfileline">
   <refnamediv>
    <refname><function>PEAR_ErrorStack::getFileLine</function></refname>
    <refpurpose>Standard file/line number/function/class context callback</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/ErrorStack.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef><replaceable>array|false</replaceable>      <function>PEAR_ErrorStack::getFileLine</function></funcdef>
      <paramdef choice="req">array <parameter>$code</parameter></paramdef>
      <paramdef choice="req">unused <parameter>$params</parameter></paramdef>
      <paramdef choice="opt">integer <parameter> $backtrace</parameter>
       <initializer>null</initializer>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>

    <refsection xml:id="core.pear.pear-errorstack.getfileline.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>This function uses a backtrace generated from <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.php.net/manual-lookup.php?pattern=debug_backtrace">debug_backtrace</link>
      and so will not work at all in PHP &lt; 4.3.0.  The frame should  reference the frame that
      contains the source of the error.
     </para>

    </refsection>
   <refsection xml:id="core.pear.pear-errorstack.getfileline.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">array</type>
        <parameter>$code</parameter>
       </term>
       <listitem>
        <para>
         Results of debug_backtrace()
        </para>
       </listitem>
      </varlistentry>     
     </variablelist>
     <variablelist>
      <varlistentry>
       <term>
        <type>unused</type>
        <parameter>$params</parameter>
       </term>
       <listitem>
        <para>
         
        </para>
       </listitem>
      </varlistentry>     
     </variablelist>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">integer</type>
        <parameter>$backtrace</parameter>
       </term>
       <listitem>
        <para>
         backtrace frame.
        </para>
       </listitem>
      </varlistentry>     
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.pear.pear-errorstack.getfileline.returns">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>
        <para>
      <emphasis>returns</emphasis> either
      array('file' =&gt; file, 'line' =&gt; line,
          'function' =&gt; function name, 'class' =&gt; class name) or
          if this doesn't work, then false
    </para>
       </refsection>
   <refsection xml:id="core.pear.pear-errorstack.getfileline.throws">
    <title xmlns="http://docbook.org/ns/docbook">Throws</title>
        <para>
      <emphasis>throws</emphasis> no exceptions thrown
    </para>
       </refsection>

   <refsection xml:id="core.pear.pear-errorstack.getfileline.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function should be called
statically.</simpara>    
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear.pear-errorstack.getmessagecallback">
   <refnamediv>
    <refname><function>PEAR_ErrorStack::getMessageCallback</function></refname>
    <refpurpose>Get an error code =&gt; error message mapping callback</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/ErrorStack.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef><replaceable>array|string|false</replaceable> <function>PEAR_ErrorStack::getMessageCallback</function></funcdef>
<paramdef choice="req"/>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>

    <refsection xml:id="core.pear.pear-errorstack.getmessagecallback.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>This method returns the current callback that can be used to generate error messages</para>

    </refsection>
   <refsection xml:id="core.pear.pear-errorstack.getmessagecallback.returns">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>
        <para>
      <emphasis>returns</emphasis> Callback function/method or false if none
    </para>
       </refsection>
   <refsection xml:id="core.pear.pear-errorstack.getmessagecallback.throws">
    <title xmlns="http://docbook.org/ns/docbook">Throws</title>
        <para>
      <emphasis>throws</emphasis> no exceptions thrown
    </para>
       </refsection>
   <refsection xml:id="core.pear.pear-errorstack.getmessagecallback.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear.pear-errorstack.haserrors">
   <refnamediv>
    <refname><function>PEAR_ErrorStack::hasErrors</function></refname>
    <refpurpose>Determine whether there are any errors on the stack</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/ErrorStack.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>boolean <function>PEAR_ErrorStack::hasErrors</function></funcdef>
      <paramdef choice="opt">string <parameter> $level = false</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>

    <refsection xml:id="core.pear.pear-errorstack.haserrors.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>Determine whether there are any errors on the stack</para>
    </refsection>
   <refsection xml:id="core.pear.pear-errorstack.haserrors.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
        <parameter>$level</parameter>
       </term>
       <listitem>
        <para>
         Level name to check for a particular severity. Use this to determine whether only a particular
         class of errors has occurred, such as whether any warnings have occurred (errors will be ignored)
        </para>
       </listitem>
      </varlistentry>     
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.pear.pear-errorstack.haserrors.throws">
    <title xmlns="http://docbook.org/ns/docbook">Throws</title>
        <para>
      <emphasis>throws</emphasis> no exceptions thrown
    </para>
       </refsection>
   <refsection xml:id="core.pear.pear-errorstack.haserrors.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear.pear-errorstack.pop">
   <refnamediv>
    <refname><function>PEAR_ErrorStack::pop</function></refname>
    <refpurpose>Pop an error off of the error stack</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/ErrorStack.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef><replaceable>false|array</replaceable>      <function>PEAR_ErrorStack::pop</function></funcdef>
<paramdef choice="req"/>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>

    <refsection xml:id="core.pear.pear-errorstack.pop.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>Pop an error off of the error stack</para>
    </refsection>
   <refsection xml:id="core.pear.pear-errorstack.pop.throws">
    <title xmlns="http://docbook.org/ns/docbook">Throws</title>
        <para>
      <emphasis>throws</emphasis> no exceptions thrown
    </para>
       </refsection>
   <refsection xml:id="core.pear.pear-errorstack.pop.since">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
        <para>
      <emphasis>since</emphasis> 0.4alpha it is no longer possible to specify a specific error
      level to return - the last error pushed will be returned instead.
    </para>
       </refsection>
   <refsection xml:id="core.pear.pear-errorstack.pop.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear.pear-errorstack.popcallback">
   <refnamediv>
    <refname><function>PEAR_ErrorStack::popCallback</function></refname>
    <refpurpose>Remove a callback from the error callback stack</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/ErrorStack.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef><replaceable>array|string|false</replaceable>      <function>PEAR_ErrorStack::popCallback</function></funcdef>
<paramdef choice="req"/>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>

    <refsection xml:id="core.pear.pear-errorstack.popcallback.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>Remove a callback from the error callback stack</para>
    </refsection>
   <refsection xml:id="core.pear.pear-errorstack.popcallback.throws">
    <title xmlns="http://docbook.org/ns/docbook">Throws</title>
        <para>
      <emphasis>throws</emphasis> no exceptions thrown
    </para>
       </refsection>
   <refsection xml:id="core.pear.pear-errorstack.popcallback.see">
    <title xmlns="http://docbook.org/ns/docbook">See</title>
        <para>
      <emphasis>see</emphasis> <link linkend="core.pear.pear-errorstack.pushcallback"><function>PEAR_ErrorStack::pushCallback</function></link>
    </para>
       </refsection>
   <refsection xml:id="core.pear.pear-errorstack.popcallback.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear.pear-errorstack.push">
 <refnamediv>
  <refname><function>PEAR_ErrorStack::push</function></refname>
  <refpurpose>Add an error to the stack</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>
    require_once 'PEAR/ErrorStack.php';
   </funcsynopsisinfo>
   <funcprototype>
    <funcdef>PEAR_Error|array <function>PEAR_ErrorStack::push</function></funcdef>
    <paramdef choice="req">
     <type xmlns="http://docbook.org/ns/docbook">integer</type> 
     <parameter>$code</parameter>
    </paramdef>
    <paramdef choice="opt">
     <type xmlns="http://docbook.org/ns/docbook">string</type> 
     <parameter> $level = 'error'</parameter>
    </paramdef>
    <paramdef choice="opt"> 
     <type xmlns="http://docbook.org/ns/docbook">array</type> 
     <parameter> $params = array()</parameter>
    </paramdef>
    <paramdef choice="opt">
     <type xmlns="http://docbook.org/ns/docbook">string</type> 
     <parameter> $msg</parameter>
     <initializer>false</initializer>
    </paramdef>
    <paramdef choice="opt">
     <type xmlns="http://docbook.org/ns/docbook">array</type> 
     <parameter> $repackage</parameter>
     <initializer>false</initializer>
    </paramdef>
    <paramdef choice="opt">
     <type xmlns="http://docbook.org/ns/docbook">array</type> 
     <parameter> $backtrace</parameter>
     <initializer>false</initializer>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>

 <refsection xml:id="core.pear.pear-errorstack.push.bcwarning"><info><title>Backwards Compatibility Warning</title></info>
  
  <warning>
   <para>
    As of PEAR 1.3.2, 
    PEAR_ErrorStack no longer instantiates 
    and returns an Exception object in PHP5.
    
    Code that relies upon this behavior will break.
   </para>
  </warning>
 </refsection>
 <refsection xml:id="core.pear.pear-errorstack.push.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   If the message generator exists, 
   it is called with 2 parameters. 
   <itemizedlist>
    <listitem>
     <para>the current Error Stack object</para>
    </listitem>
    <listitem>
     <para>
      an array that is in the same format as an error.  
       
      Available indices are 
      'code', 'package', 
      'time', 'params',
      'level', and 'context'
     </para>
    </listitem>
   </itemizedlist>
   Next, if the error should contain context information, 
   this is  handled by the context
   grabbing method.  
    
   Finally, the error is pushed onto the proper error stack
  </para>
 </refsection>
 <refsection xml:id="core.pear.pear-errorstack.push.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">integer</type>
      <parameter>$code</parameter>
     </term>
     <listitem>
      <para>
       Package-specific error code
      </para>
     </listitem>
    </varlistentry>     
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$level</parameter>
     </term>
     <listitem>
      <para>
       Error level.  This is NOT spell-checked
      </para>
     </listitem>
    </varlistentry>     
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">array</type>
      <parameter>$params</parameter>
     </term>
     <listitem>
      <para>
       associative array of error parameters
      </para>
     </listitem>
    </varlistentry>     
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$msg</parameter>
     </term>
     <listitem>
      <para>
       Error message, 
       or a portion of it if the message is to be generated
      </para>
     </listitem>
    </varlistentry>     
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">array</type>
      <parameter>$repackage</parameter>
     </term>
     <listitem>
      <para>
       If this error re-packages an error pushed by                          
       another package, 
       place the array returned from 
       <link linkend="core.pear.pear-errorstack.pop"><function>pop</function></link>
       in this parameter
      </para>
     </listitem>
    </varlistentry>     
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">array</type>
      <parameter>$backtrace</parameter>
     </term>
     <listitem>
      <para>
       Protected parameter: 
       use this to pass in the                          
       <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.php.net/manual-lookup.php?pattern=debug_backtrace">http://www.php.net/manual-lookup.php?pattern=debug_backtrace</link>
       that should be used to 
       find error context.
      </para>
     </listitem>
    </varlistentry>     
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.pear.pear-errorstack.push.returns">
  <title xmlns="http://docbook.org/ns/docbook">Return value</title>
  <para>
   <emphasis>returns</emphasis>
   if compatibility mode is on, 
   a PEAR_Error is also thrown.  
   
   If the class Exception exists, 
   then one is returned to allow code like:
   <programlisting role="php-highlighted">
&lt;?php
1      throw ($stack-&gt;<link linkend="core.pear.pear-errorstack.push">push</link>(MY_ERROR_CODE, 'error', array('username' =&gt; 'grob')));
?&gt;
   </programlisting>
  </para>
  <para>
   The errorData property of the exception class 
   will be set to the array 
   that would normally be returned.  
   
   If a 
   <link linkend="core.pear.pear-error"><classname>PEAR_Error</classname></link> 
   is returned, the userinfo property is set to the array
  </para>
  <para>Otherwise, an array is returned in this format:
   <programlisting role="php-highlighted">
&lt;?php
1      array(
2         'code' =&gt; $code,
3         'params' =&gt; $params,
4         'package' =&gt; $this-&gt;_package,
5         'level' =&gt; $level,
6         'time' =&gt; <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.php.net/manual-lookup.php?pattern=time">time</link>(),
7         'context' =&gt; $context,
8         'message' =&gt; $msg,
9      //['repackage' =&gt; $err] repackaged error array
10     );
?&gt;
   </programlisting>
  </para>
 </refsection>
 <refsection xml:id="core.pear.pear-errorstack.push.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para xmlns="http://docbook.org/ns/docbook">No exceptions thrown.</para>
 </refsection>
 <refsection xml:id="core.pear.pear-errorstack.push.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
 </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear.pear-errorstack.pushcallback">
   <refnamediv>
    <refname><function>PEAR_ErrorStack::pushCallback</function></refname>
    <refpurpose>Set an error Callback  If set to a valid callback, this will be called
every time an error  is pushed onto the stack.  The return value will be
used to determine  whether to allow an error to be pushed or logged.</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/ErrorStack.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>void      <function>PEAR_ErrorStack::pushCallback</function></funcdef>
      <paramdef choice="req">string|array <parameter>$cb</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>

    <refsection xml:id="core.pear.pear-errorstack.pushcallback.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>The return value must be one of the PEAR_ERRORSTACK_* constants.</para>
     <para>This functionality can be used to emulate PEAR's pushErrorHandling, and 
      the PEAR_ERROR_CALLBACK mode, without affecting the integrity of  the error stack or logging
     </para>

    </refsection>
   <refsection xml:id="core.pear.pear-errorstack.pushcallback.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type>string|array</type>
        <parameter>$cb</parameter>
       </term>
       <listitem>
        <para>
         
        </para>
       </listitem>
      </varlistentry>     
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.pear.pear-errorstack.pushcallback.throws">
    <title xmlns="http://docbook.org/ns/docbook">Throws</title>
        <para>
      <emphasis>throws</emphasis> no exceptions thrown
    </para>
       </refsection>
   <refsection xml:id="core.pear.pear-errorstack.pushcallback.see">
    <title xmlns="http://docbook.org/ns/docbook">See</title>
        <para>
      <emphasis>see</emphasis> <link linkend="core.pear.pear-errorstack.popcallback"><function>PEAR_ErrorStack::popCallback</function></link>
    </para>
        <para>
      <emphasis>see</emphasis> <link linkend="core.pear.pear-errorstack.constants.details.errorstack---php"><constant>PEAR_ERRORSTACK_PUSHANDLOG</constant></link>, <link linkend="core.pear.pear-errorstack.constants.details.errorstack---php"><constant>PEAR_ERRORSTACK_PUSH</constant></link>, <link linkend="core.pear.pear-errorstack.constants.details.errorstack---php"><constant>PEAR_ERRORSTACK_LOG</constant></link>
    </para>
       </refsection>
   <refsection xml:id="core.pear.pear-errorstack.pushcallback.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear.pear-errorstack.raiseerror">
 <refnamediv>
  <refname><function>PEAR_ErrorStack::raiseError</function></refname>
  <refpurpose>emulate <function>PEAR::raiseError</function></refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>
    require_once 'PEAR/ErrorStack.php';
   </funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     PEAR_Error 
     <function>PEAR_ErrorStack::raiseError</function>
    </funcdef>
    <paramdef choice="req"/>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>

 <refsection xml:id="core.pear.pear-errorstack.raiseerror.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   See 
   <link linkend="core.pear.pear.raiseerror">
    <function>PEAR::raiseError</function>
   </link>
  </para>
 </refsection>
 <refsection xml:id="core.pear.pear-errorstack.raiseerror.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para xmlns="http://docbook.org/ns/docbook">No exceptions thrown.</para>
 </refsection>
 <refsection xml:id="core.pear.pear-errorstack.raiseerror.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can be called
statically.</simpara>
 </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear.pear-errorstack.setcontextcallback">
 <refnamediv>
  <refname>
   <function>PEAR_ErrorStack::setContextCallback</function>
  </refname>
  <refpurpose>
   Set a callback that generates context 
   information (location of error) for an error stack
  </refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>
    require_once 'PEAR/ErrorStack.php';
   </funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     <type xmlns="http://docbook.org/ns/docbook">void</type> 
     <function>PEAR_ErrorStack::setContextCallback</function>
    </funcdef>
    <paramdef choice="req">
     <type xmlns="http://docbook.org/ns/docbook">array</type>|<type xmlns="http://docbook.org/ns/docbook">string</type>|null 
     <parameter>$contextCallback</parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>

 <refsection xml:id="core.pear.pear-errorstack.setcontextcallback.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   This method sets the callback that can be used to generate context
   information for an error.  
   
   Passing in <constant xmlns="http://docbook.org/ns/docbook">NULL</constant> will disable context generation
   and remove the expensive call to 
   <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.php.net/manual-lookup.php?pattern=debug_backtrace">
   <function>debug_backtrace</function></link>
  </para>
 </refsection>
 <refsection xml:id="core.pear.pear-errorstack.setcontextcallback.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">mixed</type>
      <parameter>$contextCallback</parameter>
     </term>
     <listitem>
      <para>
       A valid callback as defined by 
       <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.php.net/manual-lookup.php?pattern=is_callable">
        <function>is_callable</function>
       </link>
      </para>
     </listitem>
    </varlistentry>     
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.pear.pear-errorstack.setcontextcallback.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para xmlns="http://docbook.org/ns/docbook">No exceptions thrown.</para>
 </refsection>
 <refsection xml:id="core.pear.pear-errorstack.setcontextcallback.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
 </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear.pear-errorstack.setdefaultcallback">
 <refnamediv>
  <refname>
   <function>PEAR_ErrorStack::setDefaultCallback</function>
  </refname>
  <refpurpose>
   Sets a default callback to be used by all error stacks
  </refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>
    require_once 'PEAR/ErrorStack.php';
   </funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     <type xmlns="http://docbook.org/ns/docbook">void</type>      
     <function>PEAR_ErrorStack::setDefaultCallback</function>
    </funcdef>
    <paramdef choice="opt">
     <type xmlns="http://docbook.org/ns/docbook">array</type>|<type xmlns="http://docbook.org/ns/docbook">string</type> 
     <parameter>$callback</parameter>
     <initializer>false</initializer>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>

 <refsection xml:id="core.pear.pear-errorstack.setdefaultcallback.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   This method sets the callback 
   that can be used to generate error  
   messages for a singleton
  </para>
 </refsection>
 <refsection xml:id="core.pear.pear-errorstack.setdefaultcallback.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">array</type>|<type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$callback</parameter>
     </term>
     <listitem>
      <para>
       Callback function/method
      </para>
     </listitem>
    </varlistentry>     
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.pear.pear-errorstack.setdefaultcallback.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para xmlns="http://docbook.org/ns/docbook">No exceptions thrown.</para>
 </refsection>

 <refsection xml:id="core.pear.pear-errorstack.setdefaultcallback.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function should be called
statically.</simpara>    
 </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear.pear-errorstack.setdefaultlogger">
 <refnamediv>
  <refname>
   <function>PEAR_ErrorStack::setDefaultLogger</function>
  </refname>
  <refpurpose>
   Set up a PEAR::Log object for all 
   error stacks that don't have one
  </refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>
    require_once 'PEAR/ErrorStack.php';
   </funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     <type xmlns="http://docbook.org/ns/docbook">void</type> 
     <function>PEAR_ErrorStack::setDefaultLogger</function>
    </funcdef>
    <paramdef choice="req">
     Log <parameter>&amp;$log</parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>

 <refsection xml:id="core.pear.pear-errorstack.setdefaultlogger.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Set up a PEAR::Log object for all 
   error stacks that don't have one
  </para>
 </refsection>
 <refsection xml:id="core.pear.pear-errorstack.setdefaultlogger.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type>Log</type>
      <parameter>&amp;$log</parameter>
     </term>
     <listitem>
      <para>
       
      </para>
     </listitem>
    </varlistentry>     
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.pear.pear-errorstack.setdefaultlogger.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para xmlns="http://docbook.org/ns/docbook">No exceptions thrown.</para>
 </refsection>

 <refsection xml:id="core.pear.pear-errorstack.setdefaultlogger.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function should be called
statically.</simpara>    
 </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear.pear-errorstack.seterrormessagetemplate">
 <refnamediv>
  <refname>
   <function>PEAR_ErrorStack::setErrorMessageTemplate</function>
  </refname>
  <refpurpose>Set the Error Message Template array</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>
    require_once 'PEAR/ErrorStack.php';
   </funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     <type xmlns="http://docbook.org/ns/docbook">string</type>      
     <function>PEAR_ErrorStack::setErrorMessageTemplate</function>
    </funcdef>
    <paramdef choice="req">
     <type xmlns="http://docbook.org/ns/docbook">mixed</type> 
     <parameter>$template</parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>

 <refsection xml:id="core.pear.pear-errorstack.seterrormessagetemplate.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   The array format must be:  
   <![CDATA[ array(error code => 'message template',...)]]>
  </para>
  <para>
   Error message parameters passed into 
   <link linkend="core.pear.pear-errorstack.push">
    <function>push</function>
   </link>
   will be used as input  for the error message.  
   
   If the template is 'message %foo% was %bar%', 
   and the parameters are 
   array('foo' =&gt; 'one', 
   'bar' =&gt; 'six'), 
   the error message returned will  be 
   'message one was six'
  </para>
 </refsection>
 <refsection xml:id="core.pear.pear-errorstack.seterrormessagetemplate.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">mixed</type>
      <parameter>$template</parameter>
     </term>
     <listitem>
      <para>
       
      </para>
     </listitem>
    </varlistentry>     
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.pear.pear-errorstack.seterrormessagetemplate.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para xmlns="http://docbook.org/ns/docbook">No exceptions thrown.</para>
 </refsection>
 <refsection xml:id="core.pear.pear-errorstack.seterrormessagetemplate.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
 </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear.pear-errorstack.setlogger">
 <refnamediv>
  <refname>
   <function>PEAR_ErrorStack::setLogger</function>
  </refname>
  <refpurpose>
   Set up a PEAR::Log object for this error stack
  </refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>
    require_once 'PEAR/ErrorStack.php';
   </funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     <type xmlns="http://docbook.org/ns/docbook">void</type>
     <function>PEAR_ErrorStack::setLogger</function>
    </funcdef>
    <paramdef choice="req">
     Log 
     <parameter>&amp;$log</parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>

 <refsection xml:id="core.pear.pear-errorstack.setlogger.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Set a PEAR::Log object to use 
   for a specific error stack instance
  </para>
 </refsection>
 <refsection xml:id="core.pear.pear-errorstack.setlogger.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type>Log</type>
      <parameter>&amp;$log</parameter>
     </term>
     <listitem>
      <para>
        
      </para>
     </listitem>
    </varlistentry>     
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.pear.pear-errorstack.setlogger.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para xmlns="http://docbook.org/ns/docbook">No exceptions thrown.</para>
 </refsection>
 <refsection xml:id="core.pear.pear-errorstack.setlogger.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
 </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear.pear-errorstack.setmessagecallback">
 <refnamediv>
  <refname>
   <function>PEAR_ErrorStack::setMessageCallback</function>
  </refname>
  <refpurpose>
   Set an error code =&gt; error message mapping callback
  </refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>
    require_once 'PEAR/ErrorStack.php';
   </funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     <type xmlns="http://docbook.org/ns/docbook">void</type>
     <function>PEAR_ErrorStack::setMessageCallback</function>
    </funcdef>
    <paramdef choice="req">
     <type xmlns="http://docbook.org/ns/docbook">mixed</type> 
     <parameter>$msgCallback</parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.pear.pear-errorstack.setmessagecallback.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   This method sets the callback that 
   can be used to generate error 
   messages for any PEAR_ErrorStack instance
  </para>
 </refsection>
 <refsection xml:id="core.pear.pear-errorstack.setmessagecallback.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">mixed</type>
      <parameter>$msgCallback</parameter>
     </term>
     <listitem>
      <para>
       
      </para>
     </listitem>
    </varlistentry>     
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.pear.pear-errorstack.setmessagecallback.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para xmlns="http://docbook.org/ns/docbook">No exceptions thrown.</para>
 </refsection>
 <refsection xml:id="core.pear.pear-errorstack.setmessagecallback.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
 </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear.pear-errorstack.singleton">
 <refnamediv>
  <refname><function>PEAR_ErrorStack::singleton</function></refname>
  <refpurpose>Return a single error stack for this package.</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>
    require_once 'PEAR/ErrorStack.php';
   </funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     <replaceable>
      <link linkend="core.pear.pear-errorstack">
       <classname>PEAR_ErrorStack</classname>
      </link>
     </replaceable>&amp;      
     <function>PEAR_ErrorStack::singleton</function>
    </funcdef>
    <paramdef choice="req">
     <type xmlns="http://docbook.org/ns/docbook">string</type> 
     <parameter>$package</parameter>
    </paramdef>
    <paramdef choice="opt">
     <type xmlns="http://docbook.org/ns/docbook">callback</type> 
     <parameter> $msgCallback</parameter>
     <initializer>false</initializer>
    </paramdef>
    <paramdef choice="opt">
     <type xmlns="http://docbook.org/ns/docbook">callback</type> 
     <parameter> $contextCallback</parameter>
     <initializer>false</initializer>
    </paramdef>
    <paramdef choice="opt">
     <type xmlns="http://docbook.org/ns/docbook">boolean</type>
     <parameter> $throwPEAR_Error</parameter>
     <initializer>false</initializer>
    </paramdef>
    <paramdef choice="opt">
     <type xmlns="http://docbook.org/ns/docbook">string</type> 
     <parameter> 
      $stackClass = 'PEAR_ErrorStack'
     </parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>

 <refsection xml:id="core.pear.pear-errorstack.singleton.bcwarning"><info><title>Backwards Compatibility Warning</title></info>
  
  <warning>
   <para>
    As of PEAR 1.3.2, 
    PEAR_ErrorStack no longer instantiates 
    and returns an Exception object in PHP5, 
    and the second-to-last parameter has been removed.  
    
    Code that relies upon this behavior will break.
   </para>
  </warning>
 </refsection>
 <refsection xml:id="core.pear.pear-errorstack.singleton.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Note that all parameters are ignored if the 
   stack for package $package has already been instantiated
  </para>
 </refsection>
 <refsection xml:id="core.pear.pear-errorstack.singleton.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$package</parameter>
     </term>
     <listitem>
      <para>
       name of the package this error stack represents
      </para>
     </listitem>
    </varlistentry>     
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type>callback</type>
      <parameter>$msgCallback</parameter>
     </term>
     <listitem>
      <para>
       callback used for error message generation
      </para>
     </listitem>
    </varlistentry>     
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type>callback</type>
      <parameter>$contextCallback</parameter>
     </term>
     <listitem>
      <para>
       callback used for context generation, defaults to <link linkend="core.pear.pear-errorstack.getfileline"><function>getFileLine</function></link>
      </para>
     </listitem>
    </varlistentry>     
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">boolean</type>
      <parameter>$throwPEAR_Error</parameter>
     </term>
     <listitem>
      <para>
       If <constant xmlns="http://docbook.org/ns/docbook">TRUE</constant>, then 
       <link linkend="core.pear.pear.raiseerror">
        <function>PEAR::raiseError</function>
       </link> will be called and a 
       <link linkend="core.pear.pear-error">
        <classname>PEAR_Error</classname>
       </link> 
       object will be returned from calls to 
       <link linkend="core.pear.pear-errorstack.push">
        <function>PEAR_ErrorStack::push</function>
       </link>
      </para>
     </listitem>
    </varlistentry>     
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$stackClass</parameter>
     </term>
     <listitem>
      <para>
       class to instantiate
      </para>
     </listitem>
    </varlistentry>     
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.pear.pear-errorstack.singleton.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para xmlns="http://docbook.org/ns/docbook">No exceptions thrown.</para>
 </refsection>

 <refsection xml:id="core.pear.pear-errorstack.singleton.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function should be called
statically.</simpara>    
 </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear.pear-errorstack.staticgeterrors">
 <refnamediv>
  <refname><function>PEAR_ErrorStack::staticGetErrors</function></refname>
  <refpurpose>
   Get a list of all errors since last purge, 
   organized by package
  </refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>
    require_once 'PEAR/ErrorStack.php';
   </funcsynopsisinfo>
   <funcprototype>
    <funcdef><type xmlns="http://docbook.org/ns/docbook">array</type> 
     <function>PEAR_ErrorStack::staticGetErrors</function>
    </funcdef>
    <paramdef choice="opt">
     <type xmlns="http://docbook.org/ns/docbook">boolean</type>
     <parameter> $purge</parameter>
     <initializer>false</initializer>
    </paramdef>
    <paramdef choice="opt">
     <type xmlns="http://docbook.org/ns/docbook">string</type>|false
     <parameter> $level</parameter>
     <initializer>false</initializer>
    </paramdef>
    <paramdef choice="opt">
     <type xmlns="http://docbook.org/ns/docbook">boolean</type>
     <parameter> $merge</parameter>
     <initializer>false</initializer>
    </paramdef>
    <paramdef choice="opt">
     <type xmlns="http://docbook.org/ns/docbook">array</type>
     <parameter> 
      
       $sortfunc = array('PEAR_ErrorStack', '_sortErrors')
      
     </parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>

 <refsection xml:id="core.pear.pear-errorstack.staticgeterrors.bcwarning"><info><title>Backwards Compatibility Warning</title></info>
  
   <warning>
    <para>
     As of PEAR 1.3.2, 
     the second parameter is a new parameter <varname>$level</varname>.  
     
     Any code that relies on $merge being the second parameter will break.
    </para>
   </warning>
  </refsection>
  <refsection xml:id="core.pear.pear-errorstack.staticgeterrors.desc">
   <title xmlns="http://docbook.org/ns/docbook">Description</title>
   <para>
    Static version of 
    <link linkend="core.pear.pear-errorstack.geterrors">
     <function>PEAR_ErrorStack::getErrors</function>
    </link>, 
    returns all errors from all singleton stacks.
   </para>
  </refsection>
  <refsection xml:id="core.pear.pear-errorstack.staticgeterrors.param">
   <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
   <para>
    <variablelist>
     <varlistentry>
      <term>
       <type xmlns="http://docbook.org/ns/docbook">boolean</type>
       <parameter>$purge</parameter>
      </term>
      <listitem>
       <para>
         Set to purge the error stack of existing errors
        </para>
       </listitem>
      </varlistentry>     
     </variablelist>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
        <parameter>$level</parameter>
       </term>
       <listitem>
      <para>
       Level name to check for a particular severity. 
       
       Use this to determine whether only a particular
       class of errors has occurred, 
       such as whether any warnings have occurred 
       
       (errors will be ignored)
      </para>
     </listitem>
    </varlistentry>     
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">boolean</type>
      <parameter>$merge</parameter>
     </term>
     <listitem>
      <para>
       Set to return a flat array, not organized by package
      </para>
     </listitem>
    </varlistentry>     
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">array</type>
      <parameter>$sortfunc</parameter>
     </term>
     <listitem>
      <para>
       Function used to sort a merged array 
       - default sorts by time, and should be good for most cases
      </para>
     </listitem>
    </varlistentry>     
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.pear.pear-errorstack.staticgeterrors.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para xmlns="http://docbook.org/ns/docbook">No exceptions thrown.</para>
 </refsection>

 <refsection xml:id="core.pear.pear-errorstack.staticgeterrors.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function should be called
statically.</simpara>    
 </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear.pear-errorstack.statichaserrors">
 <refnamediv>
  <refname>
   <function>PEAR_ErrorStack::staticHasErrors</function>
  </refname>
  <refpurpose>
   Determine whether there are any errors on any error stack
  </refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>
    require_once 'PEAR/ErrorStack.php';
   </funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     <type xmlns="http://docbook.org/ns/docbook">boolean</type>
     <function>PEAR_ErrorStack::staticHasErrors</function>
    </funcdef>
    <paramdef choice="opt">
     <type xmlns="http://docbook.org/ns/docbook">string</type>|false
     <parameter> $package = false</parameter>
    </paramdef>
    <paramdef choice="opt">
     <type xmlns="http://docbook.org/ns/docbook">string</type> 
     <parameter> $level = false</parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>

 <refsection xml:id="core.pear.pear-errorstack.statichaserrors.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Static version of <link linkend="core.pear.pear-errorstack.haserrors">
   <function>PEAR_ErrorStack::hasErrors</function></link>.  
    
   Returns <constant xmlns="http://docbook.org/ns/docbook">TRUE</constant> if any singleton stack has any errors pending.  
    
   Since PEAR 1.3.2, If <varname>$package</varname> 
   is specified, it will call PEAR_ErrorStack::hasErrors
   for the singleton error stack of that package.  
    
   If level is specified, hasErrors will ignore
   any errors not conforming to the error level specified.  
    
   Use this to simulate error_reporting(E_NOTICE), for example
  </para>
 </refsection>
 <refsection xml:id="core.pear.pear-errorstack.statichaserrors.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>|<constant xmlns="http://docbook.org/ns/docbook">FALSE</constant>
      <parameter>$package</parameter>
     </term>
     <listitem>
      <para>
       Package name to retrieve error information from, 
       or false to retrieve error information 
       from all singleton stacks
      </para>
     </listitem>
    </varlistentry>     
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$level</parameter>
     </term>
     <listitem>
      <para>
       Level name to check for a particular severity. 
       
       Use this to determine whether only a particular
       class of errors has occurred, 
       such as whether any warnings have occurred 
       
       (errors will be ignored)
      </para>
     </listitem>
    </varlistentry>     
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.pear.pear-errorstack.statichaserrors.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para xmlns="http://docbook.org/ns/docbook">No exceptions thrown.</para>
 </refsection>

 <refsection xml:id="core.pear.pear-errorstack.statichaserrors.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function should be called
statically.</simpara>    
 </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear.pear-errorstack.staticpop">
 <refnamediv>
  <refname>
   <function>PEAR_ErrorStack::staticPop</function>
  </refname>
  <refpurpose>
   Static version of 
   <link linkend="core.pear.pear-errorstack.pop">
    <function>pop</function>
   </link>
  </refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>
    require_once 'PEAR/ErrorStack.php';
   </funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     <replaceable>false|array</replaceable>
     <function>PEAR_ErrorStack::staticPop</function>
    </funcdef>
    <paramdef choice="req">
     <type xmlns="http://docbook.org/ns/docbook">string</type> 
     <parameter>$package</parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>

 <refsection xml:id="core.pear.pear-errorstack.staticpop.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>Pop an error off of the error stack, static method</para>
 </refsection>
 <refsection xml:id="core.pear.pear-errorstack.staticpop.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$package</parameter>
     </term>
     <listitem>
      <para>
       Package name to retrieve error message from
      </para>
     </listitem>
    </varlistentry>     
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.pear.pear-errorstack.staticpop.returns">
  <title xmlns="http://docbook.org/ns/docbook">Return value</title>
  <para>
   <emphasis>returns</emphasis> 
   if compatibility mode is on, 
   a PEAR_Error is also thrown.
  </para>
 </refsection>
 <refsection xml:id="core.pear.pear-errorstack.staticpop.since">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <para>
   <emphasis>since</emphasis> PEAR 1.5.0a1
  </para>
 </refsection>
 <refsection xml:id="core.pear.pear-errorstack.staticpop.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para xmlns="http://docbook.org/ns/docbook">No exceptions thrown.</para>
 </refsection>

 <refsection xml:id="core.pear.pear-errorstack.staticpop.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function should be called
statically.</simpara>    
 </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear.pear-errorstack.staticpopcallback">
 <refnamediv>
  <refname><function>PEAR_ErrorStack::staticPopCallback</function></refname>
  <refpurpose>Remove a callback from every error callback stack</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>
    require_once 'PEAR/ErrorStack.php';
   </funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     <replaceable>array|string|false</replaceable>      <function>PEAR_ErrorStack::staticPopCallback</function>
    </funcdef>
    <paramdef choice="req"/>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.pear.pear-errorstack.staticpopcallback.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Pop a callback from every Error Stack.  
   
   No check is made to determine whether this is a good idea, 
   so use with discretion.
  </para>
 </refsection>
 <refsection xml:id="core.pear.pear-errorstack.staticpopcallback.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para xmlns="http://docbook.org/ns/docbook">No exceptions thrown.</para>
 </refsection>
 <refsection xml:id="core.pear.pear-errorstack.staticpopcallback.see">
  <title xmlns="http://docbook.org/ns/docbook">See</title>
  <para>
   <emphasis>see</emphasis> 
   <link linkend="core.pear.pear-errorstack.staticpushcallback">
   <function>PEAR_ErrorStack::staticPushCallback</function>
   </link>
  </para>
 </refsection>
 <refsection xml:id="core.pear.pear-errorstack.staticpopcallback.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function should be called
statically.</simpara>
 </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear.pear-errorstack.staticpush">
 <refnamediv>
  <refname>
   <function>PEAR_ErrorStack::staticPush</function>
  </refname>
  <refpurpose>
   Static version of 
   <link linkend="core.pear.pear-errorstack.push">
    <function>push</function>
   </link>
  </refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>
    require_once 'PEAR/ErrorStack.php';
   </funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     <replaceable>PEAR_Error|array</replaceable>      
     <function>PEAR_ErrorStack::staticPush</function>
    </funcdef>
    <paramdef choice="req">
     <type xmlns="http://docbook.org/ns/docbook">string</type> 
     <parameter>$package</parameter>
    </paramdef>
    <paramdef choice="req">
     <type xmlns="http://docbook.org/ns/docbook">integer</type> 
     <parameter>$code</parameter>
    </paramdef>
    <paramdef choice="opt">
     <type xmlns="http://docbook.org/ns/docbook">string</type> 
     <parameter> $level = 'error'</parameter>
    </paramdef>
    <paramdef choice="opt">
     <type xmlns="http://docbook.org/ns/docbook">array</type> 
     <parameter> $params = array()</parameter>
    </paramdef>
    <paramdef choice="opt">
     <type xmlns="http://docbook.org/ns/docbook">string</type> 
     <parameter> $msg</parameter>
     <initializer>false</initializer>
    </paramdef>
    <paramdef choice="opt">
     <type xmlns="http://docbook.org/ns/docbook">array</type> 
     <parameter> $repackage</parameter>
     <initializer>false</initializer>
    </paramdef>
    <paramdef choice="opt">
     <type xmlns="http://docbook.org/ns/docbook">array</type> 
     <parameter> $backtrace</parameter>
     <initializer>false</initializer>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>

 <refsection xml:id="core.pear.pear-errorstack.staticpush.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para/>
 </refsection>
 <refsection xml:id="core.pear.pear-errorstack.staticpush.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$package</parameter>
     </term>
     <listitem>
      <para>
       Package name this error belongs to
      </para>
     </listitem>
    </varlistentry>     
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">integer</type>
      <parameter>$code</parameter>
     </term>
     <listitem>
      <para>
       Package-specific error code
      </para>
     </listitem>
    </varlistentry>     
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$level</parameter>
     </term>
     <listitem>
      <para>
       Error level.  This is NOT spell-checked
      </para>
     </listitem>
    </varlistentry>     
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">array</type>
      <parameter>$params</parameter>
     </term>
     <listitem>
      <para>
       associative array of error parameters
      </para>
     </listitem>
    </varlistentry>     
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$msg</parameter>
     </term>
     <listitem>
      <para>
       Error message, or a portion of 
       it if the message is to be generated
      </para>
     </listitem>
    </varlistentry>     
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">array</type>
      <parameter>$repackage</parameter>
     </term>
     <listitem>
      <para>
       If this error re-packages an error pushed by                          
       another package, place the array returned from                          
       <link linkend="core.pear.pear-errorstack.pop">
        <function>pop</function>
       </link>
       in this parameter
      </para>
     </listitem>
    </varlistentry>     
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">array</type>
      <parameter>$backtrace</parameter>
     </term>
     <listitem>
      <para>
       Protected parameter: use this to pass in the                          
       <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.php.net/manual-lookup.php?pattern=debug_backtrace">debug_backtrace</link>
       that should be used to find error context
      </para>
     </listitem>
    </varlistentry>     
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.pear.pear-errorstack.returns">
  <title xmlns="http://docbook.org/ns/docbook">Return value</title>
  <para>
   <emphasis>returns</emphasis> 
   if compatibility mode is on, 
   a PEAR_Error is also thrown.
  </para>
 </refsection>
 <refsection xml:id="core.pear.pear-errorstack.staticpush.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para xmlns="http://docbook.org/ns/docbook">No exceptions thrown.</para>
 </refsection>

 <refsection xml:id="core.pear.pear-errorstack.staticpush.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function should be called
statically.</simpara>    
 </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear.pear-errorstack.staticpushcallback">
 <refnamediv>
  <refname>
   <function>PEAR_ErrorStack::staticPushCallback</function>
  </refname>
  <refpurpose>
   Set an error Callback for every package's error stack
  </refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>
    require_once 'PEAR/ErrorStack.php';
   </funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     <type xmlns="http://docbook.org/ns/docbook">void</type>
     <function>PEAR_ErrorStack::staticPushCallback</function>
    </funcdef>
    <paramdef choice="req">
     <type xmlns="http://docbook.org/ns/docbook">string</type>|<type xmlns="http://docbook.org/ns/docbook">array</type> 
     <parameter>$cb</parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>

 <refsection xml:id="core.pear.pear-errorstack.staticpushcallback.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Set an error callback for every 
   package's singleton error stack.
  </para>
 </refsection>
 <refsection xml:id="core.pear.pear-errorstack.staticpushcallback.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>|<type xmlns="http://docbook.org/ns/docbook">array</type>
      <parameter>$cb</parameter>
     </term>
     <listitem>
      <para>
       
      </para>
     </listitem>
    </varlistentry>     
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.pear.pear-errorstack.staticpushcallback.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para xmlns="http://docbook.org/ns/docbook">No exceptions thrown.</para>
 </refsection>
 <refsection xml:id="core.pear.pear-errorstack.staticpushcallback.see">
  <title xmlns="http://docbook.org/ns/docbook">See</title>
  <para>
   <emphasis>see</emphasis> 
   <link linkend="core.pear.pear-errorstack.staticpopcallback">
    <function>PEAR_ErrorStack::staticPopCallback</function>
   </link>, 
   <link linkend="core.pear.pear-errorstack.pushcallback">
    <function>PEAR_ErrorStack::pushCallback</function>
   </link>
  </para>
  <para>
   <emphasis>see</emphasis> 
   <link linkend="core.pear.pear-errorstack.constants.details.errorstack---php">
    <constant>PEAR_ERRORSTACK_PUSHANDLOG</constant>
   </link>, 
   <link linkend="core.pear.pear-errorstack.constants.details.errorstack---php">
    <constant>PEAR_ERRORSTACK_PUSH</constant>
   </link>, 
   <link linkend="core.pear.pear-errorstack.constants.details.errorstack---php">
    <constant>PEAR_ERRORSTACK_LOG</constant>
   </link>
  </para>
 </refsection>
 <refsection xml:id="core.pear.pear-errorstack.staticpushcallback.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function should be called
statically.</simpara>    
 </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear.pear-errorstack.-log">
   <refnamediv>
    <refname><function>PEAR_ErrorStack::_log</function></refname>
    <refpurpose>Log an error using PEAR::Log</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/ErrorStack.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>void      <function>PEAR_ErrorStack::_log</function></funcdef>
      <paramdef choice="req">array <parameter>$err</parameter></paramdef>
      <paramdef choice="opt">array <parameter> $levels = array(
                'exception' =&gt; PEAR_LOG_CRIT,
                'alert' =&gt; PEAR_LOG_ALERT,
                'critical' =&gt; PEAR_LOG_CRIT,
                'error' =&gt; PEAR_LOG_ERR,
                'warning' =&gt; PEAR_LOG_WARNING,
                'notice' =&gt; PEAR_LOG_NOTICE,
                'info' =&gt; PEAR_LOG_INFO,
                'debug' =&gt; PEAR_LOG_DEBUG)</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>

    <refsection xml:id="core.pear.pear-errorstack.-log.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>This is a protected function, and should only be called by child classes that extend <classname>PEAR_ErrorStack</classname></para>
    </refsection>
   <refsection xml:id="core.pear.pear-errorstack.-log.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">array</type>
        <parameter>$err</parameter>
       </term>
       <listitem>
        <para>
         Error array
        </para>
       </listitem>
      </varlistentry>     
     </variablelist>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">array</type>
        <parameter>$levels</parameter>
       </term>
       <listitem>
        <para>
         Error level =&gt; Log constant map
        </para>
       </listitem>
      </varlistentry>     
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.pear.pear-errorstack.-log.throws">
    <title xmlns="http://docbook.org/ns/docbook">Throws</title>
        <para>
      <emphasis>throws</emphasis> no exceptions thrown
    </para>
       </refsection>
   <refsection xml:id="core.pear.pear-errorstack.-log.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear.pear-errorstack.constants">
 <refnamediv>
  <refname>Package PEAR_ErrorStack Constants</refname>
  <refpurpose>Constants defined in and used by PEAR_ErrorStack</refpurpose>
 </refnamediv>
 <refsection xml:id="core.pear.pear-errorstack.constants.details"><info><title>All Constants</title></info>
  
  <refsection xml:id="core.pear.pear-errorstack.constants.details.errorstack---php"><info><title>Constants defined in ErrorStack.php</title></info>
   
   <para>
    <table><title>Constants defined in ErrorStack.php</title>
     
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Name</entry>
        <entry>Value</entry>
        <entry>Line Number</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>PEAR_ERRORSTACK_ERR_NONCLASS</entry>
        <entry>1</entry>
        <entry>110</entry>
       </row>
       <row>
        <entry>PEAR_ERRORSTACK_ERR_OBJTOSTRING</entry>
        <entry>2</entry>
        <entry>116</entry>
       </row>
       <row>
        <entry>PEAR_ERRORSTACK_IGNORE</entry>
        <entry>4</entry>
        <entry>103</entry>
       </row>
       <row>
        <entry>PEAR_ERRORSTACK_LOG</entry>
        <entry>3</entry>
        <entry>99</entry>
       </row>
       <row>
        <entry>PEAR_ERRORSTACK_PUSH</entry>
        <entry>2</entry>
        <entry>94</entry>
       </row>
       <row>
        <entry>PEAR_ERRORSTACK_PUSHANDLOG</entry>
        <entry>1</entry>
        <entry>89</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </para>
  </refsection>
 </refsection>
</refentry>

</section>

 
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear.pear-error"><info><title>PEAR_Error [deprecated]</title><titleabbrev>PEAR Error object</titleabbrev></info>
  
  

  <para>
   <classname>PEAR_Error</classname> is an object created by
   every function in PEAR in case of a failure. It provides information
   on why a function fails.
  </para>
  <para>
   How you get the object depends on
   <link linkend="core.pear.pear.seterrorhandling">
    <function>PEAR::SetErrorHandling</function></link>
  </para>

  
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear.pear-error.adduserinfo">
   <refnamediv>
    <refname>PEAR_Error::addUserInfo()</refname>
    <refpurpose>add user information</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>void <function>PEAR_Error::addUserInfo</function></funcdef>
      <paramdef choice="req">
       string <parameter>$info</parameter>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
   </refsynopsisdiv>
   <refsection xml:id="core.pear.pear-error.adduserinfo.desc">
    <title xmlns="http://docbook.org/ns/docbook">Description</title>
    <para>
     Adds an user information to the error object.
    </para>
   </refsection>   
   <refsection xml:id="core.pear.pear-error.adduserinfo.parameter">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <itemizedlist>
      <listitem>
       <para>
        <parameter>string</parameter> - 
        user info
       </para>
      </listitem>
    </itemizedlist>
    </para>
   </refsection>    
   <refsection xml:id="core.pear.pear-error.adduserinfo.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>            
  </refentry>

  
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear.pear-error.getcallback">
   <refnamediv>
    <refname>PEAR_Error::getCallback()</refname>
    <refpurpose>get callback function name</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>string <function>PEAR_Error::getCallback</function></funcdef>
      <paramdef choice="req"/>
     </funcprototype>
    </funcsynopsis>
   </refsynopsisdiv>
   <refsection xml:id="core.pear.pear-error.getcallback.desc">
    <title xmlns="http://docbook.org/ns/docbook">Description</title>
    <para>
     Returns the name of the function called in case of throwing a 
     <classname>PEAR_Error</classname> object.
    </para>
   </refsection>   
   <refsection xml:id="core.pear.pear-error.getcallback.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>
    <para>
     <parameter>string</parameter> - 
     function name
    </para>
   </refsection>      
   <refsection xml:id="core.pear.pear-error.getcall.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>            
  </refentry>
  
  
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear.pear-error.getcode">
   <refnamediv>
    <refname>PEAR_Error::getCode()</refname>
    <refpurpose>get error code</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>integer <function>PEAR_Error::getCode</function></funcdef>
      <paramdef choice="req"/>
     </funcprototype>
    </funcsynopsis>
   </refsynopsisdiv>
   <refsection xml:id="core.pear.pear-error.getcode.desc">
    <title xmlns="http://docbook.org/ns/docbook">Description</title>
    <para>
     Returns the error code coming with the error object.
    </para>
   </refsection>   
   <refsection xml:id="core.pear.pear-error.getcode.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>
    <para>
     <parameter>integer</parameter> - 
     error number
    </para>
   </refsection>      
   <refsection xml:id="core.pear.pear-error.getcode.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>            
  </refentry>
  
  
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear.pear-error.getmessage">
   <refnamediv>
    <refname>PEAR_Error::getMessage()</refname>
    <refpurpose>get error message</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>string <function>PEAR_Error::getMessage</function></funcdef>
      <paramdef choice="req"/>
     </funcprototype>
    </funcsynopsis>
   </refsynopsisdiv>
   <refsection xml:id="core.pear.pear-error.getmessage.desc">
    <title xmlns="http://docbook.org/ns/docbook">Description</title>
    <para>
     Returns the error message coming with the error object.
    </para>
   </refsection>   
   <refsection xml:id="core.pear.pear-error.getmessage.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>
    <para>
     <parameter>string</parameter> - 
     error message
    </para>
   </refsection>     
   <refsection xml:id="core.pear.pear-error.getmessage.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>            
  </refentry>
  
  
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear.pear-error.getmode">
   <refnamediv>
    <refname>PEAR_Error::getMode()</refname>
    <refpurpose>get error mode</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>integer <function>PEAR_Error::getMode</function></funcdef>
      <paramdef choice="req"/>
     </funcprototype>
    </funcsynopsis>
   </refsynopsisdiv>
   <refsection xml:id="core.pear.pear-error.getmode.desc">
    <title xmlns="http://docbook.org/ns/docbook">Description</title>
    <para>
     Returns the error mode used for throwing the error object.
    </para>
   </refsection>   
   <refsection xml:id="core.pear.pear-error.getmode.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>
    <para>
     <parameter>integer</parameter> - 
     error mode
    </para>
   </refsection>      
   <refsection xml:id="core.pear.pear-error.getmode.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>            
  </refentry>

  
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear.pear-error.getdebuginfo">
   <refnamediv>
    <refname>PEAR_Error::getDebugInfo()</refname>
    <refpurpose>get debug information</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>string <function>PEAR_Error::getDebugInfo</function></funcdef>
      <paramdef choice="req"/>
     </funcprototype>
    </funcsynopsis>
   </refsynopsisdiv>
   <refsection xml:id="core.pear.pear-error.getdebuginfo.desc">
    <title xmlns="http://docbook.org/ns/docbook">Description</title>
    <para>
     Returns debug information about an error
    </para>
   </refsection>   
   <refsection xml:id="core.pear.pear-error.getdebuginfo.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>
    <para>
     <parameter>string</parameter> - 
     error debug information
    </para>
   </refsection>      
   <refsection xml:id="core.pear.pear-error.getdebuginfo.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>         
  </refentry>

  
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear.pear-error.gettype">
   <refnamediv>
    <refname>PEAR_Error::getType()</refname>
    <refpurpose>get error type</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>integer <function>PEAR_Error::getType</function></funcdef>
      <paramdef choice="req"/>
     </funcprototype>
    </funcsynopsis>
   </refsynopsisdiv>
   <refsection xml:id="core.pear.pear-error.gettype.desc">
    <title xmlns="http://docbook.org/ns/docbook">Description</title>
    <para>
     Returns the name of the error class of the object.
    </para>
   </refsection>   
   <refsection xml:id="core.pear.pear-error.gettype.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>
    <para>
     <parameter>string</parameter> - 
     error class name 
    </para>
   </refsection> 
   <refsection xml:id="core.pear.pear-error.gettype.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>            
  </refentry>
  
  
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear.pear-error.getuserinfo">
   <refnamediv>
    <refname>PEAR_Error::getUserInfo()</refname>
    <refpurpose>get additional user-supplied information</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>string <function>PEAR_Error::getUserInfo</function></funcdef>
      <paramdef choice="req"/>
     </funcprototype>
    </funcsynopsis>
   </refsynopsisdiv>
   <refsection xml:id="core.pear.pear-error.getuserinfo.desc">
    <title xmlns="http://docbook.org/ns/docbook">Description</title>
    <para>
     Returns additional information about an error
    </para>
   </refsection>   
   <refsection xml:id="core.pear.pear-error.getuserinfo.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>
    <para>
     <parameter>string</parameter> - 
     error information
    </para>
   </refsection>     
   <refsection xml:id="core.pear.pear-error.getuserinfo.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>            
  </refentry>
  
  
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear.pear-error.pear-error">
   <refnamediv>
    <refname>PEAR_Error::PEAR_Error()</refname>
    <refpurpose>constructor</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>void <function>PEAR_Error::PEAR_Error</function></funcdef>
      <paramdef choice="opt">
       string <parameter>
        $message = 'unknown error'</parameter>
      </paramdef>
      <paramdef choice="opt">
       integer <parameter>
        $code</parameter>
       <initializer>null</initializer>
      </paramdef>
      <paramdef choice="opt">
       integer <parameter>
       $mode</parameter>
       <initializer>null</initializer>
      </paramdef>
      <paramdef choice="opt">
       mixed <parameter>
       $options</parameter>
       <initializer>null</initializer>
      </paramdef>
      <paramdef choice="opt">
       string <parameter>
       $userinfo</parameter>
       <initializer>null</initializer>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
   </refsynopsisdiv>
   <refsection xml:id="core.pear.pear-error.pear-error.desc">
    <title xmlns="http://docbook.org/ns/docbook">Description</title>
    <para>
     Constructor
    </para>
   </refsection>
   <refsection xml:id="core.pear.pear-error.pear-error.parameter">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <itemizedlist>
      <listitem>
       <para>
        <parameter>string $message</parameter> -
        the error message. A brief description of the occured
        failure or problem.
       </para>
      </listitem>
      <listitem>
       <para>
        <parameter>string $code</parameter> -
        the error code. An error specific number.
       </para>
      </listitem>
      <listitem>
       <para>
        <parameter>integer $mode</parameter> -
        the error mode
       </para>
      </listitem>
      <listitem>
       <para>
        <parameter>mixed $options</parameter> -
        error mode specific options
       </para>
      </listitem>
      <listitem>
       <para>
        <parameter>string $userinfo</parameter> -
        a string for additional user or debug info
       </para>
      </listitem>
     </itemizedlist>
    </para>
   </refsection>
   <refsection xml:id="core.pear.pear-error.pear-error.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can be called
statically.</simpara>
   </refsection>
  </refentry>

  
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear.pear-error.tostring">
   <refnamediv>
    <refname>PEAR_Error::toString()</refname>
    <refpurpose>make string representation</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>string <function>PEAR_Error::toString</function></funcdef>
      <paramdef choice="req"/>
     </funcprototype>
    </funcsynopsis>
   </refsynopsisdiv>
   <refsection xml:id="core.pear.pear-error.tostring.desc">
    <title xmlns="http://docbook.org/ns/docbook">Description</title>
    <para>
     Makes a string representation of the error object.
    </para>
   </refsection>   
   <refsection xml:id="core.pear.pear-error.tostring.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>
    <para>
     <parameter>string</parameter> - 
     object representation
    </para>
   </refsection>      
   <refsection xml:id="core.pear.pear-error.tostring.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>            
  </refentry>

  
 </section>

 
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear.system"><info><title>System</title></info>
 

 <para>
  Commandline functions
 </para>
 <para>
  <classname>System</classname> provides an API for
  cross platform compatible commandline programs.
 </para>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear.system.intro">
   <refnamediv>
    <refname>Introduction</refname>
    <refpurpose>General usage informations</refpurpose>
  </refnamediv>

  <refsection xml:id="core.pear.system.intro.clistyle"><info><title>Command line style</title></info>
     
    <para>
     The <classname>System</classname> functions are called like there
     commandline pendants
     <programlisting role="php">
   <![CDATA[
if (!System::rm('-r file1 dir1')) {
	print "Could not delete all the files";
}
   ]]>
     </programlisting>
     The arguments of the functions can be introduced as string or array:
    <programlisting role="php">
	System::rm(array('-r', 'file1', 'dir1'));
    </programlisting>
	System works like any other PHP function and will return
	<parameter>FALSE</parameter>,
	when the operation could not be completed entirely or partially. System
	won't stop when a error is found, it will try to continue. For example,
	if you are trying to delete three files and the first one can't be deleted,
	the next two files will be deleted but the function will return
	<parameter>FALSE</parameter>.
    </para>
	<para>
  Errors will be printed out using the PHP function 
  <function>trigger_error()</function> so all
	the System methods can be silenced prefix a '@' sign before the function
 call (for example: <command>@System::mkdir('-p dir1/dir2/dir3');</command>).
	</para>

  </refsection>
  <refsection xml:id="core.pear.system.intro.compatibility"><info><title>Compatibility</title></info>
    
    <para>
     <classname>System</classname> provides file system functions.
     They are named like the file system commands on Unix systems
     and supports the same options <emphasis>independent</emphasis>
     of your operation system.
    </para>
    <para>
     At the moment the functions are tested under Linux and Windows. Further
     reports about compatibility on other systems are welcome.
    </para>
    <warning>
     <para>
      In earlier versions of PHP 4, <function>unlink</function> may fail
      on Windows. This bug is already fixed in up-to-date versions.
     </para>
    </warning>
   </refsection>

   <refsection xml:id="core.pear.system.intro.manpages"><info><title>Man Pages</title></info>
    
    <para>
     This manual describes the parameters of the <classname>System</classname>
     functions, most only a string. The arguments and options of the specific
     command are <emphasis>not</emphasis> documented in the manual. Please take
     a look on the man-pages on unix-like systems
     <programlisting>
     <command>man</command> <parameter>commandname</parameter>
     </programlisting>
     or when man-pages not available on your system, visit the
     <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://unixhelp.ed.ac.uk/alphabetical/index.html">On-line UNIX manual pages</link>
    </para>
   </refsection>

  </refentry>

 
 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear.system.rm">
   <refnamediv>
    <refname>System::rm</refname>
    <refpurpose>remove files</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once "System.php";
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>mixed <function>System::rm</function></funcdef>
      
      <paramdef choice="req">
       string <parameter>$args</parameter>
      </paramdef>
      
                  
     </funcprototype>
    </funcsynopsis>
   </refsynopsisdiv>
   <refsection xml:id="core.pear.system.rm.desc">
    <title xmlns="http://docbook.org/ns/docbook">Description</title>
    <para>
     The rm command for removing files.
     Supports multiple files and dirs and also recursive deletes.
    </para>
   </refsection>   
   
   <refsection xml:id="core.pear.system.rm.parameter">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <itemizedlist>
      
      <listitem>
       <para>
        <parameter>string $args</parameter> -
        the arguments for rm
       </para>
      </listitem>      
            
     </itemizedlist>
    </para>
   </refsection>   
      
         
   <refsection xml:id="core.pear.system.rm.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>
    <para>
     <parameter>mixed</parameter> - <constant xmlns="http://docbook.org/ns/docbook">TRUE</constant> for success
    </para>
   </refsection>      
            
               
                
   <refsection xml:id="core.pear.system.rm.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>  
                 
    <simpara xmlns="http://docbook.org/ns/docbook">This function can be called
statically.</simpara>
    
                         
                             
  <simpara/>
   </refsection>    
                   
   <refsection xml:id="core.pear.system.rm.see">
    <title xmlns="http://docbook.org/ns/docbook">See</title>
    <para>
     <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://unixhelp.ed.ac.uk/CGI/man-cgi?rm"><command>rm</command>
    man page</link>
    </para>
   </refsection>         


  </refentry>

 
 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear.system.mkdir">
   <refnamediv>
    <refname>System::mkDir</refname>
    <refpurpose>create directories</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once "System.php";
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>bool <function>System::mkDir</function></funcdef>
      
      <paramdef choice="req">
       string <parameter>$args</parameter>
      </paramdef>
      
                  
     </funcprototype>
    </funcsynopsis>
   </refsynopsisdiv>
   <refsection xml:id="core.pear.system.mkdir.desc">
    <title xmlns="http://docbook.org/ns/docbook">Description</title>
    <para>
     Creates directories.
    </para>
   </refsection>   
   
   <refsection xml:id="core.pear.system.mkdir.parameter">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <itemizedlist>
      
      <listitem>
       <para>
        <parameter>string $args</parameter> -
        the name of the directory/-ies to create
       </para>
      </listitem>      
            
     </itemizedlist>
    </para>
   </refsection>   
      
         
   <refsection xml:id="core.pear.system.mkdir.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>
    <para>
     <parameter>bool</parameter> - <constant xmlns="http://docbook.org/ns/docbook">TRUE</constant> for success
    </para>
   </refsection>      
            
               
                
   <refsection xml:id="core.pear.system.mkdir.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>  
                 
    <simpara xmlns="http://docbook.org/ns/docbook">This function can be called
statically.</simpara>
    
                         
                             
  <simpara/>
   </refsection>    
   <refsection xml:id="core.pear.system.mkdir.see">
    <title xmlns="http://docbook.org/ns/docbook">See</title>
    <para>
     <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://unixhelp.ed.ac.uk/CGI/man-cgi?mkdir"><command>mkdir</command> man page</link>
    </para>
   </refsection>         
                   
  </refentry>

 
 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear.system.cat">
   <refnamediv>
    <refname>System::&amp;cat</refname>
    <refpurpose>concatenate files</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once "System.php";
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>boolean <function>System::&amp;cat</function></funcdef>
      
      <paramdef choice="req">
       string <parameter>$args</parameter>
      </paramdef>
      
                  
     </funcprototype>
    </funcsynopsis>
   </refsynopsisdiv>
   <refsection xml:id="core.pear.system.cat.desc">
    <title xmlns="http://docbook.org/ns/docbook">Description</title>
    <para>
     Concatenate files. The method uses <function>fopen</function>, 
     URLs should work too.
    </para>
   </refsection>   
   
   <refsection xml:id="core.pear.system.cat.parameter">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <itemizedlist>
      
      <listitem>
       <para>
        <parameter>string $args</parameter> -
        the arguments
       </para>
      </listitem>      
            
     </itemizedlist>
    </para>
   </refsection>   
      
         
   <refsection xml:id="core.pear.system.cat.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>
    <para>
     <parameter>boolean</parameter> - <constant xmlns="http://docbook.org/ns/docbook">TRUE</constant> on success
    </para>
   </refsection>      
            
               
                
   <refsection xml:id="core.pear.system.cat.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>  
                 
    <simpara xmlns="http://docbook.org/ns/docbook">This function can be called
statically.</simpara>
    
                         
                             
  <simpara/>
   </refsection>    
   <refsection xml:id="core.pear.system.cat.see">
    <title xmlns="http://docbook.org/ns/docbook">See</title>
    <para>
     <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://unixhelp.ed.ac.uk/CGI/man-cgi?cat"><command>cat</command> man page</link>
    </para>
   </refsection>         
   
   <refsection xml:id="core.pear.system.cat.example">
    <title xmlns="http://docbook.org/ns/docbook">Example</title>
    <example><info><title>Using <function>&amp;cat</function></title></info>
     
      <programlisting role="php">
       <![CDATA[        
       $var = System::cat('sample.txt test.txt');       
       System::cat('sample.txt test.txt > final.txt');
       System::cat('sample.txt test.txt >> final.txt');
]]>    
     </programlisting>
    </example>
   </refsection>         
  </refentry>


 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear.system.mktemp">
   <refnamediv>
    <refname>System::mktemp</refname>
    <refpurpose>Create temporary files or directories</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once "System.php";
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>mixed <function>System::mktemp</function></funcdef>      
      <paramdef choice="opt">
       string <parameter>$args</parameter>
       <initializer>null</initializer>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
   </refsynopsisdiv>
   <refsection xml:id="core.pear.system.mktemp.desc">
    <title xmlns="http://docbook.org/ns/docbook">Description</title>
    <para>
     Creates temporary files or directories. 
     This function will remove the created files when the scripts 
     finish its execution.     

    </para>
   </refsection>   
   
   <refsection xml:id="core.pear.system.mktemp.parameter">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <itemizedlist>
      
      <listitem>
       <para>
        <parameter>string $args</parameter> -
        The arguments
        <itemizedlist>
         <listitem>
          <para>
           <parameter>prefix</parameter> - 
           The string that will be prepended to the temp name
           (defaults to <parameter>tmp</parameter>)
          </para>
         </listitem>
         <listitem>
          <para>
           <parameter>-d</parameter> - 
           A temporary dir will be created instead of a file.
          </para>
         </listitem>
         <listitem>
          <para>
           <parameter>-t</parameter> - 
           The target dir where the temporary file or directory 
           will be created. If this parameter is missing, by default 
           the environment vars <parameter>TMP</parameter> on 
           Windows or <parameter>TMPDIR</parameter> on 
           Unix will be used. If these vars are also missing
           <parameter>c:\windows\temp</parameter> or 
           <parameter>/tmp</parameter> will be used.
          </para>
         </listitem>         
        </itemizedlist>
       </para>
      </listitem>      
            
     </itemizedlist>
    </para>
   </refsection>   
      
         
   <refsection xml:id="core.pear.system.mktemp.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>
    <para>
     <parameter>mixed</parameter> - 
     the full path of the created file or dir, or <constant xmlns="http://docbook.org/ns/docbook">FALSE</constant>
    </para>
   </refsection>      
            
               
                
   <refsection xml:id="core.pear.system.mktemp.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>  
                 
    <simpara xmlns="http://docbook.org/ns/docbook">This function can be called
statically.</simpara>
    
                         
                             
  <simpara/>
   </refsection>    
                   
   <refsection xml:id="core.pear.system.mktemp.see">
    <title xmlns="http://docbook.org/ns/docbook">See</title>
    <para>
     <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://unixhelp.ed.ac.uk/CGI/man-cgi?mktemp"><command>mktemp</command> man page</link>
    </para>
   </refsection>         

   <refsection xml:id="core.pear.system.mktemp.example">
    <title xmlns="http://docbook.org/ns/docbook">Example</title>
    <example><info><title>Using <function>mktemp</function></title></info>
     
      <programlisting role="php">
       <![CDATA[        
$tempfile = System::mktemp("prefix");       
$tempdir  = System::mktemp("-d prefix");
$tempfile = System::mktemp();
$tempfile = System::mktemp("-t /var/tmp prefix");
]]>    
     </programlisting>
    </example>
   </refsection>         
  </refentry>

 
 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear.system.tmpdir">
   <refnamediv>
    <refname>System::tmpdir</refname>
    <refpurpose>Get path of temporal directory</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once "System.php";
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>string <function>System::tmpdir</function></funcdef>
      
      
      <paramdef choice="req"/>
                  
     </funcprototype>
    </funcsynopsis>
   </refsynopsisdiv>
   <refsection xml:id="core.pear.system.tmpdir.desc">
    <title xmlns="http://docbook.org/ns/docbook">Description</title>
    <para>
     Get the path of the temporal directory set in the system 
     by looking in its environments variables.   
    </para>
   </refsection>   
      
         
   <refsection xml:id="core.pear.system.tmpdir.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>
    <para>
     <parameter>string</parameter> - The temporal directory on the system
    </para>
   </refsection>      
            
               
                
   <refsection xml:id="core.pear.system.tmpdir.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>  
                 
    <simpara xmlns="http://docbook.org/ns/docbook">This function can be called
statically.</simpara>
                            
    <para>
     php.ini-recommended removes the <parameter>E</parameter> from 
     the variables_order setting, making unavailable the $_ENV 
     array
    </para>
   </refsection>    
   <refsection xml:id="core.pear.system.tmpdir.see">
    <title xmlns="http://docbook.org/ns/docbook">See</title>
    <para>
     <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://unixhelp.ed.ac.uk/CGI/man-cgi?tmpdir"><command>tmpdir</command> man page</link>
    </para>
   </refsection>         
                   

  </refentry>

 
 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.pear.system.system.which">
   <refnamediv>
    <refname>System::which</refname>
    <refpurpose>show full path of a command</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once "System.php";
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>mixed <function>System::which</function></funcdef>
      <paramdef choice="req">
       string <parameter>$program</parameter>
      </paramdef>
      <paramdef choice="opt">
       boolean <parameter>$fallback</parameter>
       <initializer>false</initializer>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
   </refsynopsisdiv>
   <refsection xml:id="core.pear.system.system.which.desc">
    <title xmlns="http://docbook.org/ns/docbook">Description</title>
    <para>
     The command shows the full path of a command.
    </para>
   </refsection>   
   
   <refsection xml:id="core.pear.system.system.which.parameter">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <itemizedlist>
      
      <listitem>
       <para>
        <parameter>string $program</parameter> -
        the command to search for
       </para>
      </listitem>      
      
      <listitem>
       <para>
        <parameter>boolean $fallback</parameter> -
        value to return in case of program not found
       </para>
      </listitem>      
            
     </itemizedlist>
    </para>
   </refsection>   
      
         
   <refsection xml:id="core.pear.system.system.which.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>
    <para>
     <parameter>mixed</parameter> - 
     A string with the full path or <constant xmlns="http://docbook.org/ns/docbook">FALSE</constant> if not found
    </para>
   </refsection>      
            
               
                
   <refsection xml:id="core.pear.system.system.which.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>  
                 
    <simpara xmlns="http://docbook.org/ns/docbook">This function can be called
statically.</simpara>
    
                         
                             
  <simpara/>
   </refsection>    

   <refsection xml:id="core.pear.system.which.see">
    <title xmlns="http://docbook.org/ns/docbook">See</title>
    <para>
     <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://unixhelp.ed.ac.uk/CGI/man-cgi?which"><command>which</command> man page</link>
    </para>
   </refsection>         


  </refentry>

 
 
 </section>

</chapter>

   
<chapter xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm"><info><title>PEAR Installer classes</title></info>

 

 <para>
  The PEAR Installer classes provides an API for
  the administration and management
  of PEAR Packages.
 </para>
 <warning>
  <para>
   Documentation is not fully up-to-date with PEAR version 1.4.0.
  </para>
 </warning>


 
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-autoloader"><info><title>PEAR_Autoload</title></info>


<para>
 This class is for objects where you want to separate the code for  
 some methods into separate classes.  This is useful if you have a  
 class with not-frequently-used methods that contain lots of code  
 that you would like to avoid always parsing.
</para>
<para>
 Class Trees for <classname>PEAR_Autoloader</classname>
 <itemizedlist>
  <listitem>
   <para>PEAR
    <itemizedlist>
     <listitem>
      <para>PEAR_Autoloader</para>
     </listitem>
    </itemizedlist>
   </para>
  </listitem>
 </itemizedlist>
</para>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-autoloader.addaggregateobject">
   <refnamediv>
    <refname><function>PEAR_Autoloader::addAggregateObject</function></refname>
    <refpurpose>Add an aggregate object to object.</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
             require_once 'PEAR/autoloader.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef><replaceable>void</replaceable>       <function>PEAR_Autoloader::addAggregateObject</function></funcdef>
      <paramdef choice="req">string <parameter>$classname</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-autoloader.addaggregateobject.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>
             Add an aggregate object to this object.  If the specified class 
             is not defined, loading it will be attempted following PEAR's  file 
             naming scheme.  All the methods in the class will be  aggregated, 
             except private ones (name starting with an  underscore) and constructors.
     </para>
    </refsection>
   <refsection xml:id="core.ppm.pear-autoloader.addaggregateobject.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$classname</parameter>
       </term>      
       <listitem>
        <para>
         what class to instantiate for the object.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>
  
   <refsection xml:id="core.ppm.pear-autoloader.addaggregateobject.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>
 

<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-autoloader.addautoload">
   <refnamediv>
    <refname><function>PEAR_Autoloader::addAutoload</function></refname>
    <refpurpose>Add one or more autoload entries</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
             require_once 'PEAR/autoloader.php';
     </funcsynopsisinfo>
     <funcprototype>
             <funcdef><replaceable>void</replaceable>       <function>PEAR_Autoloader::addAutoload</function></funcdef>
      <paramdef choice="req">string <parameter>$method</parameter></paramdef>
      <paramdef choice="opt">string <parameter> ''$classname</parameter>
       <initializer>null</initializer>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-autoloader.addautoload.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>
      Add one or more autoload entries.
     </para>
    </refsection>
   <refsection xml:id="core.ppm.pear-autoloader.addautoload.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$method</parameter>
       </term>      
       <listitem>
        <para>
         which method to autoload
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$classname</parameter>
       </term>      
       <listitem>
        <para>
                which class to find the method in. 
                If the <parameter>$method</parameter> parameter is an array, this 
                parameter may be omitted (and will be ignored
                if not), and the <parameter>$method</parameter> parameter will be
                treated as an associative array with method
                names as keys and class names as values.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-autoloader.addautoload.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>
 

<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-autoloader.removeaggregateobject">
   <refnamediv>
    <refname><function>PEAR_Autoloader::removeAggregateObject</function></refname>
    <refpurpose>Remove an aggregate object</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/autoloader.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>bool       <function>PEAR_Autoloader::removeAggregateObject</function></funcdef>
      <paramdef choice="req">string <parameter>$classname</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-autoloader.removeaggregateobject.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>
      Remove an aggregate object.
     </para>
    </refsection>
   <refsection xml:id="core.ppm.pear-autoloader.removeaggregateobject.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$classname</parameter>
       </term>      
       <listitem>
        <para>
         the class of the object to remove
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-autoloader.removeaggregateobject.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>

    <para>
            <parameter>bool</parameter> Returns <constant xmlns="http://docbook.org/ns/docbook">TRUE</constant> on success, <constant xmlns="http://docbook.org/ns/docbook">FALSE</constant> on failure.
    </para>
   </refsection>

   <refsection xml:id="core.ppm.pear-autoloader.removeaggregateobject.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>
 

<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-autoloader.removeautoload">
   <refnamediv>
    <refname><function>PEAR_Autoloader::removeAutoload</function></refname>
    <refpurpose>Remove an autoload entry</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'autoloader.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>bool       <function>PEAR_Autoloader::removeAutoload</function></funcdef>
      <paramdef choice="req">string <parameter>$method</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-autoloader.removeautoload.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>
      Remove an autoload entry.
     </para>
    </refsection>
   <refsection xml:id="core.ppm.pear-autoloader.removeautoload.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$method</parameter>
       </term>      
       <listitem>
        <para>
         which method to remove the autoload entry for
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-autoloader.removeautoload.return">
           <title xmlns="http://docbook.org/ns/docbook">Return value</title>
        <para>
                <parameter>bool</parameter> Returns <constant xmlns="http://docbook.org/ns/docbook">TRUE</constant> on success, <constant xmlns="http://docbook.org/ns/docbook">FALSE</constant> on failure.
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-autoloader.removeautoload.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>
 

<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-autoloader.--call">
   <refnamediv>
    <refname><function>PEAR_Autoloader::__call</function></refname>
    <refpurpose>Overloaded object call handler</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/autoloader.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>mixed       <function>PEAR_Autoloader::__call</function></funcdef>
      <paramdef choice="req">string <parameter>$method</parameter></paramdef>
      <paramdef choice="req">string <parameter>$args</parameter></paramdef>
      <paramdef choice="req">mixed <parameter>&amp;$retval</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-autoloader.--call.desc">
    <title xmlns="http://docbook.org/ns/docbook">Description</title>
    <para>
     Overloaded object call handler, called each time an
     undefined/aggregated method is invoked. This method repeats
     the call in the right aggregate object and passes on 
     the return value.
    </para>
    </refsection>
   <refsection xml:id="core.ppm.pear-autoloader.--call.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$method</parameter>
       </term>      
       <listitem>
        <para>
         which method that was called
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$args</parameter>
       </term>      
       <listitem>
        <para>
         An array of the parameters passed in the     
         original call
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">mixed</type>
         <parameter>&amp;$retval</parameter>
       </term>      
       <listitem>
        <para>
        
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-autoloader.--call.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>
    <para>
     <parameter>mixed</parameter> -
     The return value from the aggregated method, or a 
     <classname>PEAR_Error</classname> if the called method was unknown.
    </para>
   </refsection>

   <refsection xml:id="core.ppm.pear-autoloader.--call.throws">
    <title xmlns="http://docbook.org/ns/docbook">Throws</title>
    <para>
     <table><title>Possible PEAR_Error values</title>
            
      <tgroup cols="4">

       <thead>
        <row>
         <entry>Error code</entry>
         <entry>Error value</entry>        
         <entry>Meaning</entry>        
         <entry>Solution</entry>        
        </row>
       </thead>
       <tbody>
        <row>
         <entry/>
         <entry><quote/></entry>
         <entry/>
         <entry/>
        </row>       
       </tbody>
      </tgroup>
     </table>
    </para>    
   </refsection>

   <refsection xml:id="core.ppm.pear-autoloader.--call.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>
 


</section>

 
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-builder"><info><title>PEAR_Builder</title></info>


<para>Class to handle building (compiling) extensions.</para>
<para>
        Class Trees for <classname>PEAR_Builder</classname>
</para>
<para>
 <itemizedlist>
  <listitem>
   <para>PEAR_Common</para>
    <itemizedlist>
     <listitem>
      <simpara>PEAR_Builder</simpara>
     </listitem>
    </itemizedlist>
  </listitem>
 </itemizedlist>
</para>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-builder.pear-builder">
   <refnamediv>
    <refname><function>PEAR_Builder::PEAR_Builder</function></refname>
    <refpurpose>constructor</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
             require_once 'PEAR/builder.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>void       <function>PEAR_Builder::PEAR_Builder</function></funcdef>
      <paramdef choice="req">object <parameter>&amp;$ui</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-builder.pear-builder.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>PEAR_Builder constructor</para>
    </refsection>
   <refsection xml:id="core.ppm.pear-builder.pear-builder.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">object</type>
         <parameter>&amp;$ui</parameter>
       </term>      
       <listitem>
        <para>
                user interface object (instance of <classname>PEAR_Frontend_*</classname>)
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>

   <refsection xml:id="core.ppm.pear-builder.pear-builder.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-builder.build">
   <refnamediv>
    <refname><function>PEAR_Builder::build</function></refname>
    <refpurpose>Build an extension from source</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/builder.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>array       <function>PEAR_Builder::build</function></funcdef>
      <paramdef choice="req">string <parameter>$descfile</parameter></paramdef>
      <paramdef choice="opt">mixed <parameter> $callback</parameter>
       <initializer>null</initializer>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-builder.build.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>Build an extension from source.  Runs <command>phpize</command> in the source directory, 
     but compiles in a temporary directory (/var/tmp/pear-build-USER/PACKAGE-VERSION).</para>
    </refsection>
   <refsection xml:id="core.ppm.pear-builder.build.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$descfile</parameter>
       </term>      
       <listitem>
        <para>
         path to XML package description file
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">mixed</type>
         <parameter>$callback</parameter>
       </term>      
       <listitem>
        <para>
         callback function used to report output
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-builder.build.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>
    <para>
      <parameter>array</parameter> -
      an array of associative arrays with built files, format: 
      <programlisting role="php">
      <![CDATA[
      array( array( 'file' => '/path/to/ext.so',
                    'php_api' => YYYYMMDD,
                    'zend_mod_api' => YYYYMMDD,
                    'zend_ext_api' =>; YYYYMMDD ),
       ... )
      ]]>
      </programlisting>
    </para>
   </refsection>

   <refsection xml:id="core.ppm.pear-builder.build.see">
    <title xmlns="http://docbook.org/ns/docbook">See</title>
    <para>
      PEAR_Common::infoFromDescriptionFile
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-builder.build.throws">
    <title xmlns="http://docbook.org/ns/docbook">Throws</title>
    <para>
     <table><title>Possible PEAR_Error values</title>
            
      <tgroup cols="4">

       <thead>
        <row>
         <entry>Error code</entry>
         <entry>Error value</entry>        
         <entry>Meaning</entry>        
         <entry>Solution</entry>        
        </row>
       </thead>
       <tbody>
        <row>
         <entry/>
         <entry><quote/></entry>
         <entry/>
         <entry/>
        </row>       
       </tbody>
      </tgroup>
     </table>
    </para>    
   </refsection>

   <refsection xml:id="core.ppm.pear-builder.build.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-builder.log"> 
   <refnamediv> 
    <refname><function>PEAR_Builder::log</function></refname> 
    <refpurpose/> 
   </refnamediv> 
   <refsynopsisdiv> 
    <funcsynopsis> 
     <funcsynopsisinfo> 
             require_once 'PEAR/builder.php'; 
     </funcsynopsisinfo> 
     <funcprototype> 
      <funcdef>void       <function>PEAR_Builder::log</function></funcdef> 
      <paramdef choice="req">mixed <parameter>$level</parameter></paramdef> 
      <paramdef choice="req">mixed <parameter>$msg</parameter></paramdef> 
     </funcprototype> 
    </funcsynopsis> 
    </refsynopsisdiv> 
    <refsection xml:id="core.ppm.pear-builder.log.desc"> 
     <title xmlns="http://docbook.org/ns/docbook">Description</title> 
     <para xmlns="http://docbook.org/ns/docbook">This package is not documented yet.</para> 
    </refsection> 
   <refsection xml:id="core.ppm.pear-builder.log.param"> 
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title> 
    <para> 
     <variablelist> 
      <varlistentry> 
       <term> 
        <type xmlns="http://docbook.org/ns/docbook">mixed</type> 
         <parameter>$level</parameter> 
       </term>       
       <listitem> 
        <para> 
          
        </para> 
       </listitem> 
      </varlistentry> 
      <varlistentry> 
       <term> 
        <type xmlns="http://docbook.org/ns/docbook">mixed</type> 
         <parameter>$msg</parameter> 
       </term>       
       <listitem> 
        <para> 
          
        </para> 
       </listitem> 
      </varlistentry> 
     </variablelist> 
    </para> 
   </refsection> 
 
   <refsection xml:id="core.ppm.pear-builder.log.note"> 
    <title xmlns="http://docbook.org/ns/docbook">Note</title> 
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara> 
   </refsection> 
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-builder.phpizecallback">
   <refnamediv>
    <refname><function>PEAR_Builder::phpizeCallback</function></refname>
    <refpurpose>Message callback function when running phpize</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
             require_once 'PEAR/builder.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef><replaceable>void</replaceable>       <function>PEAR_Builder::phpizeCallback</function></funcdef>
      <paramdef choice="req">string <parameter>$what</parameter></paramdef>
      <paramdef choice="req">mixed <parameter>$data</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-builder.phpizecallback.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>
      Message callback function used when running the <command>phpize</command> program.  
                      Extracts the API numbers used.  Ignores other message types than 
                      <quote>cmdoutput</quote>.
      </para>
    </refsection>
   <refsection xml:id="core.ppm.pear-builder.phpizecallback.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$what</parameter>
       </term>      
       <listitem>
        <para>
         the type of message
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">mixed</type>
         <parameter>$data</parameter>
       </term>      
       <listitem>
        <para>
         the message
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>

   <refsection xml:id="core.ppm.pear-builder.phpizecallback.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


</section>

 
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-channelfile"><info><title>PEAR_ChannelFile</title></info>
 
 <refentry xml:id="core.ppm.pear-channelfile-summary">
  <refnamediv>
   <refname>
    Class Summary
    <classname>PEAR_ChannelFile</classname>
   </refname>
   <refpurpose>The Channel handling class</refpurpose>
  </refnamediv>
  <refsection><info><title>The Channel handling class</title></info>
   
   <para>
    Represents channel.xml
   </para>
  </refsection>
  <refsection><info><title>
    Class Trees for
    <classname>PEAR_ChannelFile</classname>
   </title></info>
   
   <para>
    <itemizedlist>
     <listitem>
      <para>PEAR_ChannelFile</para>
     </listitem>
    </itemizedlist>
   </para>
  </refsection>
 </refentry>
 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-channelfile.pear-channelfile">
 <refnamediv>
  <refname>
   constructor
   <function>PEAR_ChannelFile::PEAR_ChannelFile</function>
  </refname>
  <refpurpose>PEAR_ChannelFile</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/ChannelFile.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     void constructor
     <function>PEAR_ChannelFile::PEAR_ChannelFile</function>
    </funcdef>
    <paramdef choice="req"/>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-channelfile.pear-channelfile.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Simply creates the local error stack for the PEAR_ChannelFile object.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-channelfile.pear-channelfile.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.pear-channelfile.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-channelfile.addfunction">
 <refnamediv>
  <refname>
   <function>PEAR_ChannelFile::addFunction</function>
  </refname>
  <refpurpose>Add a protocol to the provides section</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/ChannelFile.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     bool
     <function>PEAR_ChannelFile::addFunction</function>
    </funcdef>
    <paramdef choice="req">
     string
     <parameter>$type</parameter>
    </paramdef>
    <paramdef choice="req">
     string
     <parameter>$version</parameter>
    </paramdef>
    <paramdef choice="opt">
     string
     <parameter>
      $name = ''
     </parameter>
    </paramdef>
    <paramdef choice="opt">
     string
     <parameter>
      $mirror = false
     </parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-channelfile.addfunction.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Adds a supported xml-rpc or SOAP function to a channel definition file.
   The type should be <literal>xmlrpc</literal> or <literal>soap</literal> in
   lower-cased letters.  No validation is performed on insert.  For example:
  </para>
  <para>
   <programlisting role="php">
    <![CDATA[
<?php
require_once 'PEAR/ChannelFile.php';
$chan = new PEAR_ChannelFile;
$chan->setName('foo.example.com');
$chan->setSummary('demonstrate addFunction');
$chan->addFunction('xmlrpc', '1.0', 'people.list');
$chan->addFunction('oops', '1.0', 'bad.type');
?>
    ]]>
   </programlisting>
  </para>
  <para>
   The <literal>oops</literal> protocol will be successfully created, but
   will fail upon validation.   
  </para>
  <para>
   Adding a function to a mirror simply validated to ensure that the mirror already exists.
  </para>
  <para>
   <programlisting role="php">
    <![CDATA[
<?php
require_once 'PEAR/ChannelFile.php';
$chan = new PEAR_ChannelFile;
$chan->setName('foo.example.com');
$chan->setSummary('demonstrate addFunction');
// fails: mirror not found
$chan->addFunction('soap', '1.0', 'people.list', 'mirror.example.com');
$chan->addMirror('mirror.example.com');
// succeeds
$chan->addFunction('soap', '1.0', 'people.list', 'mirror.example.com');
?>
    ]]>
   </programlisting>
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-channelfile.addfunction.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$type</parameter>
     </term>
     <listitem>
      <para>protocol type</para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$version</parameter>
     </term>
     <listitem>
      <para>protocol version</para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$name</parameter>
     </term>
     <listitem>
      <para>protocol name, if any</para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$mirror</parameter>
     </term>
     <listitem>
      <para>mirror name, if this is a mirror's protocol</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.addfunction.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.addfunction.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-channelfile.addmirror">
 <refnamediv>
  <refname>
   <function>PEAR_ChannelFile::addMirror</function>
  </refname>
  <refpurpose>addMirror</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/ChannelFile.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     boolean
     <function>PEAR_ChannelFile::addMirror</function>
    </funcdef>
    <paramdef choice="req">
     string
     <parameter>$server</parameter>
    </paramdef>
    <paramdef choice="opt">
     int
     <parameter>
      $port = null
     </parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-channelfile.addmirror.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Add a mirror server.  Note that mirrors must be added to a channel.xml in order
   for users to use them.  Unofficial mirrors are not allowed without user intervention.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-channelfile.addmirror.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$server</parameter>
     </term>
     <listitem>
      <para>mirror server</para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">integer</type>
      <parameter>$port</parameter>
     </term>
     <listitem>
      <para>mirror http port</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.addmirror.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.addmirror.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-channelfile.addmirrorfunction">
 <refnamediv>
  <refname>
   <function>PEAR_ChannelFile::addMirrorFunction</function>
  </refname>
  <refpurpose>Add a protocol to a mirror's provides section</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/ChannelFile.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     bool
     <function>PEAR_ChannelFile::addMirrorFunction</function>
    </funcdef>
    <paramdef choice="req">
     string
     <parameter>$mirror</parameter>
    </paramdef>
    <paramdef choice="req">
     string
     <parameter>$type</parameter>
    </paramdef>
    <paramdef choice="req">
     string
     <parameter>$version</parameter>
    </paramdef>
    <paramdef choice="opt">
     string
     <parameter>
      $name = ''
     </parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-channelfile.addmirrorfunction.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   This is a direct way to add a <literal>xmlrpc</literal> or <literal>soap</literal>
   function to a mirror.  See docs for
   <link linkend="core.ppm.pear-channelfile.addfunction"><function>addFunction</function></link>.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-channelfile.addmirrorfunction.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$mirror</parameter>
     </term>
     <listitem>
      <para>mirror name (server)</para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$type</parameter>
     </term>
     <listitem>
      <para>protocol type</para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$version</parameter>
     </term>
     <listitem>
      <para>protocol version</para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$name</parameter>
     </term>
     <listitem>
      <para>protocol name, if any</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.addmirrorfunction.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.addmirrorfunction.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-channelfile.fromany">
 <refnamediv>
  <refname>
   <function>PEAR_ChannelFile::fromAny</function>
  </refname>
  <refpurpose>Returns channel information from different sources</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/ChannelFile.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     bool
     <function>PEAR_ChannelFile::fromAny</function>
    </funcdef>
    <paramdef choice="req">
     string
     <parameter>$info</parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-channelfile.fromany.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Parse data from either a string or a channel.xml file.
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.fromany.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$info</parameter>
     </term>
     <listitem>
      <para>
       Filename of the source, or the source itself
</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.fromany.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.fromany.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-channelfile.fromarray">
 <refnamediv>
  <refname>
   <function>PEAR_ChannelFile::fromArray</function>
  </refname>
  <refpurpose>fromArray</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/ChannelFile.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     <replaceable>
      <link linkend="core.ppm.pear-channelfile-summary">
       <classname>PEAR_ChannelFile</classname>
      </link>
      |false
     </replaceable>
     <function>PEAR_ChannelFile::fromArray</function>
    </funcdef>
    <paramdef choice="req">
     array
     <parameter>$data</parameter>
    </paramdef>
    <paramdef choice="opt">
     mixed
     <parameter>
      $compatibility</parameter>
      <initializer>false</initializer>
    </paramdef>
    <paramdef choice="opt">
     mixed
     <parameter>
      $stackClass = 'PEAR_ErrorStack'
     </parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-channelfile.fromarray.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Use this method with caution.  This is intended to allow easy import of
   a pre-parsed channel.xml from another PEAR_ChannelFile class.  It also makes
   possible the registry storage of channel.xml.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-channelfile.fromarray.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">array</type>
      <parameter>$data</parameter>
     </term>
     <listitem>
      <para>
       The pre-parsed channel data
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">mixed</type>
      <parameter>$compatibility</parameter>
     </term>
     <listitem>
      <para>
       
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">mixed</type>
      <parameter>$stackClass</parameter>
     </term>
     <listitem>
      <para/>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.fromarray.returns">
  <title xmlns="http://docbook.org/ns/docbook">Return value</title>
  <para>
   <emphasis>returns</emphasis>
   false if invalid
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.fromarray.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.fromarray.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function should be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-channelfile.fromxmlfile">
 <refnamediv>
  <refname>
   <function>PEAR_ChannelFile::fromXmlFile</function>
  </refname>
  <refpurpose>
   Parse a channel.xml file.  Expects the name of  a channel xml file as
   input.
</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/ChannelFile.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     bool
     <function>PEAR_ChannelFile::fromXmlFile</function>
    </funcdef>
    <paramdef choice="req">
     string
     <parameter>$descfile</parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-channelfile.fromxmlfile.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Parse the contents of a channel.xml and store in the current PEAR_ChannelFile object.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-channelfile.fromxmlfile.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$descfile</parameter>
     </term>
     <listitem>
      <para>name of channel xml file</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.fromxmlfile.returns">
  <title xmlns="http://docbook.org/ns/docbook">Return value</title>
  <para>
   <emphasis>returns</emphasis>
   success of parsing
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.fromxmlfile.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.fromxmlfile.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-channelfile.fromxmlstring">
 <refnamediv>
  <refname>
   <function>PEAR_ChannelFile::fromXmlString</function>
  </refname>
  <refpurpose>fromXmlString</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/ChannelFile.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     bool
     <function>PEAR_ChannelFile::fromXmlString</function>
    </funcdef>
    <paramdef choice="req">
     string
     <parameter>$data</parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-channelfile.fromxmlstring.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Parse the contents of a channel.xml and store in the current PEAR_ChannelFile object.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-channelfile.fromxmlstring.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$data</parameter>
     </term>
     <listitem>
      <para>contents of package.xml file</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.fromxmlstring.returns">
  <title xmlns="http://docbook.org/ns/docbook">Return value</title>
  <para>
   <emphasis>returns</emphasis>
   success of parsing
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.fromxmlstring.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.fromxmlstring.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-channelfile.getalias">
 <refnamediv>
  <refname>
   <function>PEAR_ChannelFile::getAlias</function>
  </refname>
  <refpurpose>Return the suggested alias users can use to refer to this channel on the command-line.</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/ChannelFile.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     string
     <function>PEAR_ChannelFile::getAlias</function>
    </funcdef>
    <paramdef choice="req"/>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-channelfile.getalias.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   This returns the channel alias.  For instance, channel <literal>pear.php.net</literal>'s
   alias is <literal>pear</literal>, channel <literal>pecl.php.net</literal>'s alias is
   <literal>pecl</literal>.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-channelfile.getalias.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.getalias.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-channelfile.getbaseurl">
 <refnamediv>
  <refname>
   <function>PEAR_ChannelFile::getBaseURL</function>
  </refname>
  <refpurpose>Get the URL to access a base resource.</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/ChannelFile.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     string
     <function>PEAR_ChannelFile::getBaseURL</function>
    </funcdef>
    <paramdef choice="req">
     string
     <parameter>$resourceType</parameter>
    </paramdef>
    <paramdef choice="opt">
     string|false
     <parameter>$mirror</parameter>
     <initializer>false</initializer>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-channelfile.getbaseurl.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>Hyperlinks in the returned xml will be used to retrieve the proper information  needed.  This allows extreme extensibility and flexibility in implementation</para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.getbaseurl.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$resourceType</parameter>
     </term>
     <listitem>
      <para>Resource Type to retrieve</para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">mixed</type>
      <parameter>$mirror</parameter>
     </term>
     <listitem>
      <para>
       Mirror name, or false for primary server.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.getbaseurl.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.getbaseurl.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-channelfile.geterrors">
 <refnamediv>
  <refname>
   <function>PEAR_ChannelFile::getErrors</function>
  </refname>
  <refpurpose>Wrapper to PEAR_ErrorStack::getErrors()</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/ChannelFile.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     array
     <function>PEAR_ChannelFile::getErrors</function>
    </funcdef>
    <paramdef choice="opt">
     boolean
     <parameter>$purge</parameter>
     <initializer>false</initializer>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-channelfile.geterrors.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Retrieve any errors from the last validation attempt.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-channelfile.geterrors.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">boolean</type>
      <parameter>$purge</parameter>
     </term>
     <listitem>
      <para>determines whether to purge the error stack after retrieving</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.geterrors.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.geterrors.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-channelfile.getfunction">
 <refnamediv>
  <refname>
   <function>PEAR_ChannelFile::getFunction</function>
  </refname>
  <refpurpose>getFunction</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/ChannelFile.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     array
     <function>PEAR_ChannelFile::getFunction</function>
    </funcdef>
    <paramdef choice="req">
     string
     <parameter>$type</parameter>
    </paramdef>
    <paramdef choice="opt">
     string
     <parameter>$name</parameter>
     <initializer>null</initializer>
    </paramdef>
    <paramdef choice="opt">
     string
     <parameter>$mirror</parameter>
     <initializer>false</initializer>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-channelfile.getfunction.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Retrieve the xml representation of a function.  If found, the array is of format:
  </para>
  <para>
   <programlisting role="php">
    <![CDATA[
<?php
array(
 '_content' => 'functionname',
 'attribs' => array('version' => 'version.number')
);
?>
    ]]>
   </programlisting>
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-channelfile.getfunction.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$type</parameter>
     </term>
     <listitem>
      <para>Protocol type</para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$name</parameter>
     </term>
     <listitem>
      <para>
       Function name (<constant xmlns="http://docbook.org/ns/docbook">NULL</constant> to return the                first protocol of the
       type requested)
</para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$mirror</parameter>
     </term>
     <listitem>
      <para>Mirror name, if any</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.getfunction.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.getfunction.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-channelfile.getfunctions">
 <refnamediv>
  <refname>
   <function>PEAR_ChannelFile::getFunctions</function>
  </refname>
  <refpurpose>Retrieve a list of all xmlrpc/soap functions</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/ChannelFile.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     <replaceable>array|false</replaceable>
     <function>PEAR_ChannelFile::getFunctions</function>
    </funcdef>
    <paramdef choice="req">
     string
     <parameter>$protocol</parameter>
    </paramdef>
    <paramdef choice="opt">
     string
     <parameter>$mirror</parameter>
     <initializer>false</initializer>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-channelfile.getfunctions.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   This retrieves an array of all defined <literal>xmlrpc</literal> and <literal>soap</literal>
   functions.  Use <link linkend="core.ppm.pear-channelfile.getbaseurl"><function>getBaseURL</function></link>
   to access <literal>rest</literal> base URLs.
  </para>
  <para>
   The format of each function is the same as is returned by <link linkend="core.ppm.pear-channelfile.getfunction"><function>getFunction</function></link>
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-channelfile.getfunctions.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$protocol</parameter>
     </term>
     <listitem>
      <para>protocol type (xmlrpc, soap)</para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$mirror</parameter>
     </term>
     <listitem>
      <para>Mirror name</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.getfunctions.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.getfunctions.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-channelfile.getmirror">
 <refnamediv>
  <refname>
   <function>PEAR_ChannelFile::getMirror</function>
  </refname>
  <refpurpose>Get the unserialized XML representing a mirror</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/ChannelFile.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     <replaceable>array|false</replaceable>
     <function>PEAR_ChannelFile::getMirror</function>
    </funcdef>
    <paramdef choice="req">
     mixed
     <parameter>$server</parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-channelfile.getmirror.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   This returns the entire contents of the &lt;mirror&gt; tag as unserialized by the
   parser.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-channelfile.getmirror.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">mixed</type>
      <parameter>$server</parameter>
     </term>
     <listitem>
      <para/>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.getmirror.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.getmirror.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-channelfile.getmirrors">
 <refnamediv>
  <refname>
   <function>PEAR_ChannelFile::getMirrors</function>
  </refname>
  <refpurpose>Retrieve a list of all mirrors and their contents</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/ChannelFile.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     array
     <function>PEAR_ChannelFile::getMirrors</function>
    </funcdef>
    <paramdef choice="req"/>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-channelfile.getmirrors.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   This returns an array of mirror information in the format defined by <link linkend="core.ppm.pear-channelfile.getmirror"><function>getMirror</function></link>
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-channelfile.getmirrors.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.getmirrors.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-channelfile.getname">
 <refnamediv>
  <refname>
   <function>PEAR_ChannelFile::getName</function>
  </refname>
  <refpurpose>retrieve the channel name</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/ChannelFile.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     <replaceable>string|false</replaceable>
     <function>PEAR_ChannelFile::getName</function>
    </funcdef>
    <paramdef choice="req"/>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-channelfile.getname.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Note that the channel name is the channel server.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-channelfile.getname.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.getname.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-channelfile.getpath">
 <refnamediv>
  <refname>
   <function>PEAR_ChannelFile::getPath</function>
  </refname>
  <refpurpose>getPath</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/ChannelFile.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     string
     <function>PEAR_ChannelFile::getPath</function>
    </funcdef>
    <paramdef choice="req">
     string
     <parameter>$protocol</parameter>
    </paramdef>
    <paramdef choice="opt">
     string|false
     <parameter>$mirror</parameter>
     <initializer>false</initializer>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-channelfile.getpath.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Retrieve the relative path to access the protocol desired.  If the channel is named
   <literal>foo.example.com</literal> and xmlrpc is accessed at <literal>foo.example.com/xml/rpc</literal>
   then path will be <literal>xml/rpc</literal>.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-channelfile.getpath.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$protocol</parameter>
     </term>
     <listitem>
      <para><literal>xmlrpc</literal> or <literal>soap</literal></para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>|<constant xmlns="http://docbook.org/ns/docbook">FALSE</constant>
      <parameter>$mirror</parameter>
     </term>
     <listitem>
      <para>mirror name or <constant xmlns="http://docbook.org/ns/docbook">FALSE</constant> for primary server</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.getpath.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.getpath.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-channelfile.getport">
 <refnamediv>
  <refname>
   <function>PEAR_ChannelFile::getPort</function>
  </refname>
  <refpurpose>retrieve the socket port used to connect to the server</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/ChannelFile.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     int|80
     <function>PEAR_ChannelFile::getPort</function>
    </funcdef>
    <paramdef choice="opt">
     mixed
     <parameter>$mirror</parameter>
     <initializer>false</initializer>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-channelfile.getport.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   web services are served through http servers, and so most servers use port 80.
   This function can be used to determine if a non-standard port is in use at a channel.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-channelfile.getport.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">mixed</type>
      <parameter>$mirror</parameter>
     </term>
     <listitem>
      <para>
       Mirror name or <constant xmlns="http://docbook.org/ns/docbook">FALSE</constant> for primary server
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.getport.returns">
  <title xmlns="http://docbook.org/ns/docbook">Return value</title>
  <para>
   <emphasis>returns</emphasis>
   port number to connect to
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.getport.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.getport.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-channelfile.getserver">
 <refnamediv>
  <refname>
   <function>PEAR_ChannelFile::getServer</function>
  </refname>
  <refpurpose>Retrieve the channel server</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/ChannelFile.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     <replaceable>string|false</replaceable>
     <function>PEAR_ChannelFile::getServer</function>
    </funcdef>
    <paramdef choice="req"/>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-channelfile.getserver.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   This is an alias for <link linkend="core.ppm.pear-channelfile.getname"><function>getName</function></link>.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-channelfile.getserver.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.getserver.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-channelfile.getssl">
 <refnamediv>
  <refname>
   <function>PEAR_ChannelFile::getSSL</function>
  </refname>
  <refpurpose>get SSL support for a channel or mirror</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/ChannelFile.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     bool
     <function>PEAR_ChannelFile::getSSL</function>
    </funcdef>
    <paramdef choice="opt">
     mixed
     <parameter>$mirror</parameter>
     <initializer>false</initializer>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-channelfile.getssl.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   This function can be used to determine whether a channel or mirror requires a
   secure connection through SSL in order to access the packages.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-channelfile.getssl.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>|<constant xmlns="http://docbook.org/ns/docbook">FALSE</constant>
      <parameter>$mirror</parameter>
     </term>
     <listitem>
      <para>
       Mirror name or false for primary server
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.getssl.returns">
  <title xmlns="http://docbook.org/ns/docbook">Return value</title>
  <para>
   <emphasis>returns</emphasis>
   Determines whether secure sockets layer (SSL) is used to connect to this channel
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.getssl.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.getssl.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-channelfile.getsummary">
 <refnamediv>
  <refname>
   <function>PEAR_ChannelFile::getSummary</function>
  </refname>
  <refpurpose>Get channel summary</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/ChannelFile.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     <replaceable>string|false</replaceable>
     <function>PEAR_ChannelFile::getSummary</function>
    </funcdef>
    <paramdef choice="req"/>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-channelfile.getsummary.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Return the brief description of a channel's purpose.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-channelfile.getsummary.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.getsummary.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-channelfile.getvalidationobject">
 <refnamediv>
  <refname>
   <function>PEAR_ChannelFile::getValidationObject</function>
  </refname>
  <refpurpose>Retrieve the object that can be used for custom validation</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/ChannelFile.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     <replaceable>PEAR_Validate|false</replaceable>
     &amp;
     <function>PEAR_ChannelFile::getValidationObject</function>
    </funcdef>
    <paramdef choice="opt">
     string|false
     <parameter>$package</parameter>
     <initializer>false</initializer>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-channelfile.getvalidationobject.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Retrieve the channel validation object.  The package parameter is intended to notify
   <function>getValidationObject</function> of the package to be validated.  If the package
   is in fact the channel validation package, then PEAR_Validate will be used for validation.
   This prevents an endless loop that would otherwise occur.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-channelfile.getvalidationobject.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>|<constant xmlns="http://docbook.org/ns/docbook">FALSE</constant>
      <parameter>$package</parameter>
     </term>
     <listitem>
      <para>
       The name of the package to validate.  If the package is
       the channel validation package, <classname>PEAR_Validate</classname> is returned.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.getvalidationobject.returns">
  <title xmlns="http://docbook.org/ns/docbook">Return value</title>
  <para>
   <emphasis>returns</emphasis>
   false is returned if the validation package          cannot be located
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.getvalidationobject.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.getvalidationobject.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-channelfile.getvalidationpackage">
 <refnamediv>
  <refname>
   <function>PEAR_ChannelFile::getValidationPackage</function>
  </refname>
  <refpurpose>Retrieve the name of the validation package for this channel</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/ChannelFile.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     <replaceable>string|false</replaceable>
     <function>PEAR_ChannelFile::getValidationPackage</function>
    </funcdef>
    <paramdef choice="req"/>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-channelfile.getvalidationpackage.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Retrieve the name of the channel's validation package as defined in channel.xml
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-channelfile.getvalidationpackage.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.getvalidationpackage.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-channelfile.isincludeable">
 <refnamediv>
  <refname>
   <function>PEAR_ChannelFile::isIncludeable</function>
  </refname>
  <refpurpose>Determine whether a file exists in the include_path and is readable</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/ChannelFile.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     bool
     <function>PEAR_ChannelFile::isIncludeable</function>
    </funcdef>
    <paramdef choice="req">
     string
     <parameter>$path</parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-channelfile.isincludeable.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Determine whether a file exists in the include_path and is readable
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-channelfile.isincludeable.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$path</parameter>
     </term>
     <listitem>
      <para>
       Relative path to file.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.isincludeable.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.isincludeable.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-channelfile.lastmodified">
 <refnamediv>
  <refname>
   <function>PEAR_ChannelFile::lastModified</function>
  </refname>
  <refpurpose>This function is used by the channel updater and retrieves a value set by the registry, or the current time if it has not been set</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/ChannelFile.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     string
     <function>PEAR_ChannelFile::lastModified</function>
    </funcdef>
    <paramdef choice="req"/>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-channelfile.lastmodified.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>\
   This method is used by the <literal>channel-update</literal> command in order to
   determine whether the local copy of channel.xml is up-to-date.
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.lastmodified.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.lastmodified.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-channelfile.resetfunctions">
 <refnamediv>
  <refname>
   <function>PEAR_ChannelFile::resetFunctions</function>
  </refname>
  <refpurpose>Empty all protocol definitions</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/ChannelFile.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     void
     <function>PEAR_ChannelFile::resetFunctions</function>
    </funcdef>
    <paramdef choice="req">
     string
     <parameter>$type</parameter>
    </paramdef>
    <paramdef choice="opt">
     string|false
     <parameter>$mirror</parameter>
     <initializer>false</initializer>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-channelfile.resetfunctions.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Clear all functions defined in the channel.xml, in order to start adding a new list.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-channelfile.resetfunctions.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$type</parameter>
     </term>
     <listitem>
      <para>protocol type (xmlrpc, soap)</para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>|<constant xmlns="http://docbook.org/ns/docbook">FALSE</constant>
      <parameter>$mirror</parameter>
     </term>
     <listitem>
      <para>mirror name, if any</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.resetfunctions.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.resetfunctions.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-channelfile.resetrest">
 <refnamediv>
  <refname>
   <function>PEAR_ChannelFile::resetREST</function>
  </refname>
  <refpurpose>Since REST does not implement RPC, provide this as a logical wrapper around resetFunctions for REST</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/ChannelFile.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     void
     <function>PEAR_ChannelFile::resetREST</function>
    </funcdef>
    <paramdef choice="opt">
     string|false
     <parameter>$mirror</parameter>
     <initializer>false</initializer>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-channelfile.resetrest.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Similar to <link linkend="core.ppm.pear-channelfile.resetfunctions"><function>resetFunctions</function></link>,
   <function>resetREST</function> removes all REST base URLs in order to start adding new
   REST functions to a channel.
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.resetrest.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>|<constant xmlns="http://docbook.org/ns/docbook">FALSE</constant>
      <parameter>$mirror</parameter>
     </term>
     <listitem>
      <para>mirror name, if any</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.resetrest.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.resetrest.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-channelfile.setalias">
 <refnamediv>
  <refname>
   <function>PEAR_ChannelFile::setAlias</function>
  </refname>
  <refpurpose>Set the channel alias</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/ChannelFile.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     boolean
     <function>PEAR_ChannelFile::setAlias</function>
    </funcdef>
    <paramdef choice="req">
     string
     <parameter>$alias</parameter>
    </paramdef>
    <paramdef choice="opt">
     boolean
     <parameter>$local</parameter>
     <initializer>false</initializer>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-channelfile.setalias.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Set the suggested alias that users can use on the command-line as a shortcut access to this
   channel.  For instance, channel <literal>pear.php.net</literal>'s alias is <literal>pear</literal>.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-channelfile.setalias.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$alias</parameter>
     </term>
     <listitem>
      <para>
       The alias
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">boolean</type>
      <parameter>$local</parameter>
     </term>
     <listitem>
      <para>
       determines whether the alias is in channel.xml or local.  If local, then
       this is the result of a <literal>pear channel-alias</literal> command.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.setalias.returns">
  <title xmlns="http://docbook.org/ns/docbook">Return value</title>
  <para>
   <emphasis>returns</emphasis>
   success
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.setalias.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.setalias.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-channelfile.setbaseurl">
 <refnamediv>
  <refname>
   <function>PEAR_ChannelFile::setBaseURL</function>
  </refname>
  <refpurpose>set the base URL for a REST resource, or set of REST resources</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/ChannelFile.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     void
     <function>PEAR_ChannelFile::setBaseURL</function>
    </funcdef>
    <paramdef choice="req">
     string
     <parameter>$resourceType</parameter>
    </paramdef>
    <paramdef choice="req">
     string
     <parameter>$url</parameter>
    </paramdef>
    <paramdef choice="opt">
     string|false
     <parameter>$mirror</parameter>
     <initializer>false</initializer>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-channelfile.setbaseurl.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Set the base URL that users should use to access a REST resource or
   set of REST resources.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-channelfile.setbaseurl.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$resourceType</parameter>
     </term>
     <listitem>
      <para>Resource Type this url links to</para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$url</parameter>
     </term>
     <listitem>
      <para>URL</para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>|<constant xmlns="http://docbook.org/ns/docbook">FALSE</constant>
      <parameter>$mirror</parameter>
     </term>
     <listitem>
      <para>mirror name, if this is not a primary server REST base URL</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.setbaseurl.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.setbaseurl.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-channelfile.setdefaultpearprotocols">
 <refnamediv>
  <refname>
   <function>PEAR_ChannelFile::setDefaultPEARProtocols</function>
  </refname>
  <refpurpose>Set a channel's protocols to the protocols supported by pearweb</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/ChannelFile.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     void
     <function>PEAR_ChannelFile::setDefaultPEARProtocols</function>
    </funcdef>
    <paramdef choice="opt">
     string
     <parameter>
      $version = '1.0'
     </parameter>
    </paramdef>
    <paramdef choice="opt">
     string|false
     <parameter>$mirror</parameter>
     <initializer>false</initializer>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-channelfile.setdefaultpearprotocols.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   This method sets up a channel's <literal>xmlrpc</literal> protocols to match
   that of pearweb (pear.php.net).  Note that it does not configure REST resources,
   that must be done manually through <link linkend="core.ppm.pear-channelfile.setbaseurl"><function>setBaseURL</function></link>.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-channelfile.setdefaultpearprotocols.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$version</parameter>
     </term>
     <listitem>
      <para>
       version of pearweb protocols to use.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>|<constant xmlns="http://docbook.org/ns/docbook">FALSE</constant>
      <parameter>$mirror</parameter>
     </term>
     <listitem>
      <para>
       Mirror name or false for primary server.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.setdefaultpearprotocols.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.setdefaultpearprotocols.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-channelfile.setname">
 <refnamediv>
  <refname>
   <function>PEAR_ChannelFile::setName</function>
  </refname>
  <refpurpose>setName</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/ChannelFile.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     <replaceable>string|false</replaceable>
     <function>PEAR_ChannelFile::setName</function>
    </funcdef>
    <paramdef choice="req">
     string
     <parameter>$name</parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-channelfile.setname.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Set the primary server (and name) of the channel.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-channelfile.setname.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$name</parameter>
     </term>
     <listitem>
      <para>
       Channel name.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.setname.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.setname.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-channelfile.setpath">
 <refnamediv>
  <refname>
   <function>PEAR_ChannelFile::setPath</function>
  </refname>
  <refpurpose>Set the file path for xmlrpc or soap</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/ChannelFile.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     void
     <function>PEAR_ChannelFile::setPath</function>
    </funcdef>
    <paramdef choice="req">
     string
     <parameter>$protocol</parameter>
    </paramdef>
    <paramdef choice="req">
     string|false
     <parameter>$path</parameter>
    </paramdef>
    <paramdef choice="opt">
     string|false
     <parameter>$mirror</parameter>
     <initializer>false</initializer>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-channelfile.setpath.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Set the relative location to the channel that should be used to connect to the
   selected protocol.  Defaults are <literal>xmlrpc.php</literal> for xml-rpc and
   <literal>soap.php</literal> for SOAP.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-channelfile.setpath.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$protocol</parameter>
     </term>
     <listitem>
      <para>
       <literal>xmlrpc</literal> or <literal>soap</literal>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>|<constant xmlns="http://docbook.org/ns/docbook">FALSE</constant>
      <parameter>$path</parameter>
     </term>
     <listitem>
      <para>name of the mirror server, or <constant xmlns="http://docbook.org/ns/docbook">FALSE</constant> for the primary</para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>|<constant xmlns="http://docbook.org/ns/docbook">FALSE</constant>
      <parameter>$mirror</parameter>
     </term>
     <listitem>
      <para>
       Mirror name or false for primary server.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.setpath.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.setpath.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-channelfile.setport">
 <refnamediv>
  <refname>
   <function>PEAR_ChannelFile::setPort</function>
  </refname>
  <refpurpose>Set the socket number (port) that is used to connect to this channel</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/ChannelFile.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     void
     <function>PEAR_ChannelFile::setPort</function>
    </funcdef>
    <paramdef choice="req">
     integer
     <parameter>$port</parameter>
    </paramdef>
    <paramdef choice="opt">
     string|false
     <parameter>$mirror</parameter>
     <initializer>false</initializer>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-channelfile.setport.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   As web services connect to channels through web servers, this can be used to set the
   port that should be used to connect.  Default is 80 for regular webservers, and 443 for
   SSL secure servers.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-channelfile.setport.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">integer</type>
      <parameter>$port</parameter>
     </term>
     <listitem>
      <para>
       port number
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>|<constant xmlns="http://docbook.org/ns/docbook">FALSE</constant>
      <parameter>$mirror</parameter>
     </term>
     <listitem>
      <para>name of the mirror server, or <constant xmlns="http://docbook.org/ns/docbook">FALSE</constant> for the primary server</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.setport.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.setport.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-channelfile.setserver">
 <refnamediv>
  <refname>
   <function>PEAR_ChannelFile::setServer</function>
  </refname>
  <refpurpose>set the Channel server</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/ChannelFile.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     <replaceable>string|false</replaceable>
     <function>PEAR_ChannelFile::setServer</function>
    </funcdef>
    <paramdef choice="req">
     string
     <parameter>$server</parameter>
    </paramdef>
    <paramdef choice="opt">
     string|false
     <parameter>$mirror</parameter>
     <initializer>false</initializer>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-channelfile.setserver.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   This is an alias to <link linkend="core.ppm.pear-channelfile.setname"><function>setName</function></link>.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-channelfile.setserver.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$server</parameter>
     </term>
     <listitem>
      <para>
       Server name
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>|<constant xmlns="http://docbook.org/ns/docbook">FALSE</constant>
      <parameter>$mirror</parameter>
     </term>
     <listitem>
      <para>
       Mirror server name or <constant xmlns="http://docbook.org/ns/docbook">FALSE</constant> for primary server.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.setserver.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.setserver.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-channelfile.setssl">
 <refnamediv>
  <refname>
   <function>PEAR_ChannelFile::setSSL</function>
  </refname>
  <refpurpose>Sets whether SSL is used to connect to this channel</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/ChannelFile.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     void
     <function>PEAR_ChannelFile::setSSL</function>
    </funcdef>
    <paramdef choice="opt">
     bool
     <parameter>$ssl</parameter>
     <initializer>true</initializer>
    </paramdef>
    <paramdef choice="opt">
     string|false
     <parameter>$mirror</parameter>
     <initializer>false</initializer>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-channelfile.setssl.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   This function is used to inform the PEAR installer to use SSL when connecting
   to this channel server.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-channelfile.setssl.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">boolean</type>
      <parameter>$ssl</parameter>
     </term>
     <listitem>
      <para>Determines whether to turn on SSL support or turn it off</para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>|<constant xmlns="http://docbook.org/ns/docbook">FALSE</constant>
      <parameter>$mirror</parameter>
     </term>
     <listitem>
      <para>name of the mirror server, or <constant xmlns="http://docbook.org/ns/docbook">FALSE</constant> for the primary server</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.setssl.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.setssl.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-channelfile.setsummary">
 <refnamediv>
  <refname>
   <function>PEAR_ChannelFile::setSummary</function>
  </refname>
  <refpurpose>set the summary of a channel's purpose</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/ChannelFile.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     boolean
     <function>PEAR_ChannelFile::setSummary</function>
    </funcdef>
    <paramdef choice="req">
     string
     <parameter>$summary</parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-channelfile.setsummary.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   This sets a human-readable description of a channel's purpose.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-channelfile.setsummary.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$summary</parameter>
     </term>
     <listitem>
      <para>
       The channel summary
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.setsummary.returns">
  <title xmlns="http://docbook.org/ns/docbook">Return value</title>
  <para>
   <emphasis>returns</emphasis>
   success
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.setsummary.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.setsummary.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-channelfile.setvalidationpackage">
 <refnamediv>
  <refname>
   <function>PEAR_ChannelFile::setValidationPackage</function>
  </refname>
  <refpurpose>
   Set the package validation object if it differs from PEAR's default.
  </refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/ChannelFile.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     boolean
     <function>PEAR_ChannelFile::setValidationPackage</function>
    </funcdef>
    <paramdef choice="req">
     string|false
     <parameter>$validateclass</parameter>
    </paramdef>
    <paramdef choice="req">
     string
     <parameter>$version</parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-channelfile.setvalidationpackage.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   The class must be either in memory (<classname>PEAR_Validate</classname> or
   <classname>PEAR_Validate_PECL</classname>) or be available for <function>include_once</function>
   via a simple formula:  Transform the underscores (<literal>_</literal>) into
   directory separators (<literal>/</literal>), append <literal>.php</literal> and
   include.
  </para>
  <para>
   A validation class named <classname>Foo_Bar_Baz</classname> should be available for
   inclusion via this code:
  </para>
  <para>
   <programlisting>
    <![CDATA[
<?php
include_once 'Foo/Bar/Baz.php';
?>
    ]]>
   </programlisting>
  </para>
  <para>
   In addition, the validation package must be available for installation from the channel
   with the version number to install specified by the <parameter>$version</parameter> parameter.
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.setvalidationpackage.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>|<constant xmlns="http://docbook.org/ns/docbook">FALSE</constant>
      <parameter>$validateclass</parameter>
     </term>
     <listitem>
      <para>pass in <constant xmlns="http://docbook.org/ns/docbook">FALSE</constant> to reset to the default packagename regex</para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$version</parameter>
     </term>
     <listitem>
      <para>
       The package version that must be installed for this channel to validate properly.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.setvalidationpackage.returns">
  <title xmlns="http://docbook.org/ns/docbook">Return value</title>
  <para>
   <emphasis>returns</emphasis>
   success
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.setvalidationpackage.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.setvalidationpackage.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-channelfile.supports">
 <refnamediv>
  <refname>
   <function>PEAR_ChannelFile::supports</function>
  </refname>
  <refpurpose>determines whether a webservices function is supported by a channel</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/ChannelFile.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     boolean
     <function>PEAR_ChannelFile::supports</function>
    </funcdef>
    <paramdef choice="req">
     string
     <parameter>$type</parameter>
    </paramdef>
    <paramdef choice="opt">
     string
     <parameter>$name</parameter>
     <initializer>null</initializer>
    </paramdef>
    <paramdef choice="opt">
     string|false
     <parameter>$mirror</parameter>
     <initializer>false</initializer>
    </paramdef>
    <paramdef choice="opt">
     string
     <parameter>
      $version = '1.0'
     </parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-channelfile.supports.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   This is used in the installer to determine whether a protocol is supported before
   attempting to connect to a remote server and invoke the function needed.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-channelfile.supports.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$type</parameter>
     </term>
     <listitem>
      <para>protocol type (<literal>xmlrpc</literal> or <literal>soap</literal>)</para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$name</parameter>
     </term>
     <listitem>
      <para>function name (like <literal>package.info</literal>)</para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>|<constant xmlns="http://docbook.org/ns/docbook">FALSE</constant>
      <parameter>$mirror</parameter>
     </term>
     <listitem>
      <para>Mirror server name or <constant xmlns="http://docbook.org/ns/docbook">FALSE</constant> for primary server</para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$version</parameter>
     </term>
     <listitem>
      <para>function version</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.supports.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.supports.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-channelfile.supportsrest">
 <refnamediv>
  <refname>
   <function>PEAR_ChannelFile::supportsREST</function>
  </refname>
  <refpurpose>
   Determines whether a channel supports any Representational State Transfer
   (REST) resources
 </refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/ChannelFile.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     bool
     <function>PEAR_ChannelFile::supportsREST</function>
    </funcdef>
    <paramdef choice="opt">
     string
     <parameter>$mirror</parameter>
     <initializer>false</initializer>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-channelfile.supportsrest.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   This does not check to see which REST resources are supported, use
   <link linkend="core.ppm.pear-channelfile.getbaseurl"><function>getBaseURL</function></link>
   to check specific REST resource or resource group support.
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.supportsrest.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>|<constant xmlns="http://docbook.org/ns/docbook">FALSE</constant>
      <parameter>$mirror</parameter>
     </term>
     <listitem>
      <para>
       Mirror server name or <constant xmlns="http://docbook.org/ns/docbook">FALSE</constant> for the primary server.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.supportsrest.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.supportsrest.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-channelfile.toarray">
 <refnamediv>
  <refname>
   <function>PEAR_ChannelFile::toArray</function>
  </refname>
  <refpurpose>return the channel representation in array format</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/ChannelFile.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     array
     <function>PEAR_ChannelFile::toArray</function>
    </funcdef>
    <paramdef choice="req"/>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-channelfile.toarray.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   This function should not be used to directly manipulate data, but instead as a means
   to serialize and transport the data in a more efficient manner than as the original xml.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-channelfile.toarray.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.toarray.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-channelfile.toxml">
 <refnamediv>
  <refname>
   <function>PEAR_ChannelFile::toXml</function>
  </refname>
  <refpurpose>Return an XML document based on the internal representation of this channel</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/ChannelFile.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     string
     <function>PEAR_ChannelFile::toXml</function>
    </funcdef>
    <paramdef choice="req"/>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-channelfile.toxml.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   This should be used to generate a <filename>channel.xml</filename> based on the data
   stored in the <classname>PEAR_ChannelFile</classname> class.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-channelfile.toxml.returns">
  <title xmlns="http://docbook.org/ns/docbook">Return value</title>
  <para>
   <emphasis>returns</emphasis>
   XML data
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.toxml.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.toxml.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-channelfile.validate">
 <refnamediv>
  <refname>
   <function>PEAR_ChannelFile::validate</function>
  </refname>
  <refpurpose>Validate channel information.</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/ChannelFile.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     boolean
     <function>PEAR_ChannelFile::validate</function>
    </funcdef>
    <paramdef choice="req"/>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-channelfile.validate.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Specific errors can be retrieved post-validation with the
   <link linkend="core.ppm.pear-channelfile.geterrors"><function>getErrors</function></link>
   method.  Errors are stored by the <link linkend="core.pear.pear-errorstack"><classname>PEAR_ErrorStack</classname></link> class, more
   information on the format of the array can be found in the documentation for PEAR_ErrorStack.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-channelfile.validate.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.validate.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-channelfile.validchannelserver">
 <refnamediv>
  <refname>
   <function>PEAR_ChannelFile::validChannelServer</function>
  </refname>
  <refpurpose>Test whether a string contains a valid channel server.</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/ChannelFile.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     bool
     <function>PEAR_ChannelFile::validChannelServer</function>
    </funcdef>
    <paramdef choice="req">
     string
     <parameter>$server</parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-channelfile.validchannelserver.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   determines whether a channel server is a valid servername.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-channelfile.validchannelserver.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$server</parameter>
     </term>
     <listitem>
      <para>
       Server name.  May contain subpaths as in <literal>foo.example.com/path/to/channel</literal>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.validchannelserver.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-channelfile.validchannelserver.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-channelfile.constants">
 <refnamediv>
  <refname>Package PEAR Constants</refname>
  <refpurpose>Constants defined in and used by PEAR</refpurpose>
 </refnamediv>
 <refsection xml:id="core.ppm.pear-channelfile.constants.details"><info><title>All Constants</title></info>
  
  <refsection xml:id="core.ppm.pear-channelfile.constants.details.channelfile---php"><info><title>Constants defined in ChannelFile.php</title></info>
   
   <para>
    <table><title>Error Constants defined in ChannelFile.php</title>
     
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Name</entry>
        <entry>Value</entry>
        <entry>Line Number</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>PEAR_CHANNELFILE_ERROR_CANT_MAKE_PARSER</entry>
        <entry>4</entry>
        <entry>48</entry>
       </row>
       <row>
        <entry>PEAR_CHANNELFILE_ERROR_EMPTY_REGEX</entry>
        <entry>24</entry>
        <entry>97</entry>
       </row>
       <row>
        <entry>PEAR_CHANNELFILE_ERROR_INVALID</entry>
        <entry>23</entry>
        <entry>93</entry>
       </row>
       <row>
        <entry>PEAR_CHANNELFILE_ERROR_INVALID_HOST</entry>
        <entry>11</entry>
        <entry>81</entry>
       </row>
       <row>
        <entry>PEAR_CHANNELFILE_ERROR_INVALID_MIRROR</entry>
        <entry>21</entry>
        <entry>85</entry>
       </row>
       <row>
        <entry>PEAR_CHANNELFILE_ERROR_INVALID_MIRRORTYPE</entry>
        <entry>22</entry>
        <entry>89</entry>
       </row>
       <row>
        <entry>PEAR_CHANNELFILE_ERROR_INVALID_NAME</entry>
        <entry>7</entry>
        <entry>65</entry>
       </row>
       <row>
        <entry>PEAR_CHANNELFILE_ERROR_INVALID_PORT</entry>
        <entry>33</entry>
        <entry>122</entry>
       </row>
       <row>
        <entry>PEAR_CHANNELFILE_ERROR_INVALID_SSL</entry>
        <entry>37</entry>
        <entry>138</entry>
       </row>
       <row>
        <entry>PEAR_CHANNELFILE_ERROR_INVALID_VERSION</entry>
        <entry>2</entry>
        <entry>38</entry>
       </row>
       <row>
        <entry>PEAR_CHANNELFILE_ERROR_MIRROR_NOT_FOUND</entry>
        <entry>32</entry>
        <entry>118</entry>
       </row>
       <row>
        <entry>PEAR_CHANNELFILE_ERROR_MULTILINE_SUMMARY</entry>
        <entry>9</entry>
        <entry>73</entry>
       </row>
       <row>
        <entry>PEAR_CHANNELFILE_ERROR_NOBASEURLTYPE</entry>
        <entry>35</entry>
        <entry>130</entry>
       </row>
       <row>
        <entry>PEAR_CHANNELFILE_ERROR_NOVALIDATE_NAME</entry>
        <entry>27</entry>
        <entry>109</entry>
       </row>
       <row>
        <entry>PEAR_CHANNELFILE_ERROR_NOVALIDATE_VERSION</entry>
        <entry>28</entry>
        <entry>113</entry>
       </row>
       <row>
        <entry>PEAR_CHANNELFILE_ERROR_NO_FUNCTIONNAME</entry>
        <entry>26</entry>
        <entry>105</entry>
       </row>
       <row>
        <entry>PEAR_CHANNELFILE_ERROR_NO_FUNCTIONVERSION</entry>
        <entry>25</entry>
        <entry>101</entry>
       </row>
       <row>
        <entry>PEAR_CHANNELFILE_ERROR_NO_HOST</entry>
        <entry>10</entry>
        <entry>77</entry>
       </row>
       <row>
        <entry>PEAR_CHANNELFILE_ERROR_NO_NAME</entry>
        <entry>6</entry>
        <entry>61</entry>
       </row>
       <row>
        <entry>PEAR_CHANNELFILE_ERROR_NO_STATICVERSION</entry>
        <entry>34</entry>
        <entry>126</entry>
       </row>
       <row>
        <entry>PEAR_CHANNELFILE_ERROR_NO_SUMMARY</entry>
        <entry>8</entry>
        <entry>69</entry>
       </row>
       <row>
        <entry>PEAR_CHANNELFILE_ERROR_NO_VERSION</entry>
        <entry>1</entry>
        <entry>33</entry>
       </row>
       <row>
        <entry>PEAR_CHANNELFILE_ERROR_NO_XML_EXT</entry>
        <entry>3</entry>
        <entry>43</entry>
       </row>
       <row>
        <entry>PEAR_CHANNELFILE_ERROR_PARSER_ERROR</entry>
        <entry>5</entry>
        <entry>53</entry>
       </row>
       <row>
        <entry>PEAR_CHANNELFILE_URI_CANT_MIRROR</entry>
        <entry>36</entry>
        <entry>134</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </para>
  </refsection>
 </refsection>
</refentry>

</section>

 
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-command"><info><title>PEAR_Command</title></info>
        

<para>PEAR command class, a simple factory class for administrative commands.</para>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-command.factory">
   <refnamediv>
    <refname><function>PEAR_Command::factory</function></refname>
    <refpurpose>get object for executing a command.</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/command.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>object       <function>PEAR_Command::factory</function></funcdef>
      <paramdef choice="req">string <parameter>$command</parameter></paramdef>
      <paramdef choice="req">object <parameter>&amp;$config</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-command.factory.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>Get the right object for executing a command.</para>
    </refsection>
   <refsection xml:id="core.ppm.pear-command.factory.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$command</parameter>
       </term>      
       <listitem>
        <para>
         The name of the command
        </para>
       </listitem>
      </varlistentry>
       <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">object</type>
         <parameter>&amp;$config</parameter>
       </term>      
       <listitem>
        <para>
         Instance of <classname>PEAR_Config</classname> object
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-command.factory.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>
    <para>
     <parameter>object</parameter> the command object 
    </para>
   </refsection>

   <refsection xml:id="core.ppm.pear-command.factory.throws">
    <title xmlns="http://docbook.org/ns/docbook">Throws</title>
    <para>
     <table><title>Possible PEAR_Error values</title>
            
      <tgroup cols="4">

       <thead>
        <row>
         <entry>Error code</entry>
         <entry>Error value</entry>        
         <entry>Meaning</entry>        
         <entry>Solution</entry>        
        </row>
       </thead>
       <tbody>
        <row>
         <entry/>
         <entry><quote/></entry>
         <entry/>
         <entry/>
        </row>       
       </tbody>
      </tgroup>
     </table>
    </para>    
   </refsection>

   <refsection xml:id="core.ppm.pear-command.factory.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function should be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-command.getcommands">
   <refnamediv>
    <refname><function>PEAR_Command::getCommands</function></refname>
    <refpurpose>get list of currently supported commands</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/command.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>array       <function>PEAR_Command::getCommands</function></funcdef>
<void/>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-command.getcommands.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>Get the list of currently supported commands, and what classes implement them.</para>
    </refsection>
   <refsection xml:id="core.ppm.pear-command.getcommands.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>
    <para>
      <parameter>array</parameter> command =&gt; implementing class
    </para>
   </refsection>

   <refsection xml:id="core.ppm.pear-command.getcommands.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
   <simpara xmlns="http://docbook.org/ns/docbook">This function should be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-command.getdescription">
   <refnamediv>
    <refname><function>PEAR_Command::getDescription</function></refname>
    <refpurpose>get description for a command</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/command.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>string       <function>PEAR_Command::getDescription</function></funcdef>
      <paramdef choice="req">string <parameter>$command</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-command.getdescription.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>Get description for a command.</para>
    </refsection>
   <refsection xml:id="core.ppm.pear-command.getdescription.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$command</parameter>
       </term>      
       <listitem>
        <para>
         Name of the command
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-command.getdescription.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>
    <para>
     <parameter>string</parameter> command description
    </para>
   </refsection>

   <refsection xml:id="core.ppm.pear-command.getdescription.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function should be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-command.getgetoptargs">
   <refnamediv>
    <refname><function>PEAR_Command::getGetoptArgs</function></refname>
    <refpurpose>compiles arguments for getopt</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/command.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef><replaceable>void</replaceable>       <function>PEAR_Command::getGetoptArgs</function></funcdef>
      <paramdef choice="req">string <parameter>$command</parameter></paramdef>
      <paramdef choice="req">string <parameter>&amp;$short_args</parameter></paramdef>
      <paramdef choice="req">array <parameter>&amp;$long_args</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-command.getgetoptargs.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>Compiles arguments for getopt.</para>
    </refsection>
   <refsection xml:id="core.ppm.pear-command.getgetoptargs.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$command</parameter>
       </term>      
       <listitem>
        <para>
         command to get optstring for
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>&amp;$short_args</parameter>
       </term>      
       <listitem>
        <para>
         (reference) short getopt format
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">array</type>
        <parameter>&amp;$long_args</parameter>
       </term>      
       <listitem>
        <para>
         (reference) long getopt format
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>

   <refsection xml:id="core.ppm.pear-command.getgetoptargs.throws">
    <title xmlns="http://docbook.org/ns/docbook">Throws</title>
    <para>
     <table><title>Possible PEAR_Error values</title>
            
      <tgroup cols="4">

       <thead>
        <row>
         <entry>Error code</entry>
         <entry>Error value</entry>        
         <entry>Meaning</entry>        
         <entry>Solution</entry>        
        </row>
       </thead>
       <tbody>
        <row>
         <entry/>
         <entry><quote/></entry>
         <entry/>
         <entry/>
        </row>       
       </tbody>
      </tgroup>
     </table>
    </para>    
   </refsection>

   <refsection xml:id="core.ppm.pear-command.getgetoptargs.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function should be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-command.gethelp">
   <refnamediv>
    <refname><function>PEAR_Command::getHelp</function></refname>
    <refpurpose>get help for command</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/command.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>string       <function>PEAR_Command::getHelp</function></funcdef>
      <paramdef choice="req">string <parameter>$command</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-command.gethelp.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>Get help for command.</para>
    </refsection>
   <refsection xml:id="core.pear.pear-command.gethelp.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$command</parameter>
       </term>      
       <listitem>
        <para>
         Name of the command to return help for
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>

   <refsection xml:id="core.ppm.pear-command.gethelp.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>
    <para>
     <parameter>string</parameter> help text
    </para>
   </refsection>
   
   <refsection xml:id="core.ppm.pear-command.gethelp.throws">
    <title xmlns="http://docbook.org/ns/docbook">Throws</title>
    <para>
     <table><title>Possible PEAR_Error values</title>
            
      <tgroup cols="4">

       <thead>
        <row>
         <entry>Error code</entry>
         <entry>Error value</entry>        
         <entry>Meaning</entry>        
         <entry>Solution</entry>        
        </row>
       </thead>
       <tbody>
        <row>
         <entry/>
         <entry><quote/></entry>
         <entry/>
         <entry/>
        </row>       
       </tbody>
      </tgroup>
     </table>
    </para>    
   </refsection>

   <refsection xml:id="core.ppm.pear-command.gethelp.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function should be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-command.getshortcuts">
   <refnamediv>
    <refname><function>PEAR_Command::getShortcuts</function></refname>
    <refpurpose>get list of command shortcuts.</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/command.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>array       <function>PEAR_Command::getShortcuts</function></funcdef>
<void/>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-command.getshortcuts.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>Get the list of command shortcuts.</para>
    </refsection>
   <refsection xml:id="core.ppm.pear-command.getshortcuts.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>
    <para>
     <parameter>array</parameter> shortcut =&gt; command
    </para>
   </refsection>
 
   <refsection xml:id="core.ppm.pear-command.getshortcuts.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function should be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-command.registercommands">
   <refnamediv>
    <refname><function>PEAR_Command::registerCommands</function></refname>
    <refpurpose>scan the command directory</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/command.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>bool       <function>PEAR_Command::registerCommands</function></funcdef>
      <paramdef choice="opt">bool <parameter> $merge</parameter>
       <initializer>false</initializer>
      </paramdef>
      <paramdef choice="opt">string <parameter> $dir</parameter>
       <initializer>null</initializer>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-command.registercommands.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>Scan through the Command directory looking for classes and see what commands they implement.</para>
    </refsection>
   <refsection xml:id="core.ppm.pear-command.registercommands.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">boolean</type>
         <parameter>$merge</parameter>
       </term>      
       <listitem>
        <para>
         if <constant xmlns="http://docbook.org/ns/docbook">FALSE</constant> (default), the new list of
         commands should replace the current one. 
         If <constant xmlns="http://docbook.org/ns/docbook">TRUE</constant>,
         new entries will be merged with old.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$dir</parameter>
       </term>      
       <listitem>
        <para>
         where (what directory) to look for
         classes, defaults to the Command subdirectory 
         of the directory from where this file 
         (<constant>__FILE__</constant>) is
         included.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-command.registercommands.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>
    <para>
     <parameter>bool</parameter> <constant xmlns="http://docbook.org/ns/docbook">TRUE</constant> on success
    </para>
   </refsection>

   <refsection xml:id="core.ppm.pear-command.registercommands.throws">
    <title xmlns="http://docbook.org/ns/docbook">Throws</title>
    <para>
     <table><title>Possible PEAR_Error values</title>
            
      <tgroup cols="4">

       <thead>
        <row>
         <entry>Error code</entry>
         <entry>Error value</entry>        
         <entry>Meaning</entry>        
         <entry>Solution</entry>        
        </row>
       </thead>
       <tbody>
        <row>
         <entry/>
         <entry><quote/></entry>
         <entry/>
         <entry/>
        </row>       
       </tbody>
      </tgroup>
     </table>
    </para>    
   </refsection>

   <refsection xml:id="core.ppm.pear-command.registercommands.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function should be called
statically.</simpara>
   </refsection>
</refentry>




</section>

 
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-common"><info><title>PEAR_Common</title></info>
 
 <para>
  Class providing common functionality for PEAR 
  administration classes.
 </para>
 <para>
  Class Trees for <function>PEAR_Common</function>
 </para>
 <para>
  <itemizedlist>
   <listitem>
    <para>
     PEAR
     <itemizedlist>
      <listitem>
       <simpara>
        PEAR_Common
       </simpara>
      </listitem>
     </itemizedlist>
    </para>
   </listitem>
  </itemizedlist>
 </para>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-common.pear-common">
   <refnamediv>
    <refname><function>PEAR_Common::PEAR_Common</function></refname>
    <refpurpose>PEAR_Common constructor</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/common.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>void
       <function>PEAR_Common::PEAR_Common</function></funcdef>
<void/>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-common.pear-common.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>PEAR_Common constructor</para>
    </refsection>
 
    <refsection xml:id="core.ppm.pear-common.pear-common.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-common.addtempfile">
   <refnamediv>
    <refname><function>PEAR_Common::addTempFile</function></refname>
    <refpurpose>register a temporary file or directory</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/common.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef><replaceable>void</replaceable> 
       <function>PEAR_Common::addTempFile</function></funcdef>
      <paramdef choice="req">string <parameter>$file</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-common.addtempfile.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>Register a temporary file or directory. When the destructor 
      is executed, all registered temporary files and 
      directories are removed.</para>
    </refsection>
   <refsection xml:id="core.ppm.pear-common.addtempfile.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$file</parameter>
       </term>      
       <listitem>
        <para>
         name of file or directory
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>

   <refsection xml:id="core.ppm.pear-common.addtempfile.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-common.analyzesourcecode">
   <refnamediv>
    <refname><function>PEAR_Common::analyzeSourceCode</function></refname>
    <refpurpose>analyze the source code of the given PHP file</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/common.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>array
       <function>PEAR_Common::analyzeSourceCode</function></funcdef>
      <paramdef choice="req">string <parameter>$file</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-common.analyzesourcecode.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>Analyze the source code of the given PHP file</para>
    </refsection>
   <refsection xml:id="core.ppm.pear-common.analyzesourcecode.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$file</parameter>
       </term>      
       <listitem>
        <para>
         Filename of the PHP file
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-common.analyzesourcecode.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>
    <para>
     <parameter>array</parameter> - hash list of
     <parameter>declared_classes</parameter>,
     <parameter>declared_methods</parameter>,
     <parameter>declared_functions</parameter> and
     <parameter>used_classes</parameter>     
    </para>
   </refsection>

   <refsection xml:id="core.ppm.pear-common.analyzesourcecode.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-common.buildprovidesarray">
   <refnamediv>
    <refname><function>PEAR_Common::buildProvidesArray</function></refname>
    <refpurpose>Build a array</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/common.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef><replaceable>void</replaceable>
       <function>PEAR_Common::buildProvidesArray</function></funcdef>
      <paramdef choice="req">array <parameter>$srcinfo</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-common.buildprovidesarray.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>
      Build a "provides" array from data returned 
      by <function>analyzeSourceCode</function>. 
      The format of the built array is like this:
      <programlisting role="php">
       <![CDATA[
        array(
        'class;MyClass' => 
           array(
           'type' => 'class',
           'name' => 'MyClass'
           ),
           ...  
        )
        ]]>
      </programlisting>
     </para>
    </refsection>
   <refsection xml:id="core.ppm.pear-common.buildprovidesarray.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">array</type>
         <parameter>$srcinfo</parameter>
       </term>      
       <listitem>
        <para>
         array with information about a 
         source file as returned by the 
         <function>analyzeSourceCode</function> method.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>

   <refsection xml:id="core.ppm.pear-common.buildprovidesarray.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-common.downloadhttp">
   <refnamediv>
    <refname><function>PEAR_Common::downloadHttp</function></refname>
    <refpurpose>Download a file through HTTP</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/common.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>string  <function>PEAR_Common::downloadHttp</function></funcdef>
      <paramdef choice="req">string <parameter>$url</parameter></paramdef>
      <paramdef choice="req">object <parameter>&amp;$ui</parameter></paramdef>
      <paramdef choice="opt">string <parameter>$save_dir = '.'</parameter></paramdef>
      <paramdef choice="opt">mixed <parameter>$callback</parameter>
       <initializer>null</initializer>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-common.downloadhttp.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>
      Download a file through HTTP.  
      Considers suggested file name in Content-disposition: header 
      and can run a callback function for different events.  
      The callback will be called with two parameters: 
      the callback type, and parameters.  
      The implemented callback types are:
      <itemizedlist>
       <listitem>
        <para>
         <parameter>'setup'</parameter> - 
         called at the very beginning, parameter is a 
         UI object that should be used for all output
        </para>
       </listitem>
       <listitem>
        <para>
         <parameter>'message'</parameter> -
         the parameter is a string with an informational message
        </para>
       </listitem>
       <listitem>
        <para>
         <parameter>'saveas'</parameter> - 
         may be used to save with a different file name, the
         parameter is the filename that is about to be used. 
         If a <parameter>'saveas'</parameter> callback 
         returns a non-empty string, that file name will be 
         used as the filename instead.
         Note that <parameter>$save_dir</parameter> will not 
         be affected by this, only the basename of the file.
        </para>
       </listitem>
       <listitem>
        <para>
         <parameter>'start'</parameter> -
         download is starting, parameter is number of bytes
         that are expected, or -1 if unknown  
        </para>
       </listitem>
       <listitem>
        <para>
         <parameter>'bytesread'</parameter> -
         parameter is the number of bytes read so far
        </para>
       </listitem>
       <listitem>
        <para>
         <parameter>'done'</parameter> - download is 
         complete, parameter is the total number 
         of bytes read 
        </para>
       </listitem>
       <listitem>
        <para>
         <parameter>'connfailed'</parameter> -
         if the TCP connection fails, this callback is called
         with <programlisting role="php">array(host,port,errno,errmsg)</programlisting>
        </para>
       </listitem>
       <listitem>
        <para>
         <parameter>'writefailed'</parameter> -
         if writing to disk fails, this callback is called         
         with <programlisting role="php">array(destfile,errmsg)</programlisting>
        </para>
       </listitem>
      </itemizedlist>
      If an HTTP proxy has been configured 
      (<parameter>http_proxy</parameter> PEAR_Config setting), 
      the proxy will be used.
     </para>
    </refsection>
   <refsection xml:id="core.ppm.pear-common.downloadhttp.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$url</parameter>
       </term>      
       <listitem>
        <para>
         the URL to download
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">object</type>
         <parameter>&amp;$ui</parameter>
       </term>      
       <listitem>
        <para>
         <classname>PEAR_Frontend_*</classname> instance   
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$save_dir</parameter>
       </term>      
       <listitem>
        <para>
         directory to save file in
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">mixed</type>
         <parameter>$callback</parameter>
       </term>      
       <listitem>
        <para>
         function/method to call for status      
         updates
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">object</type>
         <parameter>$config</parameter>
       </term>      
       <listitem>
        <para>
         <classname>PEAR_Config</classname> instance
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-common.downloadhttp.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>
    <para>
     <parameter>string</parameter> - 
     Returns the full path of the downloaded file or a 
     PEAR error on failure.  If the error is caused by
     socket-related errors, the error object will   
     have the fsockopen error code available through
     <function>getCode</function>.
    </para>
   </refsection>

   <refsection xml:id="core.ppm.pear-common.downloadhttp.throws">
    <title xmlns="http://docbook.org/ns/docbook">Throws</title>
    <para>
     <table><title>Possible PEAR_Error values</title>
            
      <tgroup cols="4">

       <thead>
        <row>
         <entry>Error code</entry>
         <entry>Error value</entry>        
         <entry>Meaning</entry>        
         <entry>Solution</entry>        
        </row>
       </thead>
       <tbody>
        <row>
         <entry/>
         <entry><quote/></entry>
         <entry/>
         <entry/>
        </row>       
       </tbody>
      </tgroup>
     </table>
    </para>    
   </refsection>

   <refsection xml:id="core.ppm.pear-common.downloadhttp.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-common.infofromany">
   <refnamediv>
    <refname><function>PEAR_Common::infoFromAny</function></refname>
    <refpurpose>Returns package information from different sources</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/common.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>string <function>PEAR_Common::infoFromAny</function></funcdef>
      <paramdef choice="req">string <parameter>$info</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-common.infofromany.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>
      Returns package information from different sources.
      This method is able to extract information about a package 
      from a .tgz archive or from a XML package definition file.
     </para>
    </refsection>
   <refsection xml:id="core.ppm.pear-common.infofromany.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$info</parameter>
       </term>      
       <listitem>
        <para>
         Filename of the source (<parameter>'package.xml'</parameter>,
         <parameter>'&lt;package&gt;.tgz'</parameter>)
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-common.infofromany.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>
    <para>
     <parameter>string</parameter> -
     Package information
    </para>
   </refsection>

   <refsection xml:id="core.ppm.pear-common.infofromany.throws">
    <title xmlns="http://docbook.org/ns/docbook">Throws</title>
    <para>
     <table><title>Possible PEAR_Error values</title>
            
      <tgroup cols="4">

       <thead>
        <row>
         <entry>Error code</entry>
         <entry>Error value</entry>        
         <entry>Meaning</entry>        
         <entry>Solution</entry>        
        </row>
       </thead>
       <tbody>
        <row>
         <entry/>
         <entry><quote/></entry>
         <entry/>
         <entry/>
        </row>       
       </tbody>
      </tgroup>
     </table>
    </para>    
   </refsection>

   <refsection xml:id="core.ppm.pear-common.infofromany.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-common.infofromdescriptionfile">
   <refnamediv>
    <refname><function>PEAR_Common::infoFromDescriptionFile</function></refname>
    <refpurpose>Returns information about a package file</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/common.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>array 
       <function>PEAR_Common::infoFromDescriptionFile</function></funcdef>
      <paramdef choice="req">string <parameter>$descfile</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-common.infofromdescriptionfile.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>
      Returns information about a package file.
      Expects the name of a package xml file as input.
     </para>
    </refsection>
   <refsection xml:id="core.ppm.pear-common.infofromdescriptionfile.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$descfile</parameter>
       </term>      
       <listitem>
        <para>
         name of package xml file
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-common.infofromdescriptionfile.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>
    <para>
     <parameter>array</parameter> -
     array with package information
    </para>
   </refsection>
   
   <refsection xml:id="core.ppm.pear-common.infofromdescriptionfile.throws">
    <title xmlns="http://docbook.org/ns/docbook">Throws</title>
    <para>
     <table><title>Possible PEAR_Error values</title>
            
      <tgroup cols="4">

       <thead>
        <row>
         <entry>Error code</entry>
         <entry>Error value</entry>        
         <entry>Meaning</entry>        
         <entry>Solution</entry>        
        </row>
       </thead>
       <tbody>
        <row>
         <entry/>
         <entry><quote/></entry>
         <entry/>
         <entry/>
        </row>       
       </tbody>
      </tgroup>
     </table>
    </para>    
   </refsection>

   <refsection xml:id="core.ppm.pear-common.infofromdescriptionfile.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-common.infofromstring">
   <refnamediv>
    <refname><function>PEAR_Common::infoFromString</function></refname>
    <refpurpose>Returns information about a package file</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/common.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>array
       <function>PEAR_Common::infoFromString</function></funcdef>
      <paramdef choice="req">string <parameter>$data</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-common.infofromstring.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>Returns information about a package file. 
      Expects the contents of a package xml file as input.</para>
    </refsection>
   <refsection xml:id="core.ppm.pear-common.infofromstring.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$data</parameter>
       </term>      
       <listitem>
        <para>
        content of package xml file
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-common.infofromstring.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>
    <para>
     <parameter>array</parameter> -
     array with package information
    </para>
   </refsection>

   <refsection xml:id="core.ppm.pear-common.infofromstring.throws">
    <title xmlns="http://docbook.org/ns/docbook">Throws</title>
    <para>
     <table><title>Possible PEAR_Error values</title>
            
      <tgroup cols="4">

       <thead>
        <row>
         <entry>Error code</entry>
         <entry>Error value</entry>        
         <entry>Meaning</entry>        
         <entry>Solution</entry>        
        </row>
       </thead>
       <tbody>
        <row>
         <entry/>
         <entry><quote/></entry>
         <entry/>
         <entry/>
        </row>       
       </tbody>
      </tgroup>
     </table>
    </para>    
   </refsection>

   <refsection xml:id="core.ppm.pear-common.infofromstring.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-common.infofromtgzfile">
   <refnamediv>
    <refname><function>PEAR_Common::infoFromTgzFile</function></refname>
    <refpurpose>Returns information about a package file</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/common.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>array
       <function>PEAR_Common::infoFromTgzFile</function></funcdef>
      <paramdef choice="req">string <parameter>$file</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-common.infofromtgzfile.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>
      Returns information about a package file.
      Expects the name of a gzipped tar file as input.</para>
    </refsection>
   <refsection xml:id="core.ppm.pear-common.infofromtgzfile.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$file</parameter>
       </term>      
       <listitem>
        <para>
         name of .tgz file
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-common.infofromtgzfile.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>

    <para>
     <parameter>array</parameter> -
     array with package information
    </para>
   </refsection>

   <refsection xml:id="core.ppm.pear-common.infofromtgzfile.throws">
    <title xmlns="http://docbook.org/ns/docbook">Throws</title>
    <para>
     <table><title>Possible PEAR_Error values</title>
            
      <tgroup cols="4">

       <thead>
        <row>
         <entry>Error code</entry>
         <entry>Error value</entry>        
         <entry>Meaning</entry>        
         <entry>Solution</entry>        
        </row>
       </thead>
       <tbody>
        <row>
         <entry/>
         <entry><quote/></entry>
         <entry/>
         <entry/>
        </row>       
       </tbody>
      </tgroup>
     </table>
    </para>    
   </refsection>

   <refsection xml:id="core.ppm.pear-common.infofromtgzfile.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-common.log">
   <refnamediv>
    <refname><function>PEAR_Common::log</function></refname>
    <refpurpose>Logging method</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/common.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef><replaceable>void</replaceable>
       <function>PEAR_Common::log</function></funcdef>
      <paramdef choice="req">int <parameter>$level</parameter></paramdef>
      <paramdef choice="req">string <parameter>$msg</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-common.log.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>Logging method.</para>
    </refsection>
   <refsection xml:id="core.ppm.pear-common.log.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">integer</type>
         <parameter>$level</parameter>
       </term>      
       <listitem>
        <para>
         log level (0 is quiet, higher is noisier)
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$msg</parameter>
       </term>      
       <listitem>
        <para>
         message to write to the log
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>

   <refsection xml:id="core.ppm.pear-common.log.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-common.mkdirhier">
   <refnamediv>
    <refname><function>PEAR_Common::mkDirHier</function></refname>
    <refpurpose>Create a directory and necessary parent directories</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'common.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>bool
       <function>PEAR_Common::mkDirHier</function></funcdef>
      <paramdef choice="req">string <parameter>$dir</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-common.mkdirhier.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>
      Wrapper to System::mkDir(), 
      creates a directory as well as any necessary parent directories.
     </para>
    </refsection>
   <refsection xml:id="core.ppm.pear-common.mkdirhier.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$dir</parameter>
       </term>      
       <listitem>
        <para>
         directory name
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-common.mkdirhier.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>
    <para>
     <parameter>bool</parameter> - 
     Returns <constant xmlns="http://docbook.org/ns/docbook">TRUE</constant> on success,
<classname xmlns="http://docbook.org/ns/docbook">PEAR_Error</classname> on failure.
    </para>
   </refsection>

   <refsection xml:id="core.ppm.pear-common.mkdirhier.throws">
    <title xmlns="http://docbook.org/ns/docbook">Throws</title>
    <para>
     <table><title>Possible PEAR_Error values</title>
            
      <tgroup cols="4">

       <thead>
        <row>
         <entry>Error code</entry>
         <entry>Error value</entry>        
         <entry>Meaning</entry>        
         <entry>Solution</entry>        
        </row>
       </thead>
       <tbody>
        <row>
         <entry/>
         <entry><quote/></entry>
         <entry/>
         <entry/>
        </row>       
       </tbody>
      </tgroup>
     </table>
    </para>    
   </refsection>

   <refsection xml:id="core.ppm.pear-common.mkdirhier.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-common.mktempdir">
   <refnamediv>
    <refname><function>PEAR_Common::mkTempDir</function></refname>
    <refpurpose>Create and register a temporary directory.</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/common.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>string 
       <function>PEAR_Common::mkTempDir</function></funcdef>
      <paramdef choice="opt">string <parameter>$tmpdir = ''
      </parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-common.mktempdir.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>Create and register a temporary directory.</para>
    </refsection>
   <refsection xml:id="core.ppm.pear-common.mktempdir.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$tmpdir</parameter>
       </term>      
       <listitem>
        <para>
         Directory to use as tmpdir.
         Will use system defaults (for example
         <parameter>/tmp</parameter> or 
         <parameter>c:\windows\temp</parameter>)
         if not specified.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>

   <refsection xml:id="core.ppm.pear-common.mktempdir.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>
    <para>
     <parameter>string</parameter> name of created directory
    </para>
   </refsection>

   <refsection xml:id="core.ppm.pear-common.mktempdir.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-common.setfrontendobject">
   <refnamediv>
    <refname><function>PEAR_Common::setFrontendObject</function></refname>
    <refpurpose>Set object representing frontend to use.</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'common.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef><replaceable>void</replaceable>
       <function>PEAR_Common::setFrontendObject</function></funcdef>
      <paramdef choice="req">object <parameter>&amp;$ui</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-common.setfrontendobject.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>Set object that represents the frontend to be used.</para>
    </refsection>
   <refsection xml:id="core.ppm.pear-common.setfrontendobject.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">object</type>
        <parameter>$ui</parameter>
       </term>      
       <listitem>
        <para>
         Reference of the frontend object
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>

   <refsection xml:id="core.ppm.pear-common.setfrontendobject.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-common.validatepackageinfo">
   <refnamediv>
    <refname><function>PEAR_Common::validatePackageInfo</function></refname>
    <refpurpose>Validate XML package definition file</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'common.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>boolean       <function>PEAR_Common::validatePackageInfo</function></funcdef>
      <paramdef choice="req">string <parameter>$info</parameter></paramdef>
      <paramdef choice="req">array <parameter>&amp;$errors</parameter></paramdef>
      <paramdef choice="req">array <parameter>&amp;$warnings</parameter></paramdef>
      <paramdef choice="opt">string <parameter>$dir_prefix = ''</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-common.validatepackageinfo.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>Validate XML package definition file.</para>
    </refsection>
   <refsection xml:id="core.ppm.pear-common.validatepackageinfo.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$info</parameter>
       </term>      
       <listitem>
        <para>
         Filename of the package archive or of the
         package definition file
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">array</type>
         <parameter>$errors</parameter>
       </term>      
       <listitem>
        <para>
         Array that will contain the errors
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">array</type>
         <parameter>$warnings</parameter>
       </term>      
       <listitem>
        <para>
         Array that will contain the warnings
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$dir_prefix</parameter>
       </term>      
       <listitem>
        <para>
         directory where source files
         may be found, or empty if they are not available
        </para>
       </listitem>
      </varlistentry>      
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-common.validatepackageinfo.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>
    <para>
     <parameter>bool</parameter> -
     <constant xmlns="http://docbook.org/ns/docbook">TRUE</constant> if valid
    </para>
   </refsection>

   <refsection xml:id="core.ppm.pear-common.validatepackageinfo.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-common.validpackagename">
   <refnamediv>
    <refname><function>PEAR_Common::validPackageName</function></refname>
    <refpurpose>Test whether a string is a valid package name</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/common.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>bool
       <function>PEAR_Common::validPackageName</function></funcdef>
      <paramdef choice="req">string <parameter>$name</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-common.validpackagename.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>Test whether a string contains a valid package name.</para>
    </refsection>
   <refsection xml:id="core.ppm.pear-common.validpackagename.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$name</parameter>
       </term>      
       <listitem>
        <para>
         the package name to test
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-common.validpackagename.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>
    <para>
     <parameter>bool</parameter> -
     Returns <constant xmlns="http://docbook.org/ns/docbook">TRUE</constant> on success, <constant xmlns="http://docbook.org/ns/docbook">FALSE</constant> on failure.
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-common.validpackagename.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-common.xmlfrominfo">
   <refnamediv>
    <refname><function>PEAR_Common::xmlFromInfo</function></refname>
    <refpurpose>Return an XML document based on the package info</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/common.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>string
       <function>PEAR_Common::xmlFromInfo</function></funcdef>
      <paramdef choice="req">array <parameter>$pkginfo</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-common.xmlfrominfo.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>
      Return an XML document based on the package info 
      (as returned by the <function>PEAR_Common::infoFrom*</function> 
      methods).
     </para>
    </refsection>
   <refsection xml:id="core.ppm.pear-common.xmlfrominfo.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">array</type>
         <parameter>$pkginfo</parameter>
       </term>      
       <listitem>
        <para>
         package info
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-common.xmlfrominfo.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>

    <para>
     <parameter>string</parameter> - 
     XML data
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-common.xmlfrominfo.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


</section>

 
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-config"><info><title>PEAR_Config</title></info>
 
 <para>
  Class Trees for <function>PEAR_Config</function>
 </para>
 <para>
  <itemizedlist>
   <listitem>
    <para>
     PEAR
     <itemizedlist>
      <listitem>
       <simpara>
        PEAR_Config
       </simpara>
      </listitem>
     </itemizedlist>
    </para>
   </listitem>
  </itemizedlist>
 </para>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-config.pear-config">
   <refnamediv>
    <refname><function>PEAR_Config::PEAR_Config</function></refname>
    <refpurpose>Constructor</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/config.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>void       <function>PEAR_Config::PEAR_Config</function></funcdef>
      <paramdef choice="opt">string <parameter>$user_file = ''</parameter></paramdef>
      <paramdef choice="opt">string <parameter>$system_file = ''</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-config.pear-config.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>Constructor</para>
    </refsection>
   <refsection xml:id="core.ppm.pear-config.pear-config.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$user_file</parameter>
       </term>      
       <listitem>
        <para>
         file to read user-defined options from
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$system_file</parameter>
       </term>      
       <listitem>
        <para>
         file to read system-wide defaults from
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>

   <refsection xml:id="core.ppm.pear-config.pear-config.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-config.apiversion">
   <refnamediv>
    <refname><function>PEAR_Config::apiVersion</function></refname>
    <refpurpose>return API version (1.1 as of PEAR 1.4.0)</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once '/Config.php'; (since PEAR 1.4.0)
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>void <function>PEAR_Config::apiVersion</function></funcdef>
      <paramdef choice="req"/>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>

    <refsection xml:id="core.ppm.pear-config.apiversion.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>
      Returns API version (1.1 as of PEAR 1.4.0).
     </para>
    </refsection>
   <refsection xml:id="core.ppm.pear-config.apiversion.throws">
    <title xmlns="http://docbook.org/ns/docbook">Throws</title>
        <para>
      <emphasis>throws</emphasis> no exceptions thrown
    </para>
       </refsection>
   <refsection xml:id="core.ppm.pear-config.apiversion.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-config.definedby">
   <refnamediv>
    <refname><function>PEAR_Config::definedBy</function></refname>
    <refpurpose>Tells what config layer that gets to define a key</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/config.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>string       <function>PEAR_Config::definedBy</function></funcdef>
      <paramdef choice="req">string <parameter>$key</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-config.definedby.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>Tells what config layer that gets to define a key.</para>
    </refsection>
   <refsection xml:id="core.ppm.pear-config.definedby.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$key</parameter>
       </term>      
       <listitem>
        <para>
         config key
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-config.definedby.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>
    <para>
     <parameter>string</parameter> - the config layer, or an empty string if not found
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-config.definedby.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-config.deletechannel">
   <refnamediv>
    <refname><function>PEAR_Config::deleteChannel</function></refname>
    <refpurpose>deleteChannel</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once '/Config.php'; (since PEAR 1.4.0)
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>void <function>PEAR_Config::deleteChannel</function></funcdef>
      <paramdef choice="req">string <parameter>$channel</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>

    <refsection xml:id="core.ppm.pear-config.deletechannel.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>
      remove a channel's configuration entirely.
     </para>
    </refsection>
   <refsection xml:id="core.ppm.pear-config.deletechannel.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
        <parameter>$channel</parameter>
       </term>
       <listitem>
        <para>
         Channel name to delete (channel server).
        </para>
       </listitem>
      </varlistentry>     
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-config.deletechannel.throws">
    <title xmlns="http://docbook.org/ns/docbook">Throws</title>
        <para>
      <emphasis>throws</emphasis> no exceptions thrown
    </para>
       </refsection>
   <refsection xml:id="core.ppm.pear-config.deletechannel.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-config.get">
   <refnamediv>
    <refname><function>PEAR_Config::get</function></refname>
    <refpurpose>Returns a configuration value</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/config.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>mixed       <function>PEAR_Config::get</function></funcdef>
      <paramdef choice="req">string <parameter>$key</parameter></paramdef>
      <paramdef choice="opt">mixed <parameter>$layer</parameter>
       <initializer>null</initializer>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-config.get.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>Returns a configuration value, prioritizing layers as per the layers property.</para>
    </refsection>
   <refsection xml:id="core.ppm.pear-config.get.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$key</parameter>
       </term>      
       <listitem>
        <para>
         config key
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">mixed</type>
         <parameter>$layer</parameter>
       </term>      
       <listitem>
        <para>
         layer key
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-config.get.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>
    <para>
    <parameter>mixed</parameter> the config value, or NULL if not found
    </para>
   </refsection>


   <refsection xml:id="core.ppm.pear-config.get.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-config.getconffile">
   <refnamediv>
    <refname><function>PEAR_Config::getConfFile</function></refname>
    <refpurpose>Gets the file used for storing the config for a layer</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once '/Config.php'; (since PEAR 1.4.0)
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>void <function>PEAR_Config::getConfFile</function></funcdef>
      <paramdef choice="req">string <parameter>$layer</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>

    <refsection xml:id="core.ppm.pear-config.getconffile.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>
      Use this to retrieve the name of the configuration file that provides values
      for a particular configuration layer.
     </para>
    </refsection>
   <refsection xml:id="core.ppm.pear-config.getconffile.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
        <parameter>$layer</parameter>
       </term>
       <listitem>
        <para>
         <literal>user</literal>, <literal>system</literal>, or <literal>ftp</literal>
        </para>
       </listitem>
      </varlistentry>     
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-config.getconffile.throws">
    <title xmlns="http://docbook.org/ns/docbook">Throws</title>
        <para>
      <emphasis>throws</emphasis> no exceptions thrown
    </para>
       </refsection>
   <refsection xml:id="core.ppm.pear-config.getconffile.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-config.getdefaultchannel">
   <refnamediv>
    <refname><function>PEAR_Config::getDefaultChannel</function></refname>
    <refpurpose>Retrieve the default channel.</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once '/Config.php'; (since PEAR 1.4.0)
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef><replaceable>string|false</replaceable> <function>PEAR_Config::getDefaultChannel</function></funcdef>
      <paramdef choice="opt">string <parameter> $layer</parameter>
       <initializer>null</initializer>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>

    <refsection xml:id="core.ppm.pear-config.getdefaultchannel.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>
      On startup, channels are not initialized, so if the default channel is not
      pear.php.net, then initialize the config.
     </para>
    </refsection>
   <refsection xml:id="core.ppm.pear-config.getdefaultchannel.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
        <parameter>$layer</parameter>
       </term>
       <listitem>
        <para>
         layer from which to retrieve the registry, or null for the first to match
        </para>
       </listitem>
      </varlistentry>     
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-config.getdefaultchannel.throws">
    <title xmlns="http://docbook.org/ns/docbook">Throws</title>
        <para>
      <emphasis>throws</emphasis> no exceptions thrown
    </para>
       </refsection>
   <refsection xml:id="core.ppm.pear-config.getdefaultchannel.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-config.getdocs">
   <refnamediv>
    <refname><function>PEAR_Config::getDocs</function></refname>
    <refpurpose>Get the documentation for a config value</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/config.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>string       <function>PEAR_Config::getDocs</function></funcdef>
      <paramdef choice="req">string <parameter>$key</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-config.getdocs.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>Get the documentation for a config value.</para>
    </refsection>
   <refsection xml:id="core.ppm.pear-config.getdocs.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$key</parameter>
       </term>      
       <listitem>
        <para>
         config key
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-config.getdocs.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>

    <para>
     <parameter>string</parameter> - documentation string
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-config.getdocs.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-config.getftp">
   <refnamediv>
    <refname><function>PEAR_Config::getFTP</function></refname>
    <refpurpose>The ftp server is set in <link linkend="core.ppm.pear-config.readftpconfigfile"><function>readFTPConfigFile</function></link>.
     It exists only if a remote configuration file has been specified
    </refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once '/Config.php'; (since PEAR 1.4.0)
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef><replaceable>PEAR_FTP|false</replaceable>&amp; <function>PEAR_Config::getFTP</function></funcdef>
<paramdef choice="req"/>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>

    <refsection xml:id="core.ppm.pear-config.getftp.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>returns the object that can be used for accessing the remote FTP server, or false
     if none should be used.</para>

    </refsection>
   <refsection xml:id="core.ppm.pear-config.getftp.throws">
    <title xmlns="http://docbook.org/ns/docbook">Throws</title>
        <para>
      <emphasis>throws</emphasis> no exceptions thrown
    </para>
       </refsection>
   <refsection xml:id="core.ppm.pear-config.getftp.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-config.getgroup">
   <refnamediv>
    <refname><function>PEAR_Config::getGroup</function></refname>
    <refpurpose>Get the parameter group for a config key</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/config.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>string       <function>PEAR_Config::getGroup</function></funcdef>
      <paramdef choice="req">string <parameter>$key</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-config.getgroup.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>Get the parameter group for a config key.</para>
    </refsection>
   <refsection xml:id="core.ppm.pear-config.getgroup.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$key</parameter>
       </term>      
       <listitem>
        <para>
         config key
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-config.getgroup.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>
    <para>
      <parameter>string</parameter> - parameter group
    </para>
   </refsection>

   <refsection xml:id="core.ppm.pear-config.getgroup.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-config.getgroupkeys">
   <refnamediv>
    <refname><function>PEAR_Config::getGroupKeys</function></refname>
    <refpurpose>Get the list of the parameters in a group</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/config.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>array       <function>PEAR_Config::getGroupKeys</function></funcdef>
      <paramdef choice="req">string <parameter>$group</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-config.getgroupkeys.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>Get the list of the parameters in a group.</para>
    </refsection>
   <refsection xml:id="core.ppm.pear-config.getgroupkeys.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$group</parameter>
       </term>      
       <listitem>
        <para>
         parameter group
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-config.getgroupkeys.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>
    <para>
     <parameter>array</parameter> list of parameters in
     <parameter>$group</parameter>
    </para>
   </refsection>


   <refsection xml:id="core.ppm.pear-config.getgroupkeys.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-config.getgroups">
   <refnamediv>
    <refname><function>PEAR_Config::getGroups</function></refname>
    <refpurpose>Get the list of parameter groups</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/config.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>array       <function>PEAR_Config::getGroups</function></funcdef>
<void/>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-config.getgroups.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>Get the list of parameter groups.</para>
    </refsection>
   <refsection xml:id="core.ppm.pear-config.getgroups.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>

    <para>
     <parameter>array</parameter> - list of parameter groups
    </para>
   </refsection>

   <refsection xml:id="core.ppm.pear-config.getgroups.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-config.getkeys">
   <refnamediv>
    <refname><function>PEAR_Config::getKeys</function></refname>
    <refpurpose>Get all the current config keys</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/config.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>array       <function>PEAR_Config::getKeys</function></funcdef>
<void/>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-config.getkeys.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>Get all the current config keys</para>
    </refsection>
   <refsection xml:id="core.ppm.pear-config.getkeys.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>
    <para>
      <parameter>array</parameter> - simple array of config keys
    </para>
   </refsection>

   <refsection xml:id="core.ppm.pear-config.getkeys.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-config.getlayers">
   <refnamediv>
    <refname><function>PEAR_Config::getLayers</function></refname>
    <refpurpose>Returns the layers defined</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/config.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>array       <function>PEAR_Config::getLayers</function></funcdef>
<void/>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-config.getlayers.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>Returns the layers defined, except the <parameter>'default'</parameter> one</para>
    </refsection>
   <refsection xml:id="core.ppm.pear-config.getlayers.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>

    <para>
     <parameter>array</parameter> the defined layers
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-config.getlayers.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-config.getprompt">
   <refnamediv>
    <refname><function>PEAR_Config::getPrompt</function></refname>
    <refpurpose>Get short documentation for a config value</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/config.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>string       <function>PEAR_Config::getPrompt</function></funcdef>
      <paramdef choice="req">string <parameter>$key</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-config.getprompt.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>Get the short documentation for a config value.</para>
    </refsection>
   <refsection xml:id="core.ppm.pear-config.getprompt.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$key</parameter>
       </term>      
       <listitem>
        <para>
         config key
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-config.getprompt.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>    
    <para>
     <parameter>string</parameter> short documentation string
    </para>
   </refsection>

   <refsection xml:id="core.ppm.pear-config.getprompt.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-config.getregistry">
   <refnamediv>
    <refname><function>PEAR_Config::getRegistry</function></refname>
    <refpurpose>getRegistry</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once '/Config.php'; (since PEAR 1.4.0)
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>PEAR_Registry|false&amp; <function>PEAR_Config::getRegistry</function></funcdef>
      <paramdef choice="opt">string <parameter> $use</parameter>
       <initializer>null</initializer>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>

    <refsection xml:id="core.ppm.pear-config.getregistry.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para xmlns="http://docbook.org/ns/docbook">This package is not documented yet.</para>
    </refsection>
   <refsection xml:id="core.ppm.pear-config.getregistry.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
        <parameter>$use</parameter>
       </term>
       <listitem>
        <para>
         This parameter determines which layer will be used to retrieve a registry based
         on the <literal>php_dir</literal> configuration variable for that layer.  The
         default value of null will use the first layer that contains a valid php_dir,
         whereas if specified as <literal>user</literal>, <literal>system</literal> or
         <literal>ftp</literal>, it will attempt to return the registry for that layer.
        </para>
        <para>
         On failure to retrieve a registry, it returns false
        </para>
       </listitem>
      </varlistentry>     
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-config.getregistry.throws">
    <title xmlns="http://docbook.org/ns/docbook">Throws</title>
        <para>
      <emphasis>throws</emphasis> no exceptions thrown
    </para>
       </refsection>
   <refsection xml:id="core.ppm.pear-config.getregistry.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-config.getremote">
   <refnamediv>
    <refname><function>PEAR_Config::getRemote</function></refname>
    <refpurpose>getRemote</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once '/Config.php'; (since PEAR 1.4.0)
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>PEAR_Remote&amp; <function>PEAR_Config::getRemote</function></funcdef>
<paramdef choice="req"/>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>

    <refsection xml:id="core.ppm.pear-config.getremote.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>
      This returns a PEAR_Remote based on the current PEAR_Config object.
     </para>
    </refsection>
   <refsection xml:id="core.ppm.pear-config.getremote.throws">
    <title xmlns="http://docbook.org/ns/docbook">Throws</title>
        <para>
      <emphasis>throws</emphasis> no exceptions thrown
    </para>
       </refsection>
   <refsection xml:id="core.ppm.pear-config.getremote.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-config.getrest">
   <refnamediv>
    <refname><function>PEAR_Config::getREST</function></refname>
    <refpurpose>getREST</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once '/Config.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>PEAR_REST&amp;      <function>PEAR_Config::getREST</function></funcdef>
      <paramdef choice="req">string <parameter>$version</parameter></paramdef>
      <paramdef choice="opt">array <parameter> $options = array()</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>

    <refsection xml:id="core.ppm.pear-config.getrest.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para xmlns="http://docbook.org/ns/docbook">This package is not documented yet.</para>
    </refsection>
   <refsection xml:id="core.ppm.pear-config.getrest.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
        <parameter>$version</parameter>
       </term>
       <listitem>
        <para>
         This should be <literal>1.0</literal> in PEAR 1.4.0.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">array</type>
        <parameter>$options</parameter>
       </term>
       <listitem>
        <para>
         options for the <link linkend="core.ppm.pear-rest"><classname>PEAR_REST</classname></link> constructor
        </para>
       </listitem>
      </varlistentry>     
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-config.getrest.throws">
    <title xmlns="http://docbook.org/ns/docbook">Throws</title>
        <para>
      <emphasis>throws</emphasis> no exceptions thrown
    </para>
       </refsection>
   <refsection xml:id="core.ppm.pear-config.getrest.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-config.getsetvalues">
   <refnamediv>
    <refname><function>PEAR_Config::getSetValues</function></refname>
    <refpurpose>Get the list of allowed set values for a config value</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/config.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>array       <function>PEAR_Config::getSetValues</function></funcdef>
      <paramdef choice="req">string <parameter>$key</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-config.getsetvalues.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>
      Get the list of allowed set values for a config value.
      Returns NULL for config values that are not sets.
     </para>
    </refsection>
   <refsection xml:id="core.ppm.pear-config.getsetvalues.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$key</parameter>
       </term>      
       <listitem>
        <para>
         config key
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-config.getsetvalues.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>
    <para>
     <parameter>array</parameter> - 
     enumerated array of set values, or NULL if the config key 
     is unknown or not a set
    </para>
   </refsection>

   <refsection xml:id="core.ppm.pear-config.getsetvalues.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-config.gettype">
   <refnamediv>
    <refname><function>PEAR_Config::getType</function></refname>
    <refpurpose>Get the type of a config value</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/config.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>string       <function>PEAR_Config::getType</function></funcdef>
      <paramdef choice="req">string <parameter>$key</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-config.gettype.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>Get the type of a config value.</para>
    </refsection>
   <refsection xml:id="core.ppm.pear-config.gettype.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$key</parameter>
       </term>      
       <listitem>
        <para>
         config key
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-config.gettype.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>
    
    <para>
     <parameter>string</parameter> - 
     type, one of <quote>string</quote>, 
     <quote>integer</quote>, 
     <quote>file</quote>, 
     <quote>directory</quote>,
     <quote>set</quote> or
     <quote>password</quote>.
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-config.gettype.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-config.isdefined">
   <refnamediv>
    <refname><function>PEAR_Config::isDefined</function></refname>
    <refpurpose>Tells whether a key exists as config value</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/config.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>bool       <function>PEAR_Config::isDefined</function></funcdef>
      <paramdef choice="req">string <parameter>$key</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-config.isdefined.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>Tells whether a given key exists as a config value.</para>
    </refsection>
   <refsection xml:id="core.ppm.pear-config.isdefined.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$key</parameter>
       </term>      
       <listitem>
        <para>
         config key
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-config.isdefined.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>
    <para>
     <parameter>bool</parameter> - whether <parameter>$key</parameter> exists in this object
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-config.isdefined.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-config.isdefinedlayer">
   <refnamediv>
    <refname><function>PEAR_Config::isDefinedLayer</function></refname>
    <refpurpose>Tells whether a config layer exists</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'config.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>bool       <function>PEAR_Config::isDefinedLayer</function></funcdef>
      <paramdef choice="req">string <parameter>$layer</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-config.isdefinedlayer.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>Tells whether a given config layer exists.</para>
    </refsection>
   <refsection xml:id="core.ppm.pear-config.isdefinedlayer.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$layer</parameter>
       </term>      
       <listitem>
        <para>
         config layer
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-config.isdefinedlayer.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>

    <para>
     <parameter>bool</parameter> - whether <parameter>$layer</parameter> exists in this object
    </para>
   </refsection>

   <refsection xml:id="core.ppm.pear-config.isdefinedlayer.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-config.mergeconfigfile">
   <refnamediv>
    <refname><function>PEAR_Config::mergeConfigFile</function></refname>
    <refpurpose>Merges data into a config layer from a file</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/config.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>bool       <function>PEAR_Config::mergeConfigFile</function></funcdef>
      <paramdef choice="req">string <parameter>$file</parameter></paramdef>
      <paramdef choice="opt">bool <parameter>$override</parameter>
       <initializer>true</initializer>
      </paramdef>
      <paramdef choice="opt">string <parameter>$layer = 'user'</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-config.mergeconfigfile.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>
      Merges data into a config layer from a file. Does 
      the same thing as 
      <link linkend="core.ppm.pear-config.readconfigfile">
       <function>readConfigFile</function></link>, 
      except it does not replace all existing values in the
      config layer.
     </para>
    </refsection>
   <refsection xml:id="core.ppm.pear-config.mergeconfigfile.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$file</parameter>
       </term>      
       <listitem>
        <para>
         file to read from
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">boolean</type>
         <parameter>$override</parameter>
       </term>      
       <listitem>
        <para>
         whether to overwrite existing data
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$layer</parameter>
       </term>      
       <listitem>
        <para>
         config layer to insert data into (<parameter>'user'</parameter> or
         <parameter>'system'</parameter>)
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-config.mergeconfigfile.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>
    <para>
     <parameter>bool</parameter> -
     Returns <constant xmlns="http://docbook.org/ns/docbook">TRUE</constant> on success,
<classname xmlns="http://docbook.org/ns/docbook">PEAR_Error</classname> on failure.
    </para>
   </refsection>

   <refsection xml:id="core.ppm.pear-config.mergeconfigfile.throws">
    <title xmlns="http://docbook.org/ns/docbook">Throws</title>
    <para>
     <table><title>Possible PEAR_Error values</title>
            
      <tgroup cols="4">

       <thead>
        <row>
         <entry>Error code</entry>
         <entry>Error value</entry>        
         <entry>Meaning</entry>        
         <entry>Solution</entry>        
        </row>
       </thead>
       <tbody>
        <row>
         <entry/>
         <entry><quote/></entry>
         <entry/>
         <entry/>
        </row>       
       </tbody>
      </tgroup>
     </table>
    </para>    
   </refsection>

   <refsection xml:id="core.ppm.pear-config.mergeconfigfile.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-config.noregistry">
   <refnamediv>
    <refname><function>PEAR_Config::noRegistry</function></refname>
    <refpurpose>noRegistry</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once '/Config.php'; (since PEAR 1.4.0)
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>void <function>PEAR_Config::noRegistry</function></funcdef>
<paramdef choice="req"/>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>

    <refsection xml:id="core.ppm.pear-config.noregistry.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>
      Use this method to disable automatic creation of PEAR_Registry objects when
      reading from a configuration file or changing php_dir configuration variable.
     </para>
    </refsection>
   <refsection xml:id="core.ppm.pear-config.noregistry.throws">
    <title xmlns="http://docbook.org/ns/docbook">Throws</title>
        <para>
      <emphasis>throws</emphasis> no exceptions thrown
    </para>
       </refsection>
   <refsection xml:id="core.ppm.pear-config.noregistry.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-config.readconfigfile">
   <refnamediv>
    <refname><function>PEAR_Config::readConfigFile</function></refname>
    <refpurpose>Reads configuration data from a file</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/config.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>bool       <function>PEAR_Config::readConfigFile</function></funcdef>
      <paramdef choice="opt">string <parameter>$file</parameter>
       <initializer>null</initializer>
      </paramdef>
      <paramdef choice="opt">string <parameter>$layer = 'user'</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-config.readconfigfile.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>
      Reads configuration data from a file. 
      All existing values in the config layer 
      are discarded and replaced with data from the file.</para>
    </refsection>
   <refsection xml:id="core.ppm.pear-config.readconfigfile.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$file</parameter>
       </term>      
       <listitem>
        <para>
         file to read from, if <constant xmlns="http://docbook.org/ns/docbook">NULL</constant> or not specified, 
         the last-used file for the same layer (second param) is used
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$layer</parameter>
       </term>      
       <listitem>
        <para>
         config layer to insert data into (<parameter>'user'</parameter> or <parameter>'system'</parameter>)
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-config.readconfigfile.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>
    <para>
     <parameter>bool</parameter> -
     Returns <constant xmlns="http://docbook.org/ns/docbook">TRUE</constant> on success,
<classname xmlns="http://docbook.org/ns/docbook">PEAR_Error</classname> on failure.
    </para>
   </refsection>

   <refsection xml:id="core.ppm.pear-config.readconfigfile.throws">
    <title xmlns="http://docbook.org/ns/docbook">Throws</title>
    <para>
     <table><title>Possible PEAR_Error values</title>
            
      <tgroup cols="4">

       <thead>
        <row>
         <entry>Error code</entry>
         <entry>Error value</entry>        
         <entry>Meaning</entry>        
         <entry>Solution</entry>        
        </row>
       </thead>
       <tbody>
        <row>
         <entry/>
         <entry><quote/></entry>
         <entry/>
         <entry/>
        </row>       
       </tbody>
      </tgroup>
     </table>
    </para>    
   </refsection>

   <refsection xml:id="core.ppm.pear-config.readconfigfile.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-config.readftpconfigfile">
   <refnamediv>
    <refname><function>PEAR_Config::readFTPConfigFile</function></refname>
    <refpurpose>readFTPConfigFile</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once '/Config.php'; (since PEAR 1.4.0)
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef><replaceable>true|PEAR_Error</replaceable> <function>PEAR_Config::readFTPConfigFile</function></funcdef>
      <paramdef choice="req">string <parameter>$path</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>

    <refsection xml:id="core.ppm.pear-config.readftpconfigfile.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>
      Process a ftp configuration file by connecting to the server, retrieving the
      configuration file and parsing it normally.  This function uses Net_FTP through
      the PEAR_FTP class.
     </para>
    </refsection>
   <refsection xml:id="core.ppm.pear-config.readftpconfigfile.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
        <parameter>$path</parameter>
       </term>
       <listitem>
        <para>
         url to the remote config file, like ftp://www.example.com/pear/config.ini
        </para>
       </listitem>
      </varlistentry>     
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-config.readftpconfigfile.throws">
    <title xmlns="http://docbook.org/ns/docbook">Throws</title>
        <para>
      <emphasis>throws</emphasis> no exceptions thrown
    </para>
       </refsection>
   <refsection xml:id="core.ppm.pear-config.readftpconfigfile.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-config.remove">
   <refnamediv>
    <refname><function>PEAR_Config::remove</function></refname>
    <refpurpose>Remove a config key from a config layer</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/config.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>bool       <function>PEAR_Config::remove</function></funcdef>
      <paramdef choice="req">string <parameter>$key</parameter></paramdef>
      <paramdef choice="opt">string <parameter>$layer = 'user'</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-config.remove.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>Remove a config key from a specific config layer.</para>
    </refsection>
   <refsection xml:id="core.ppm.pear-config.remove.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$key</parameter>
       </term>      
       <listitem>
        <para>
         config key
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$layer</parameter>
       </term>      
       <listitem>
        <para>
         config layer
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-config.remove.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>

    <para>
     <parameter>bool</parameter> -
     Returns <constant xmlns="http://docbook.org/ns/docbook">TRUE</constant> on success,
<classname xmlns="http://docbook.org/ns/docbook">PEAR_Error</classname> on failure.
    </para>
   </refsection>
   
   <refsection xml:id="core.ppm.pear-config.remove.throws">
    <title xmlns="http://docbook.org/ns/docbook">Throws</title>
    <para>
     <table><title>Possible PEAR_Error values</title>
            
      <tgroup cols="4">

       <thead>
        <row>
         <entry>Error code</entry>
         <entry>Error value</entry>        
         <entry>Meaning</entry>        
         <entry>Solution</entry>        
        </row>
       </thead>
       <tbody>
        <row>
         <entry/>
         <entry><quote/></entry>
         <entry/>
         <entry/>
        </row>       
       </tbody>
      </tgroup>
     </table>
    </para>    
   </refsection>

   <refsection xml:id="core.ppm.pear-config.remove.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-config.removelayer">
   <refnamediv>
    <refname><function>PEAR_Config::removeLayer</function></refname>
    <refpurpose>Temporarily remove an entire config layer</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/config.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>bool       <function>PEAR_Config::removeLayer</function></funcdef>
      <paramdef choice="req">string <parameter>$layer</parameter></paramdef>
     
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-config.removelayer.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>Temporarily remove an entire config layer.  USE WITH CARE!</para>
    </refsection>
   <refsection xml:id="core.ppm.pear-config.removelayer.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$layer</parameter>
       </term>      
       <listitem>
        <para>
         config key
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-config.removelayer.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>
    <para>
     <parameter>bool</parameter> -
     Returns <constant xmlns="http://docbook.org/ns/docbook">TRUE</constant> on success, <constant xmlns="http://docbook.org/ns/docbook">FALSE</constant> on failure.     
    </para>
   </refsection>

   <refsection xml:id="core.ppm.pear-config.removelayer.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-config.set">
   <refnamediv>
    <refname><function>PEAR_Config::set</function></refname>
    <refpurpose>Set config value in specific layer</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/config.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>bool       <function>PEAR_Config::set</function></funcdef>
      <paramdef choice="req">string <parameter>$key</parameter></paramdef>
      <paramdef choice="req">string <parameter>$value</parameter></paramdef>
      <paramdef choice="opt">string <parameter>$layer = 'user'</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-config.set.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>
      Set a config value in a specific layer (defaults to 
      <parameter>'user'</parameter>). Enforces the types defined 
      in the configuration_info array.  An integer config 
      variable will be cast to int, and a set config 
      variable will be validated against its legal values.</para>
    </refsection>
   <refsection xml:id="core.ppm.pear-config.set.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$key</parameter>
       </term>      
       <listitem>
        <para>
         config key
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$value</parameter>
       </term>      
       <listitem>
        <para>
         config value
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$layer</parameter>
       </term>      
       <listitem>
        <para>
         config layer
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-config.set.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title> 
    <para>
     <parameter>bool</parameter> -
     Returns <constant xmlns="http://docbook.org/ns/docbook">TRUE</constant> on success, <constant xmlns="http://docbook.org/ns/docbook">FALSE</constant> on failure.
    </para>
   </refsection>

   <refsection xml:id="core.ppm.pear-config.set.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-config.setchannels">
   <refnamediv>
    <refname><function>PEAR_Config::setChannels</function></refname>
    <refpurpose>Set the list of channels.</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once '/Config.php'; (since PEAR 1.4.0)
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>bool <function>PEAR_Config::setChannels</function></funcdef>
      <paramdef choice="req">array <parameter>$channels</parameter></paramdef>
      <paramdef choice="opt">bool <parameter> $merge</parameter>
       <initializer>false</initializer>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>

    <refsection xml:id="core.ppm.pear-config.setchannels.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>
      This should be set via a call to <function>PEAR_Registry::listChannels</function>.
      A call to this function sets up empty arrays for each channel in configurations.
     </para>

    </refsection>
   <refsection xml:id="core.ppm.pear-config.setchannels.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">array</type>
        <parameter>$channels</parameter>
       </term>
       <listitem>
        <para>
         a simple list of channel names.
        </para>
       </listitem>
      </varlistentry>     
     </variablelist>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">boolean</type>
        <parameter>$merge</parameter>
       </term>
       <listitem>
        <para>
         if true, then the list of channel is merged with the existing list, otherwise
         it replaces the existing list.
        </para>
       </listitem>
      </varlistentry>     
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-config.setchannels.returns">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>
        <para>
      <emphasis>returns</emphasis> success of operation
    </para>
       </refsection>
   <refsection xml:id="core.ppm.pear-config.setchannels.throws">
    <title xmlns="http://docbook.org/ns/docbook">Throws</title>
        <para>
      <emphasis>throws</emphasis> no exceptions thrown
    </para>
       </refsection>
   <refsection xml:id="core.ppm.pear-config.setchannels.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-config.setinstallroot">
   <refnamediv>
    <refname><function>PEAR_Config::setInstallRoot</function></refname>
    <refpurpose>setInstallRoot</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once '/Config.php'; (since PEAR 1.4.0)
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>void <function>PEAR_Config::setInstallRoot</function></funcdef>
      <paramdef choice="req">string|false <parameter>$root</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>

    <refsection xml:id="core.ppm.pear-config.setinstallroot.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>
      This is used to implement the --installroot option for installation.  In earlier
      PEAR versions, this was implemented in <function>PEAR_Installer::install</function>,
      but this makes it more difficult to track with the introduction of channels, and to
      satisfy better encapsulation, it has been moved to <classname>PEAR_Config</classname>.
     </para>
     <para>
      Pass in a full path.  On retrieving any directory configuration variable, the
      value will be prepended with the installroot specified in this method.  For example,
      if <literal>php_dir</literal> is <literal>/usr/lib/php</literal>, and
      <function>setInstallRoot</function> is used with <literal>/hoopla/boo</literal>,
      the value returned from <function>get</function> would be
      <literal>/hoopla/boo/usr/lib/php</literal>.  Use an empty string <literal>''</literal>
      to reset an installroot.
     </para>
    </refsection>
   <refsection xml:id="core.ppm.pear-config.setinstallroot.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>|<constant xmlns="http://docbook.org/ns/docbook">FALSE</constant>
        <parameter>$root</parameter>
       </term>
       <listitem>
        <para>
         installation directory to prepend to all _dir variables, or <constant xmlns="http://docbook.org/ns/docbook">FALSE</constant> to     
         disable
        </para>
       </listitem>
      </varlistentry>     
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-config.setinstallroot.throws">
    <title xmlns="http://docbook.org/ns/docbook">Throws</title>
        <para>
      <emphasis>throws</emphasis> no exceptions thrown
    </para>
       </refsection>
   <refsection xml:id="core.ppm.pear-config.setinstallroot.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-config.setregistry">
   <refnamediv>
    <refname><function>PEAR_Config::setRegistry</function></refname>
    <refpurpose>This is to allow customization like the use of installroot</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once '/Config.php'; (since PEAR 1.4.0)
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>bool      <function>PEAR_Config::setRegistry</function></funcdef>
      <paramdef choice="req">PEAR_Registry|false <parameter>&amp;$reg</parameter></paramdef>
      <paramdef choice="opt">string <parameter> $layer = 'user'</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>

    <refsection xml:id="core.ppm.pear-config.setregistry.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>
      Use this to override the automatic registry creation performed whenever the
      <literal>php_dir</literal> configuration variable is modified.
     </para>
     <para>
      If <link linkend="core.ppm.pear-config.noregistry"><function>noRegistry</function></link>
      has been called, this call will be ignored and <constant xmlns="http://docbook.org/ns/docbook">FALSE</constant> returned.  In addition, it is
      not possible to set the registry for the <literal>ftp</literal> layer.
     </para>
    </refsection>
   <refsection xml:id="core.ppm.pear-config.setregistry.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type>PEAR_Registry|false</type>
        <parameter>&amp;$reg</parameter>
       </term>
       <listitem>
        <para>
         The <classname>PEAR_Registry</classname> that will be used, or false to reset the
         registry.
        </para>
       </listitem>
      </varlistentry>     
     </variablelist>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
        <parameter>$layer</parameter>
       </term>
       <listitem>
        <para>
         This must be either <literal>user</literal> or <literal>system</literal>
        </para>
       </listitem>
      </varlistentry>     
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-config.setregistry.throws">
    <title xmlns="http://docbook.org/ns/docbook">Throws</title>
        <para>
      <emphasis>throws</emphasis> no exceptions thrown
    </para>
       </refsection>
   <refsection xml:id="core.ppm.pear-config.setregistry.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-config.singleton">
   <refnamediv>
    <refname><function>PEAR_Config::singleton</function></refname>
    <refpurpose>Return a reference of a PEAR_Config object</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/config.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>object &amp;<function>PEAR_Config::singleton</function></funcdef>
      <paramdef choice="opt">string <parameter>$user_file = ''</parameter></paramdef>
      <paramdef choice="opt">string <parameter>$system_file = ''</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-config.singleton.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>
      If you want to keep only one instance of 
      this class in use, this method will give you 
      a reference to the last created 
      <classname>PEAR_Config</classname> object if 
      one exists, or create a new object.
     </para>
    </refsection>
   <refsection xml:id="core.ppm.pear-config.singleton.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$user_file</parameter>
       </term>      
       <listitem>
        <para>
         file to read user-defined options from
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$system_file</parameter>
       </term>      
       <listitem>
        <para>
         file to read system-wide defaults from
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-config.singleton.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>

    <para>
     <parameter>object</parameter> -
     an existing or new <classname>PEAR_Config</classname> instance
    </para>
   </refsection>

   <refsection xml:id="core.ppm.pear-config.singleton.see">
    <title xmlns="http://docbook.org/ns/docbook">See</title>
    <para>
     <link linkend="core.ppm.pear-config.pear-config">
      <function>PEAR_Config::PEAR_Config</function>
     </link> 
    </para>
   </refsection>

   <refsection xml:id="core.ppm.pear-config.singleton.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function should be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-config.store">
   <refnamediv>
    <refname><function>PEAR_Config::store</function></refname>
    <refpurpose>Stores configuration data in a layer</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/config.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>bool       <function>PEAR_Config::store</function></funcdef>
      <paramdef choice="opt">string <parameter>$layer = 'user'</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-config.store.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>Stores configuration data in a layer.</para>
    </refsection>
   <refsection xml:id="core.ppm.pear-config.store.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$layer</parameter>
       </term>      
       <listitem>
        <para>
         config layer to store
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-config.store.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>
    <para>
     <emphasis>bool</emphasis> -
     Returns <constant xmlns="http://docbook.org/ns/docbook">TRUE</constant> on success,
<classname xmlns="http://docbook.org/ns/docbook">PEAR_Error</classname> on failure.
    </para>
   </refsection>

   <refsection xml:id="core.ppm.pear-config.store.throws">
    <title xmlns="http://docbook.org/ns/docbook">Throws</title>
    <para>
     <table><title>Possible PEAR_Error values</title>
            
      <tgroup cols="4">

       <thead>
        <row>
         <entry>Error code</entry>
         <entry>Error value</entry>        
         <entry>Meaning</entry>        
         <entry>Solution</entry>        
        </row>
       </thead>
       <tbody>
        <row>
         <entry/>
         <entry><quote/></entry>
         <entry/>
         <entry/>
        </row>       
       </tbody>
      </tgroup>
     </table>
    </para>    
   </refsection>

   <refsection xml:id="core.ppm.pear-config.store.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-config.todefault">
   <refnamediv>
    <refname><function>PEAR_Config::toDefault</function></refname>
    <refpurpose>Revert value of config key to the system-defined one</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/config.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>bool       <function>PEAR_Config::toDefault</function></funcdef>
      <paramdef choice="req">string <parameter>$key</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-config.todefault.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>
      Unset the user-defined value of a config key, 
      reverting the value to the system-defined one.
     </para>
    </refsection>
   <refsection xml:id="core.ppm.pear-config.todefault.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$key</parameter>
       </term>      
       <listitem>
        <para>
         config key
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-config.todefault.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>

    <para>
     <parameter>bool</parameter> -
     Returns <constant xmlns="http://docbook.org/ns/docbook">TRUE</constant> on success, <constant xmlns="http://docbook.org/ns/docbook">FALSE</constant> on failure.
    </para>
   </refsection>

   <refsection xml:id="core.ppm.pear-config.todefault.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-config.validconfiguration">
   <refnamediv>
    <refname><function>PEAR_Config::validConfiguration</function></refname>
    <refpurpose>Determine whether any configuration files have been detected, and whether a
 registry object can be retrieved from this configuration.</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once '/Config.php'; (since PEAR 1.4.0)
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>bool <function>PEAR_Config::validConfiguration</function></funcdef>
<paramdef choice="req"/>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>

    <refsection xml:id="core.ppm.pear-config.validconfiguration.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>
      This method can be used to ward off any real problems with the default configuration.
     </para>
    </refsection>
   <refsection xml:id="core.ppm.pear-config.validconfiguration.throws">
    <title xmlns="http://docbook.org/ns/docbook">Throws</title>
        <para>
      <emphasis>throws</emphasis> no exceptions thrown
    </para>
       </refsection>
   <refsection xml:id="core.ppm.pear-config.validconfiguration.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-config.writeconfigfile">
   <refnamediv>
    <refname><function>PEAR_Config::writeConfigFile</function></refname>
    <refpurpose>Write data into config layer from file</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/config.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>bool       <function>PEAR_Config::writeConfigFile</function></funcdef>
      <paramdef choice="opt">string <parameter>$file</parameter>
       <initializer>null</initializer>
      </paramdef>
      <paramdef choice="opt">bool <parameter>$layer = 'user'</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-config.writeconfigfile.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>
      Writes data into a config layer from a file.
     </para>
    </refsection>
   <refsection xml:id="core.ppm.pear-config.writeconfigfile.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$file</parameter>
       </term>      
       <listitem>
        <para>
         file to read from
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">boolean</type>
         <parameter>$layer</parameter>
       </term>      
       <listitem>
        <para>
         whether to overwrite existing data
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-config.writeconfigfile.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>

    <para>
     <parameter>bool</parameter> - 
     Returns <constant xmlns="http://docbook.org/ns/docbook">TRUE</constant> on success,
<classname xmlns="http://docbook.org/ns/docbook">PEAR_Error</classname> on failure.
    </para>
   </refsection>

   <refsection xml:id="core.ppm.pear-config.writeconfigfile.throws">
    <title xmlns="http://docbook.org/ns/docbook">Throws</title>
    <para>
     <table><title>Possible PEAR_Error values</title>
            
      <tgroup cols="4">

       <thead>
        <row>
         <entry>Error code</entry>
         <entry>Error value</entry>        
         <entry>Meaning</entry>        
         <entry>Solution</entry>        
        </row>
       </thead>
       <tbody>
        <row>
         <entry/>
         <entry><quote/></entry>
         <entry/>
         <entry/>
        </row>       
       </tbody>
      </tgroup>
     </table>
    </para>    
   </refsection>

   <refsection xml:id="core.ppm.pear-config.writeconfigfile.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>



</section>

 
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-dependency"><info><title>PEAR_Dependency</title></info>
 
 <para>This class is deprecated by
  <link linkend="core.ppm.pear-dependency2"><classname>PEAR_Dependency2</classname></link>
  in PEAR 1.4.0
 </para>
 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-dependency.pear-dependency">
   <refnamediv>
    <refname><function>PEAR_Dependency::PEAR_Dependency</function></refname>
    <refpurpose>constructor</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/Dependency.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>void       <function>PEAR_Dependency::PEAR_Dependency</function></funcdef>
      <paramdef choice="req">object <parameter>&amp;$registry</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-dependency.pear-dependency.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>
      Constructor
     </para>
    </refsection>
   <refsection xml:id="core.ppm.pear-dependency.pear-dependency.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">object</type>
         <parameter>&amp;$registry</parameter>
       </term>      
       <listitem>
        <para>
         a <link linkend="core.ppm.pear-registry">
          <classname>PEAR_Registry</classname></link> instance
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>

   <refsection xml:id="core.ppm.pear-dependency.pear-dependency.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-dependency.callcheckmethod">
   <refnamediv>
    <refname><function>PEAR_Dependency::callCheckMethod</function></refname>
    <refpurpose>Maps the xml dependency definition</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/Dependency.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>void       <function>PEAR_Dependency::callCheckMethod</function></funcdef>
      <paramdef choice="req">mixed <parameter>&amp;$errmsg</parameter></paramdef>
      <paramdef choice="req">array <parameter>$opts</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-dependency.callcheckmethod.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>
      This method maps the xml dependency definition 
      to the <classname>PEAR_Dependency</classname>
      one. 
     </para>
    </refsection>
   <refsection xml:id="core.ppm.pear-dependency.callcheckmethod.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">mixed</type>
         <parameter>&amp;$errmsg</parameter>
       </term>      
       <listitem>
        <para>
         this variable will contains an error message, if
         check fail
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">array</type>
         <parameter>$opts</parameter>
       </term>      
       <listitem>
        <para>
         An Array with all Dependency entries from the
         parsed XML package definition, ie:
         <programlisting role="php">
          <![CDATA[
$opts => Array
   (
       ['type'] => 'pkg',
       ['rel'] => 'ge',
       ['version'] => '3.4',
       ['name'] => 'HTML_Common'
    );
          ]]>
         </programlisting>
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>

   <refsection xml:id="core.ppm.pear-dependency.callcheckmethod.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>
    <para>
     <parameter>mixed</parameter> - 
     <constant xmlns="http://docbook.org/ns/docbook">FALSE</constant> if all dependencies could be resolved
     <emphasis>successfully(!)</emphasis>; or an
     <constant>PEAR_DEPENDENCY_*</constant> constant
     in case of unresolved dependencies.
    </para>
   </refsection>
   
   <refsection xml:id="core.ppm.pear-dependency.callcheckmethod.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-dependency.checkextension">
   <refnamediv>
    <refname><function>PEAR_Dependency::checkExtension</function></refname>
    <refpurpose>Check Extension dependency</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/Dependency.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>mixed       <function>PEAR_Dependency::checkExtension</function></funcdef>
      <paramdef choice="req">mixed <parameter>&amp;$errmsg</parameter></paramdef>
      <paramdef choice="req">string <parameter>$name</parameter></paramdef>
      <paramdef choice="opt">string <parameter>$req</parameter>
       <initializer>null</initializer>
      </paramdef>
      <paramdef choice="opt">string <parameter>$relation = 'has'</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-dependency.checkextension.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>Extension dependencies check method</para>
    </refsection>
   <refsection xml:id="core.ppm.pear-dependency.checkextension.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">mixed</type>
         <parameter>&amp;$errmsg</parameter>
       </term>      
       <listitem>
        <para>
         this variable will contains an error message, if
         check fail         
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$name</parameter>
       </term>      
       <listitem>
        <para>
         Name of the extension to test
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$req</parameter>
       </term>      
       <listitem>
        <para>
         Required extension version to compare with             
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$relation</parameter>
       </term>      
       <listitem>
        <para>
         How to compare versions with eachother
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-dependency.checkextension.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>
    <para>
     <parameter>mixed</parameter> -
      <constant xmlns="http://docbook.org/ns/docbook">FALSE</constant> if dependency could be resolved
      <emphasis>successfully(!)</emphasis>; or an
      <constant>PEAR_DEPENDENCY_*</constant> constant
      in case of an unresolved dependency.     
    </para>
   </refsection>

   <refsection xml:id="core.ppm.pear-dependency.checkextension.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-dependency.checkos">
   <refnamediv>
    <refname><function>PEAR_Dependency::checkOS</function></refname>
    <refpurpose>Check Operating system dependency</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/Dependency.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>mixed       <function>PEAR_Dependency::checkOS</function></funcdef>
      <paramdef choice="req">string <parameter>&amp;$errmsg</parameter></paramdef>
      <paramdef choice="req">string <parameter>$os</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-dependency.checkos.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>Operating system  dependencies check method</para>
    </refsection>
   <refsection xml:id="core.ppm.pear-dependency.checkos.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>&amp;$errmsg</parameter>
       </term>      
       <listitem>
        <para>
         this variable will contains an error message, if
         check fail         
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$os</parameter>
       </term>      
       <listitem>
        <para>
         Name of the operating system
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-dependency.checkos.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>
    <para>
   <parameter>mixed</parameter> - 
     <constant xmlns="http://docbook.org/ns/docbook">FALSE</constant> if dependency could be resolved
     <emphasis>successfully(!)</emphasis>; or an
     <constant>PEAR_DEPENDENCY_*</constant> constant
     in case of unresolved dependency.
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-dependency.checkos.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-dependency.checkpackage">
   <refnamediv>
    <refname><function>PEAR_Dependency::checkPackage</function></refname>
    <refpurpose>check Package dependency</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/Dependency.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>mixed       <function>PEAR_Dependency::checkPackage</function></funcdef>
      <paramdef choice="req">mixed <parameter>&amp;$errmsg</parameter></paramdef>
      <paramdef choice="req">string <parameter>$name</parameter></paramdef>
      <paramdef choice="opt">string <parameter>$req</parameter>
       <initializer>null</initializer>
      </paramdef>
      <paramdef choice="opt">string <parameter>$relation = 'has'</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-dependency.checkpackage.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>Package dependencies check method</para>
    </refsection>
   <refsection xml:id="core.ppm.pear-dependency.checkpackage.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>&amp;$errmsg</parameter>
       </term>      
       <listitem>
        <para>
         this variable will contains an error message, if
         check fail           
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$name</parameter>
       </term>      
       <listitem>
        <para>
         Name of the package to test
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$req</parameter>
       </term>      
       <listitem>
        <para>
         Required package version to compare with        
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$relation</parameter>
       </term>      
       <listitem>
        <para>
         How to compare versions with eachother
        </para>
       </listitem>
      </varlistentry>

     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-dependency.checkpackage.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>

    <para>
   <parameter>mixed</parameter> - 
     <constant xmlns="http://docbook.org/ns/docbook">FALSE</constant> if dependency could be resolved
     <emphasis>successfully(!)</emphasis>; or an
     <constant>PEAR_DEPENDENCY_*</constant> constant
     in case of unresolved dependency.
    </para>
   </refsection>

   <refsection xml:id="core.ppm.pear-dependency.checkpackage.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-dependency.checkphp">
   <refnamediv>
    <refname><function>PEAR_Dependency::checkPHP</function></refname>
    <refpurpose>Check PHP version</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/Dependency.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>mixed       <function>PEAR_Dependency::checkPHP</function></funcdef>
      <paramdef choice="req">mixed <parameter>&amp;$errmsg</parameter></paramdef>
      <paramdef choice="req">string <parameter>$req</parameter></paramdef>
      <paramdef choice="opt">string <parameter>$relation = 'ge'</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-dependency.checkphp.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>PHP version check method</para>
    </refsection>
   <refsection xml:id="core.ppm.pear-dependency.checkphp.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">mixed</type>
         <parameter>&amp;$errmsg</parameter>
       </term>      
       <listitem>
        <para>
         this variable will contains an error message, if
         check fail            
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$req</parameter>
       </term>      
       <listitem>
        <para>
         which version to compare
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$relation</parameter>
       </term>      
       <listitem>
        <para>
         how to compare the version
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-dependency.checkphp.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>
    <para>
   <parameter>mixed</parameter> - 
     <constant xmlns="http://docbook.org/ns/docbook">FALSE</constant> if dependency could be resolved
     <emphasis>successfully(!)</emphasis>; or an
     <constant>PEAR_DEPENDENCY_*</constant> constant
     in case of unresolved dependency.
 
  
    </para>
   </refsection>

   <refsection xml:id="core.ppm.pear-dependency.checkphp.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-dependency.checkprogram">
   <refnamediv>
    <refname><function>PEAR_Dependency::checkProgram</function></refname>
    <refpurpose>Check external program</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/Dependency.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>mixed       <function>PEAR_Dependency::checkProgram</function></funcdef>
      <paramdef choice="req">mixed <parameter>&amp;$errmsg</parameter></paramdef>
      <paramdef choice="req">string <parameter>$program</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-dependency.checkprogram.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>
      External program check method.
      Looks for executable files in directories 
      listed in the PATH environment variable.
     </para>
    </refsection>
   <refsection xml:id="core.ppm.pear-dependency.checkprogram.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">mixed</type>
         <parameter>&amp;$errmsg</parameter>
       </term>      
       <listitem>
        <para>
         this variable will contains an error message, if
         check fail            
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$program</parameter>
       </term>      
       <listitem>
        <para>
         which program to look for
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-dependency.checkprogram.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>
   
    <para>
   <parameter>mixed</parameter> - 
     <constant xmlns="http://docbook.org/ns/docbook">FALSE</constant> if dependency could be resolved
     <emphasis>successfully(!)</emphasis>; or an
     <constant>PEAR_DEPENDENCY_*</constant> constant
     in case of unresolved dependency.

    </para>
   </refsection>

   <refsection xml:id="core.ppm.pear-dependency.checkprogram.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-dependency.checksapi">
   <refnamediv>
    <refname><function>PEAR_Dependency::checkSAPI</function></refname>
    <refpurpose>Check SAPI backend</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/Dependency.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>mixed       <function>PEAR_Dependency::checkSAPI</function></funcdef>
      <paramdef choice="req">mixed <parameter>&amp;$errmsg</parameter></paramdef>
      <paramdef choice="req">string <parameter>$name</parameter></paramdef>
      <paramdef choice="opt">string <parameter>$req</parameter>
       <initializer>null</initializer>
      </paramdef>
      <paramdef choice="opt">string <parameter>$relation = 'has'</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-dependency.checksapi.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>
      SAPI backend check method. 
      Version comparison is not yet available here.
     </para>
    </refsection>
   <refsection xml:id="core.ppm.pear-dependency.checksapi.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">mixed</type>
         <parameter>&amp;$errmsg</parameter>
       </term>      
       <listitem>
        <para>
         this variable will contains an error message, if
         check fail          
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$name</parameter>
       </term>      
       <listitem>
        <para>
         name of SAPI backend
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$req</parameter>
       </term>      
       <listitem>
        <para>
         which version to compare (currently unused)
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$relation</parameter>
       </term>      
       <listitem>
        <para>
         how to compare versions (currently
         hardcoded to 'has')
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-dependency.checksapi.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>

    <para>
   <parameter>mixed</parameter> - 
     <constant xmlns="http://docbook.org/ns/docbook">FALSE</constant> if dependency could be resolved
     <emphasis>successfully(!)</emphasis>; or an
     <constant>PEAR_DEPENDENCY_*</constant> constant
     in case of unresolved dependency.

    </para>
   </refsection>

   <refsection xml:id="core.ppm.pear-dependency.checksapi.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-dependency.checkzend">
   <refnamediv>
    <refname><function>PEAR_Dependency::checkZend</function></refname>
    <refpurpose>Check Zend version</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/Dependency.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>mixed       <function>PEAR_Dependency::checkZend</function></funcdef>
      <paramdef choice="req">mixed <parameter>&amp;$errmsg</parameter></paramdef>
      <paramdef choice="req">string <parameter>$req</parameter></paramdef>
      <paramdef choice="opt">string <parameter> ''}$relation = 'ge'</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-dependency.checkzend.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>Zend version check method</para>
    </refsection>
   <refsection xml:id="core.ppm.pear-dependency.checkzend.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">mixed</type>
         <parameter>&amp;$errmsg</parameter>
       </term>      
       <listitem>
        <para>
         this variable will contains an error message, if
         check fail           
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$req</parameter>
       </term>      
       <listitem>
        <para>
         which version to compare
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$relation</parameter>
       </term>      
       <listitem>
        <para>
         how to compare the version
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-dependency.checkzend.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>
    
    <para>
   <parameter>mixed</parameter> - 
     <constant xmlns="http://docbook.org/ns/docbook">FALSE</constant> if dependency could be resolved
     <emphasis>successfully(!)</emphasis>; or an
     <constant>PEAR_DEPENDENCY_*</constant> constant
     in case of unresolved dependency.

    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-dependency.checkzend.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>

</section>

 
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-dependency2"><info><title>PEAR_Dependency2</title></info>
 
 <refentry xml:id="core.ppm.pear-dependency2-summary">
  <refnamediv>
   <refname>
    Class Summary
    <classname>PEAR_Dependency2</classname>
   </refname>
   <refpurpose>Dependency check for PEAR packages</refpurpose>
  </refnamediv>
  <refsection><info><title>Dependency check for PEAR packages</title></info>
   
   <para>
    This class handles both version 1.0 and 2.0 
    dependencies and supersedes
    PEAR_Dependency since PEAR 1.4.0
   </para>
  </refsection>
  <refsection><info><title>
    Class Trees for
    <classname>PEAR_Dependency2</classname>
   </title></info>
   
   <para>
    <itemizedlist>
     <listitem>
      <para>PEAR_Dependency2</para>
     </listitem>
    </itemizedlist>
   </para>
  </refsection>
 </refentry>
 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-dependency2.pear-dependency2">
 <refnamediv>
  <refname>
   constructor
   <function>PEAR_Dependency2::PEAR_Dependency2</function>
  </refname>
  <refpurpose>PEAR_Dependency2</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/Dependency2.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     void constructor
     <function>PEAR_Dependency2::PEAR_Dependency2</function>
    </funcdef>
    <paramdef choice="req">
     PEAR_Config
     <parameter>&amp;$config</parameter>
    </paramdef>
    <paramdef choice="req">
     array
     <parameter>$installoptions</parameter>
    </paramdef>
    <paramdef choice="req">
     array
     <parameter>$package</parameter>
    </paramdef>
    <paramdef choice="opt">
     int
     <parameter>
      $state = PEAR_VALIDATE_INSTALLING
     </parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-dependency2.pear-dependency2.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para xmlns="http://docbook.org/ns/docbook">This package is not documented yet.</para>
</refsection>
 <refsection xml:id="core.ppm.pear-dependency2.pear-dependency2.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type>PEAR_Config</type>
      <parameter>&amp;$config</parameter>
     </term>
     <listitem>
      <para>
       Current configuration object.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">array</type>
      <parameter>$installoptions</parameter>
     </term>
     <listitem>
      <para>installation options</para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">array</type>
      <parameter>$package</parameter>
     </term>
     <listitem>
      <para>
       The current package.  For installation dependencies, this is the package
       that contains dependencies.  For uninstallation dependencies, this is the package
       that is going to be uninstalled.
      </para>
      <para>
       format of <function>PEAR_Registry::parsedPackageName</function>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">integer</type>
      <parameter>$state</parameter>
     </term>
     <listitem>
      <para>installation state (one of PEAR_VALIDATE_*)</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-dependency2.pear-dependency2.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-dependency2.pear-dependency2.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-dependency2.normalizedep">
 <refnamediv>
  <refname>
   <function>PEAR_Dependency2::normalizeDep</function>
  </refname>
  <refpurpose>Convert a 1.0 dep into a 2.0 dep</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/Dependency2.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     array
     <function>PEAR_Dependency2::normalizeDep</function>
    </funcdef>
    <paramdef choice="req">
     array
     <parameter>$dep</parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-dependency2.normalizedep.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   This converts an old-style package.xml 1.0 &lt;dep&gt; tag into the format used
   by package.xml 2.0.  package.xml 2.0 can represent every kind of &lt;dep&gt; tag
   in its new syntax.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-dependency2.normalizedep.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">array</type>
      <parameter>$dep</parameter>
     </term>
     <listitem>
      <para>
       The package.xml 1.0 &lt;dep&gt; as parsed from xml.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-dependency2.normalizedep.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-dependency2.normalizedep.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-dependency2.validatearchdependency">
 <refnamediv>
  <refname>
   <function>PEAR_Dependency2::validateArchDependency</function>
  </refname>
  <refpurpose>
   Specify a complex dependency on an OS/processor/kernel version,  Use OS for
   simple operating system dependency.
</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/Dependency2.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     true|PEAR_Error|array
     <function>PEAR_Dependency2::validateArchDependency</function>
    </funcdef>
    <paramdef choice="req">
     array
     <parameter>$dep</parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-dependency2.validatearchdependency.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   This is the only dependency that accepts an <function>ereg</function>able pattern.  The pattern 
   will be matched against the <function>php_uname</function> output parsed by <classname>OS_Guess</classname>
   As with all dependency validation, true is returned on success, PEAR_Error on failure
   for required dependencies (and the arch dependency is required).  If the
   <literal>soft</literal>, <literal>force</literal> or <literal>ignore-errors</literal>
   options are specified, an array containing the error message will be returned instead.
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-dependency2.validatearchdependency.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">array</type>
      <parameter>$dep</parameter>
     </term>
     <listitem>
      <para>
       Contents of the dependency, as parsed from xml.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-dependency2.validatearchdependency.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-dependency2.validatearchdependency.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-dependency2.validatedependency1">
 <refnamediv>
  <refname>
   <function>PEAR_Dependency2::validateDependency1</function>
  </refname>
  <refpurpose>validate a package.xml 1.0 dependency</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/Dependency2.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     true|PEAR_Error|array
     <function>PEAR_Dependency2::validateDependency1</function>
    </funcdef>
    <paramdef choice="req">
     array
     <parameter>$dep</parameter>
    </paramdef>
    <paramdef choice="opt">
     array
     <parameter>
      $params = array()
     </parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-dependency2.validatedependency1.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Validate a package.xml version 1.0 &lt;dep&gt; dependency.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-dependency2.validatedependency1.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">array</type>
      <parameter>$dep</parameter>
     </term>
     <listitem>
      <para>
       The contents of the &lt;dep&gt; tag as parsed from xml
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">array</type>
      <parameter>$params</parameter>
     </term>
     <listitem>
      <para>
       The list of PEAR_Downloader_Package objects that will be installed.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-dependency2.validatedependency1.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-dependency2.validatedependency1.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-dependency2.validateextensiondependency">
 <refnamediv>
  <refname>
   <function>PEAR_Dependency2::validateExtensionDependency</function>
  </refname>
  <refpurpose>validate a dependency on a PHP extension</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/Dependency2.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     true|PEAR_Error|array
     <function>PEAR_Dependency2::validateExtensionDependency</function>
    </funcdef>
    <paramdef choice="req">
     array
     <parameter>$dep</parameter>
    </paramdef>
    <paramdef choice="opt">
     bool
     <parameter>
      $required = true
     </parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-dependency2.validateextensiondependency.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   This validates against actual in-memory extensions, and will not attempt to locate
   extensions on disk.  To do this, a dependency should be a package dependency with
   the &lt;providesextension&gt; tag.
  </para>
  <para>
   As with all dependency validation, true is returned on success, PEAR_Error on failure
   for required dependencies.  If the <literal>soft</literal>, <literal>force</literal>
   or <literal>ignore-errors</literal> options are specified, an array containing the
   error message will be returned instead.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-dependency2.validateextensiondependency.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">array</type>
      <parameter>$dep</parameter>
     </term>
     <listitem>
      <para>
       dependency contents as parsed from xml
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">boolean</type>
      <parameter>$required</parameter>
     </term>
     <listitem>
      <para>
       Whether this is a required or optional dependency
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-dependency2.validateextensiondependency.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-dependency2.validateextensiondependency.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-dependency2.validateosdependency">
 <refnamediv>
  <refname>
   <function>PEAR_Dependency2::validateOsDependency</function>
  </refname>
  <refpurpose>
   Specify a dependency on an OS.  Use arch for detailed os/processor
   information
</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/Dependency2.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     true|PEAR_Error|array
     <function>PEAR_Dependency2::validateOsDependency</function>
    </funcdef>
    <paramdef choice="req">
     array
     <parameter>$dep</parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-dependency2.validateosdependency.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>There are two generic OS dependencies that will be the most common, unix and windows.
   Other options are linux, freebsd, darwin (OS X), sunos, irix, hpux, aix.
   As with all dependency validation, true is returned on success, PEAR_Error on failure
   for required dependencies (and the OS dependency is required).  If the
   <literal>soft</literal>, <literal>force</literal> or <literal>ignore-errors</literal>
   options are specified, an array containing the error message will be returned instead.
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-dependency2.validateosdependency.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">array</type>
      <parameter>$dep</parameter>
     </term>
     <listitem>
      <para>
       Dependency contents as parsed from xml
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-dependency2.validateosdependency.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-dependency2.validateosdependency.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-dependency2.validatepackage">
 <refnamediv>
  <refname>
   <function>PEAR_Dependency2::validatePackage</function>
  </refname>
  <refpurpose>validatePackage</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/Dependency2.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     true|PEAR_Error|array
     <function>PEAR_Dependency2::validatePackage</function>
    </funcdef>
    <paramdef choice="req">
     array|PEAR_PackageFile_v2|PEAR_Downloader_Package
     <parameter>$pkg</parameter>
    </paramdef>
    <paramdef choice="req">
     PEAR_Common
     <parameter>&amp;$dl</parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-dependency2.validatepackage.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   As with all dependency validation, true is returned on success, PEAR_Error on failure
   for required dependencies (and the PEAR installer dependency is required).  If the
   <literal>soft</literal>, <literal>force</literal> or <literal>ignore-errors</literal>
   options are specified, an array containing the error message will be returned instead.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-dependency2.validatepackage.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">array</type>|PEAR_PackageFile_v2|PEAR_Downloader_Package
      <parameter>$pkg</parameter>
     </term>
     <listitem>
      <para>
       Either an array of format <literal>array('channel' =&gt; channelname, 'package' =&gt; package)</literal>
       or one of these objects.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      PEAR_Common
      <parameter>&amp;$dl</parameter>
     </term>
     <listitem>
      <para>
       Any object with a <function>log</function> method that matches the signature of
       <classname>PEAR_Common</classname>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-dependency2.validatepackage.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-dependency2.validatepackage.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-dependency2.validatepackagedependency">
 <refnamediv>
  <refname>
   <function>PEAR_Dependency2::validatePackageDependency</function>
  </refname>
  <refpurpose>validatePackageDependency</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/Dependency2.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     array|true|PEAR_Error
     <function>PEAR_Dependency2::validatePackageDependency</function>
    </funcdef>
    <paramdef choice="req">
     array
     <parameter>$dep</parameter>
    </paramdef>
    <paramdef choice="req">
     boolean
     <parameter>$required</parameter>
    </paramdef>
    <paramdef choice="req">
     array
     <parameter>$params</parameter>
    </paramdef>
    <paramdef choice="opt">
     bool
     <parameter>$depv1</parameter>
     <initializer>false</initializer>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-dependency2.validatepackagedependency.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Validate a package-style dependency.  Validation is performed in this sequence:
  </para>
  <para>
   <orderedlist>
    <listitem>
     <para>
      If the dependency package provides an extension through the &lt;providesextension&gt;
      tag, then see if it passes the extension validation test first and return if so.
     </para>
    </listitem>
    <listitem>
     <para>
      If the list of packages to be installed contains a match for the dependency, use that
      to validate the dependency and return.
     </para>
    </listitem>
    <listitem>
     <para>
      If the dependency package is already installed, make sure the installed version
      passes the conditions.
     </para>
    </listitem>
    <listitem>
     <para>
      At this point, the dependency has failed.  If the dependency is required,
      return a PEAR_Error containing the failure error message, otherwise return
      an array containing the error message.
     </para>
    </listitem>
   </orderedlist>
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-dependency2.validatepackagedependency.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">array</type>
      <parameter>$dep</parameter>
     </term>
     <listitem>
      <para>
       dependency array as defined by package.xml 2.0
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">boolean</type>
      <parameter>$required</parameter>
     </term>
     <listitem>
      <para>
       whether this is a required or optional dependency
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">array</type>
      <parameter>$params</parameter>
     </term>
     <listitem>
      <para>
       array of PEAR_Downloader_Package objects representing packages to be
       downloaded that can be used to validate dependencies
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">boolean</type>
      <parameter>$depv1</parameter>
     </term>
     <listitem>
      <para>
       if <constant xmlns="http://docbook.org/ns/docbook">TRUE</constant>, then deps on pear.php.net that fail will also check
       against pecl.php.net packages to accommodate extensions that have
       moved to pecl.php.net from pear.php.net
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-dependency2.validatepackagedependency.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-dependency2.validatepackagedependency.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-dependency2.validatepackageuninstall">
 <refnamediv>
  <refname>
   <function>PEAR_Dependency2::validatePackageUninstall</function>
  </refname>
  <refpurpose>validatePackageUninstall</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/Dependency2.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     true|PEAR_Error|array
     <function>PEAR_Dependency2::validatePackageUninstall</function>
    </funcdef>
    <paramdef choice="req">
     PEAR_Installer
     <parameter>&amp;$dl</parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-dependency2.validatepackageuninstall.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   As with all dependency validation, true is returned on success, PEAR_Error on failure
   for required dependencies (and the PEAR installer dependency is required).  If the
   <literal>soft</literal>, <literal>force</literal> or <literal>ignore-errors</literal>
   options are specified, an array containing the error message will be returned instead.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-dependency2.validatepackageuninstall.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      PEAR_Installer
      <parameter>&amp;$dl</parameter>
     </term>
     <listitem>
      <para>
       This method retrieves the list of packages to be uninstalled from the
       PEAR_Installer object, and makes sure no dependencies with existing packages
       would be broken if the current package were to be uninstalled.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-dependency2.validatepackageuninstall.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-dependency2.validatepackageuninstall.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-dependency2.validatepearinstallerdependency">
 <refnamediv>
  <refname>
   <function>PEAR_Dependency2::validatePearinstallerDependency</function>
  </refname>
  <refpurpose>validatePearinstallerDependency</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/Dependency2.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     true|PEAR_Error|array
     <function>PEAR_Dependency2::validatePearinstallerDependency</function>
    </funcdef>
    <paramdef choice="req">
     array
     <parameter>$dep</parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-dependency2.validatepearinstallerdependency.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Validate the running PEAR version against the dependency.  This dependency is designed
   to prevent PEAR versions incompatible with the current package.xml from attempting to install
   it.  As with all dependency validation, true is returned on success, PEAR_Error on failure
   for required dependencies (and the PEAR installer dependency is required).  If the
   <literal>soft</literal>, <literal>force</literal> or <literal>ignore-errors</literal>
   options are specified, an array containing the error message will be returned instead.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-dependency2.validatepearinstallerdependency.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">mixed</type>
      <parameter>$dep</parameter>
     </term>
     <listitem>
      <para/>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-dependency2.validatepearinstallerdependency.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-dependency2.validatepearinstallerdependency.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-dependency2.validatephpdependency">
 <refnamediv>
  <refname>
   <function>PEAR_Dependency2::validatePhpDependency</function>
  </refname>
  <refpurpose>validatePhpDependency</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/Dependency2.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     true|PEAR_Error|array
     <function>PEAR_Dependency2::validatePhpDependency</function>
    </funcdef>
    <paramdef choice="req">
     array
     <parameter>$dep</parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-dependency2.validatephpdependency.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Validate the running PHP version against the dependency.  The implicit assumption
   is that the installer's PHP version is the same as the final script's PHP version.
   As with all dependency validation, true is returned on success, PEAR_Error on failure
   for required dependencies (and the PHP dependency is required).  If the
   <literal>soft</literal>, <literal>force</literal> or <literal>ignore-errors</literal>
   options are specified, an array containing the error message will be returned instead.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-dependency2.validatephpdependency.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">array</type>
      <parameter>$dep</parameter>
     </term>
     <listitem>
      <para>
       The dependency xml as represented in parsing
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-dependency2.validatephpdependency.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-dependency2.validatephpdependency.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-dependency2.validatesubpackagedependency">
 <refnamediv>
  <refname>
   <function>PEAR_Dependency2::validateSubpackageDependency</function>
  </refname>
  <refpurpose>validateSubpackageDependency</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/Dependency2.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     array|true|PEAR_Error
     <function>PEAR_Dependency2::validateSubpackageDependency</function>
    </funcdef>
    <paramdef choice="req">
     array
     <parameter>$dep</parameter>
    </paramdef>
    <paramdef choice="req">
     bool
     <parameter>$required</parameter>
    </paramdef>
    <paramdef choice="req">
     array
     <parameter>$params</parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-dependency2.validatesubpackagedependency.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Validate a subpackage-style dependency.  This is identical to a package dependency
   from a validation perspective, and so documentation for
   <link linkend="core.ppm.pear-dependency2.validatepackagedependency"><function>validatePackageDependency</function></link> should be referenced for details.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-dependency2.validatesubpackagedependency.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">array</type>
      <parameter>$dep</parameter>
     </term>
     <listitem>
      <para>
       dependency array as defined by package.xml 2.0
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">boolean</type>
      <parameter>$required</parameter>
     </term>
     <listitem>
      <para>
       whether this is a required or optional dependency
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">array</type>
      <parameter>$params</parameter>
     </term>
     <listitem>
      <para>
       array of PEAR_Downloader_Package objects representing packages to be
       downloaded that can be used to validate dependencies
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-dependency2.validatesubpackagedependency.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-dependency2.validatesubpackagedependency.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

</section>

 
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-dependencydb"><info><title>PEAR_DependencyDB</title></info>
 
 <refentry xml:id="core.ppm.pear-dependencydb-summary">
  <refnamediv>
   <refname>
    Class Summary
    <classname>PEAR_DependencyDB</classname>
   </refname>
   <refpurpose>Track dependency relationships between installed packages</refpurpose>
  </refnamediv>
  <refsection><info><title>Track dependency relationships between installed packages</title></info>
   
   <para>
    This provides sophisticated dependency handling relationships between
    installed packages and downloaded to-be-installed packages.
   </para>
  </refsection>
  <refsection><info><title>
    Class Trees for
    <classname>PEAR_DependencyDB</classname>
   </title></info>
   
   <para>
    <itemizedlist>
     <listitem>
      <para>PEAR_DependencyDB</para>
     </listitem>
    </itemizedlist>
   </para>
  </refsection>
 </refentry>
 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-dependencydb.assertdepsdb">
 <refnamediv>
  <refname>
   <function>PEAR_DependencyDB::assertDepsDB</function>
  </refname>
  <refpurpose>
   Create the dependency database, if it doesn't exist.  Error if the
   database is  newer than the code reading it.
</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/DependencyDB.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     void|PEAR_Error
     <function>PEAR_DependencyDB::assertDepsDB</function>
    </funcdef>
    <paramdef choice="req"/>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-dependencydb.assertdepsdb.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Assert that the dependency database exists, and attempt to create it
   if it doesn't.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-dependencydb.assertdepsdb.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-dependencydb.assertdepsdb.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-dependencydb.dependson">
 <refnamediv>
  <refname>
   <function>PEAR_DependencyDB::dependsOn</function>
  </refname>
  <refpurpose>Determine whether $parent depends on $child, near or deep</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/DependencyDB.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     void
     <function>PEAR_DependencyDB::dependsOn</function>
    </funcdef>
    <paramdef choice="req">
     array|PEAR_PackageFile_v2|PEAR_PackageFile_v2
     <parameter>$parent</parameter>
    </paramdef>
    <paramdef choice="req">
     array|PEAR_PackageFile_v2|PEAR_PackageFile_v2
     <parameter>$child</parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-dependencydb.dependson.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   This method is the central method of DependencyDB.  Through the dependency
   database, it is possible to determine whether any two packages share a dependency
   relationship independent of how tightly bound the two packages are.  In other words,
   if package A depends on package B depends on package C, this method can be used to
   determine that package A indirectly depends on package C.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-dependencydb.dependson.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type>array|PEAR_PackageFile_v2|PEAR_PackageFile_v2</type>
      <parameter>$parent</parameter>
     </term>
     <listitem>
      <para>
       The parent package (as in package A in the example above)
      </para>
      <para>
       This parameter, if an array, should be in format:
      </para>
      <para>
       <programlisting>
        <![CDATA[
<?php
array(
  'package' => 'packagename',
  'channel' => 'channelname'
);
?>
        ]]>
       </programlisting>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type>array|PEAR_PackageFile_v2|PEAR_PackageFile_v2</type>
      <parameter>$child</parameter>
     </term>
     <listitem>
      <para>
       The child package (as in package B or package C in the example above)
      </para>
      <para>
       This parameter, if an array, should be in format:
      </para>
      <para>
       <programlisting>
        <![CDATA[
<?php
array(
  'package' => 'packagename',
  'channel' => 'channelname'
);
?>
        ]]>
       </programlisting>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-dependencydb.dependson.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-dependencydb.dependson.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-dependencydb.getdependencies">
 <refnamediv>
  <refname>
   <function>PEAR_DependencyDB::getDependencies</function>
  </refname>
  <refpurpose>Get a list of dependencies of this installed package</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/DependencyDB.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     <replaceable>array|false</replaceable>
     <function>PEAR_DependencyDB::getDependencies</function>
    </funcdef>
    <paramdef choice="req">
     PEAR_PackageFile_v1|PEAR_PackageFile_v2|array
     <parameter>&amp;$pkg</parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-dependencydb.getdependencies.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   get an array of all immediate package dependencies of an installed package.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-dependencydb.getdependencies.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type>PEAR_PackageFile_v1|PEAR_PackageFile_v2|array</type>
      <parameter>&amp;$pkg</parameter>
     </term>
     <listitem>
      <para>
       This parameter, if an array, should be in format:
      </para>
      <para>
       <programlisting>
        <![CDATA[
<?php
array(
  'package' => 'packagename',
  'channel' => 'channelname'
);
?>
        ]]>
       </programlisting>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-dependencydb.getdependencies.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-dependencydb.getdependencies.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-dependencydb.getdependentpackagedependencies">
 <refnamediv>
  <refname>
   <function>PEAR_DependencyDB::getDependentPackageDependencies</function>
  </refname>
  <refpurpose>
   Get a list of the actual dependencies of installed packages that depend on
   a package.
</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/DependencyDB.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     <replaceable>array|false</replaceable>
     <function>PEAR_DependencyDB::getDependentPackageDependencies</function>
    </funcdef>
    <paramdef choice="req">
     PEAR_PackageFile_v1|PEAR_PackageFile_v2|array
     <parameter>&amp;$pkg</parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-dependencydb.getdependentpackagedependencies.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   This returns the complete tree of extended dependencies of a single installed package.
  </para>
  <para>
   For instance, a real-world example.  package SOAP depends on Mail_Mime, HTTP_Request, Net_URL, Net_DIME.  package HTTP_Request depends on Net_URL, Net_Socket.  This method will return an array
   similar to:
  </para>
  <para>
   <programlisting>
    <![CDATA[
<?php
array(
    'pear.php.net' =>
        array(
            'mail_mime' =>
                array('name' => 'Mail_Mime',
                      'channel' => 'pear.php.net'),
            'http_request' =>
                array('name' => 'HTTP_Request',
                      'channel' => 'pear.php.net'),
            'net_url' =>
                array('name' => 'Net_URL',
                      'channel' => 'pear.php.net',
                      'min' => '1.0.12'),
            'net_dime' =>
                array('name' => 'Net_DIME',
                      'channel' => 'pear.php.net'),
            'net_socket' =>
                array('name' => 'Net_Socket',
                      'channel' => 'pear.php.net'),
        ),
);
?>
    ]]>
   </programlisting>
  </para>
  <para>
   Note that this should not be relied upon for exact dependencies.  In the example above, the
   returned dependency will be that of HTTP_Request upon Net_URL, which is stricter than SOAP's
   dependency upon Net_URL.  In other words, if there are two similar dependencies, the last
   one encountered will be returned.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-dependencydb.getdependentpackagedependencies.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type>PEAR_PackageFile_v1|PEAR_PackageFile_v2|array</type>
      <parameter>&amp;$pkg</parameter>
     </term>
     <listitem>
      <para>
       This parameter, if an array, should be in format:
      </para>
      <para>
       <programlisting>
        <![CDATA[
<?php
array(
  'package' => 'packagename',
  'channel' => 'channelname'
);
?>
        ]]>
       </programlisting>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-dependencydb.getdependentpackagedependencies.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-dependencydb.getdependentpackagedependencies.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="package.pear.pear.pear-dependencydb.getdependentpackages">
 <refnamediv>
  <refname>
   <function>PEAR_DependencyDB::getDependentPackages</function>
  </refname>
  <refpurpose>Get a list of installed packages that depend on this package</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/DependencyDB.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     <replaceable>array|false</replaceable>
     <function>PEAR_DependencyDB::getDependentPackages</function>
    </funcdef>
    <paramdef choice="req">
     PEAR_PackageFile_v1|PEAR_PackageFile_v2|array
     <parameter>&amp;$pkg</parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="package.pear.pear.pear-dependencydb.getdependentpackages.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   This is most useful at uninstall-time.  A list of installed packages that depend
   upon the package can be used to prevent uninstallation, and to emit warnings
   for optional dependencies.
  </para>
</refsection>
 <refsection xml:id="package.pear.pear.pear-dependencydb.getdependentpackages.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type>PEAR_PackageFile_v1|PEAR_PackageFile_v2|array</type>
      <parameter>&amp;$pkg</parameter>
     </term>
     <listitem>
      <para>
       This parameter, if an array, should be in format:
      </para>
      <para>
       <programlisting>
        <![CDATA[
<?php
array(
  'package' => 'packagename',
  'channel' => 'channelname'
);
?>
        ]]>
       </programlisting>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="package.pear.pear.pear-dependencydb.getdependentpackages.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="package.pear.pear.pear-dependencydb.getdependentpackages.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-dependencydb.haswriteaccess">
 <refnamediv>
  <refname>
   <function>PEAR_DependencyDB::hasWriteAccess</function>
  </refname>
  <refpurpose>determines whether a dependency DB can be modified</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/DependencyDB.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     bool
     <function>PEAR_DependencyDB::hasWriteAccess</function>
    </funcdef>
    <paramdef choice="req"/>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-dependencydb.haswriteaccess.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   This method is used by the installer to prevent attempts to create/modify the
   dependency DB if the current user does not have write access to the registry.
   Without this method, simple read-only commands like <literal>pear info</literal>
   would not work.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-dependencydb.haswriteaccess.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-dependencydb.haswriteaccess.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-dependencydb.installpackage">
 <refnamediv>
  <refname>
   <function>PEAR_DependencyDB::installPackage</function>
  </refname>
  <refpurpose>Register dependencies of a package that is being installed or upgraded</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/DependencyDB.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     void
     <function>PEAR_DependencyDB::installPackage</function>
    </funcdef>
    <paramdef choice="req">
     PEAR_PackageFile_v2|PEAR_PackageFile_v2
     <parameter>&amp;$package</parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-dependencydb.installpackage.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   This method is used by the registry when a package is installed or upgraded to
   register the package's dependencies in the dependency database.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-dependencydb.installpackage.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type>PEAR_PackageFile_v2|PEAR_PackageFile_v2</type>
      <parameter>&amp;$package</parameter>
     </term>
     <listitem>
      <para>
       This parameter, if an array, should be in format:
      </para>
      <para>
       <programlisting>
        <![CDATA[
<?php
array(
  'package' => 'packagename',
  'channel' => 'channelname'
);
?>
        ]]>
       </programlisting>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-dependencydb.installpackage.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-dependencydb.installpackage.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-dependencydb.rebuilddb">
 <refnamediv>
  <refname>
   <function>PEAR_DependencyDB::rebuildDB</function>
  </refname>
  <refpurpose>Rebuild the dependency DB by reading registry entries.</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/DependencyDB.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     <replaceable>true|PEAR_Error</replaceable>
     <function>PEAR_DependencyDB::rebuildDB</function>
    </funcdef>
    <paramdef choice="req"/>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-dependencydb.rebuilddb.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   This is used to create or re-create the dependency database by reading
   registry entries for each installed file to extract dependencies and save
   them in the dependency database.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-dependencydb.rebuilddb.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-dependencydb.rebuilddb.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-dependencydb.setconfig">
 <refnamediv>
  <refname>
   <function>PEAR_DependencyDB::setConfig</function>
  </refname>
  <refpurpose>Set up the registry/location of dependency DB</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/DependencyDB.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     void
     <function>PEAR_DependencyDB::setConfig</function>
    </funcdef>
    <paramdef choice="req">
     PEAR_Config|false
     <parameter>&amp;$config</parameter>
    </paramdef>
    <paramdef choice="opt">
     string|false
     <parameter>$depdb</parameter>
     <initializer>false</initializer>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-dependencydb.setconfig.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   This crucial method is used to set the <classname>PEAR_Config</classname> object
   that should be used to retrieve both configuration information and a
   <classname>PEAR_Registry</classname> class for internal manipulation.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-dependencydb.setconfig.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <link linkend="core.ppm.pear-config"><classname>PEAR_Config</classname></link>|<constant xmlns="http://docbook.org/ns/docbook">FALSE</constant>
      <parameter>&amp;$config</parameter>
     </term>
     <listitem>
      <para/>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>|<constant xmlns="http://docbook.org/ns/docbook">FALSE</constant>
      <parameter>$depdb</parameter>
     </term>
     <listitem>
      <para>full path to the dependency database, or <constant xmlns="http://docbook.org/ns/docbook">FALSE</constant> to use default</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-dependencydb.setconfig.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-dependencydb.setconfig.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-dependencydb.singleton">
 <refnamediv>
  <refname>
   <function>PEAR_DependencyDB::singleton</function>
  </refname>
  <refpurpose>Get a raw dependency database.  Calls setConfig() and assertDepsDB()</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/DependencyDB.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     <replaceable>
      <link linkend="core.ppm.pear-dependencydb-summary">
       <classname>PEAR_DependencyDB</classname>
      </link>
      |PEAR_Error
     </replaceable>
     &amp;
     <function>PEAR_DependencyDB::singleton</function>
    </funcdef>
    <paramdef choice="req">
     PEAR_Config
     <parameter>&amp;$config</parameter>
    </paramdef>
    <paramdef choice="opt">
     string|false
     <parameter>$depdb</parameter>
     <initializer>false</initializer>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-dependencydb.singleton.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Return a single dependency database based on the location of the database on disk.
   In other words, 1 dependency database is created for each registry location.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-dependencydb.singleton.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <link linkend="core.ppm.pear-config"><classname>PEAR_Config</classname></link>
      <parameter>&amp;$config</parameter>
     </term>
     <listitem>
      <para>
       PEAR_Config object
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>|$false;
      <parameter>$depdb</parameter>
     </term>
     <listitem>
      <para>full path to the dependency database, or <constant xmlns="http://docbook.org/ns/docbook">FALSE</constant> to use default</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-dependencydb.singleton.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-dependencydb.singleton.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function should be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-dependencydb.uninstallpackage">
 <refnamediv>
  <refname>
   <function>PEAR_DependencyDB::uninstallPackage</function>
  </refname>
  <refpurpose>Remove dependencies of a package that is being uninstalled, or upgraded.</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/DependencyDB.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     void
     <function>PEAR_DependencyDB::uninstallPackage</function>
    </funcdef>
    <paramdef choice="req">
     PEAR_PackageFile_v1|PEAR_PackageFile_v2|array
     <parameter>&amp;$pkg</parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-dependencydb.uninstallpackage.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   This method is used by the registry when a package is uninstalled or upgraded to
   remove the package's dependencies from the dependency database.
  </para>
  <para>Upgraded packages first uninstall, then install</para>
 </refsection>
 <refsection xml:id="core.ppm.pear-dependencydb.uninstallpackage.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type>PEAR_PackageFile_v1|PEAR_PackageFile_v2|array</type>
      <parameter>&amp;$pkg</parameter>
     </term>
     <listitem>
      <para>
       This parameter, if an array, should be in format:
      </para>
      <para>
       <programlisting>
        <![CDATA[
<?php
array(
  'package' => 'packagename',
  'channel' => 'channelname'
);
?>
        ]]>
       </programlisting>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-dependencydb.uninstallpackage.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-dependencydb.uninstallpackage.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

</section>

 
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-frontend"><info><title>PEAR_Frontend</title></info>
 
 <refentry xml:id="core.ppm.pear-frontend-summary">
  <refnamediv>
   <refname>
    Class Summary
    <classname>PEAR_Frontend</classname>
   </refname>
   <refpurpose>Singleton-based frontend for PEAR user input/output</refpurpose>
  </refnamediv>
  <refsection><info><title>Singleton-based frontend for PEAR user input/output (since PEAR 1.4.0)</title></info>
   
   <para>
    This is also the base class for all frontends.
   </para>
  </refsection>
  <refsection><info><title>
    Class Trees for
    <classname>PEAR_Frontend</classname>
   </title></info>
   
   <para>
    <itemizedlist>
     <listitem>
      <para>
       PEAR
       <itemizedlist>
        <listitem>
         <para>PEAR_Frontend</para>
        </listitem>
       </itemizedlist>
      </para>
     </listitem>
    </itemizedlist>
   </para>
  </refsection>
 </refentry>
 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-frontend.addtempfile">
 <refnamediv>
  <refname>
   <function>PEAR_Frontend::addTempFile</function>
  </refname>
  <refpurpose>This can be overridden to allow session-based temporary file management</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/Frontend.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     void
     <function>PEAR_Frontend::addTempFile</function>
    </funcdef>
    <paramdef choice="req">
     mixed
     <parameter>$file</parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-frontend.addtempfile.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>By default, all files are deleted at the end of a session.  The web installer  needs to be able to sustain a list over many sessions in order to support  user interaction with install scripts</para>
 </refsection>
 <refsection xml:id="core.ppm.pear-frontend.addtempfile.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">mixed</type>
      <parameter>$file</parameter>
     </term>
     <listitem>
      <para/>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-frontend.addtempfile.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-frontend.addtempfile.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-frontend.isincludeable">
 <refnamediv>
  <refname>
   <function>PEAR_Frontend::isIncludeable</function>
  </refname>
  <refpurpose>isIncludeable</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/Frontend.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     bool
     <function>PEAR_Frontend::isIncludeable</function>
    </funcdef>
    <paramdef choice="req">
     string
     <parameter>$path</parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-frontend.isincludeable.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Simple utility class used to determine whether a file can be included via <literal>include_path</literal>
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-frontend.isincludeable.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$path</parameter>
     </term>
     <listitem>
      <para>relative or absolute include path</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-frontend.isincludeable.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-frontend.isincludeable.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-frontend.log">
 <refnamediv>
  <refname>
   <function>PEAR_Frontend::log</function>
  </refname>
  <refpurpose>log</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/Frontend.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     void
     <function>PEAR_Frontend::log</function>
    </funcdef>
    <paramdef choice="req">
     int
     <parameter>$level</parameter>
    </paramdef>
    <paramdef choice="req">
     string
     <parameter>$msg</parameter>
    </paramdef>
    <paramdef choice="opt">
     bool
     <parameter>$append_crlf</parameter>
     <initializer>true</initializer>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-frontend.log.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Log a message in a frontend-specific way.  By default, nothing is done.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-frontend.log.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">integer</type>
      <parameter>$level</parameter>
     </term>
     <listitem>
      <para/>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$msg</parameter>
     </term>
     <listitem>
      <para/>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">boolean</type>
      <parameter>$append_crlf</parameter>
     </term>
     <listitem>
      <para/>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-frontend.log.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-frontend.log.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="package.pear.pear.pear-frontend.setconfig">
 <refnamediv>
  <refname>
   <function>PEAR_Frontend::setConfig</function>
  </refname>
  <refpurpose>setConfig</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/Frontend.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     void
     <function>PEAR_Frontend::setConfig</function>
    </funcdef>
    <paramdef choice="req">
     PEAR_Config
     <parameter>&amp;$config</parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="package.pear.pear.pear-frontend.setconfig.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Set the configuration object used by this frontend.
  </para>
</refsection>
 <refsection xml:id="package.pear.pear.pear-frontend.setconfig.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type>PEAR_Config</type>
      <parameter>&amp;$config</parameter>
     </term>
     <listitem>
      <para/>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="package.pear.pear.pear-frontend.setconfig.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="package.pear.pear.pear-frontend.setconfig.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="package.pear.pear.pear-frontend.setfrontendclass">
 <refnamediv>
  <refname>
   <function>PEAR_Frontend::setFrontendClass</function>
  </refname>
  <refpurpose>setFrontendClass</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/Frontend.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     void&amp;
     <function>PEAR_Frontend::setFrontendClass</function>
    </funcdef>
    <paramdef choice="req">
     string
     <parameter>$uiclass</parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="package.pear.pear.pear-frontend.setfrontendclass.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Set the kind of frontend that should be retrieved from the <function>singleton</function>
   method.  If the class does not exist, the method changes all underscores (<literal>_</literal>) into directory
   separators (like PEAR_Frontend_CLI to <literal>PEAR/Frontend/CLI</literal>) and appends
   <literal>.php</literal> and then checks to see if the file can be included.  If the
   class does exist after all of this, a simple check is made to see if the
   <function>userConfirm</function> method exists, and then a new frontend object is
   returned.  Any failure causes a PEAR_Error to be returned.
  </para>
</refsection>
 <refsection xml:id="package.pear.pear.pear-frontend.setfrontendclass.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$uiclass</parameter>
     </term>
     <listitem>
      <para>
       the full classname (like <literal>PEAR_Frontend_Web</literal>)
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="package.pear.pear.pear-frontend.setfrontendclass.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   PEAR_Error on any problem
  </para>
 </refsection>
 <refsection xml:id="package.pear.pear.pear-frontend.setfrontendclass.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="package.pear.pear.pear-frontend.singleton">
 <refnamediv>
  <refname>
   <function>PEAR_Frontend::singleton</function>
  </refname>
  <refpurpose>Retrieve the frontend object</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/Frontend.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     PEAR_Frontend_CLI|PEAR_Frontend_Web|PEAR_Frontend_Gtk&amp;
     <function>PEAR_Frontend::singleton</function>
    </funcdef>
    <paramdef choice="opt">
     mixed
     <parameter>
      $type = null
     </parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="package.pear.pear.pear-frontend.singleton.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Get a single unique copy of the current PEAR frontend object.
  </para>
</refsection>
 <refsection xml:id="package.pear.pear.pear-frontend.singleton.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>|<constant xmlns="http://docbook.org/ns/docbook">NULL</constant>
      <parameter>$type</parameter>
     </term>
     <listitem>
      <para>
       if being called for the first time, the user can specify the kind of frontend to
       return.  Otherwise, this parameter is ignored, and the existing single frontend is
       returned.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="package.pear.pear.pear-frontend.singleton.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="package.pear.pear.pear-frontend.singleton.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can be called
statically.</simpara>
</refsection>
</refentry>

</section>

 
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-installer"><info><title>PEAR_Installer</title></info>
 

 <para>
  Administration class used to install PEAR packages
  and maintain the installed package database.
 </para>
 <para>
  Class Trees for <function>PEAR_Installer</function>
 </para>
 <para>
  <itemizedlist>
   <listitem>
    <para>
     PEAR_Common
     <itemizedlist>
      <listitem>
       <simpara>
        PEAR_Installer
       </simpara>
      </listitem>
     </itemizedlist>
    </para>
   </listitem>
  </itemizedlist>
 </para>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-installer.pear-installer">
   <refnamediv>
    <refname><function>PEAR_Installer::PEAR_Installer</function></refname>
    <refpurpose>constructor</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/Installer.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>void       <function>constructor PEAR_Installer::constructor PEAR_Installer</function></funcdef>
      <paramdef choice="req">object <parameter>&amp;$ui</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-installer.pear-installer.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>PEAR_Installer constructor.</para>
    </refsection>
   <refsection xml:id="core.ppm.pear-installer.pear-installer.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">object</type>
         <parameter>&amp;$ui</parameter>
       </term>      
       <listitem>
        <para>
         user interface object (instance of
         <classname>PEAR_Frontend_*</classname>)
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-installer.pear-installer.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-installer.install">
   <refnamediv>
    <refname><function>PEAR_Installer::install</function></refname>
    <refpurpose>Installs package files</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/Installer.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>array       <function>PEAR_Installer::install</function></funcdef>
      <paramdef choice="req">string <parameter>$pkgfile</parameter></paramdef>
      <paramdef choice="opt">array <parameter>$options = array()</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-installer.install.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>Installs the files within the package file specified.</para>
    </refsection>
   <refsection xml:id="core.ppm.pear-installer.install.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$pkgfile</parameter>
       </term>      
       <listitem>
        <para>
         path to the package file
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">array</type>
         <parameter>$options</parameter>
       </term>      
       <listitem>
        <para>
         installating options, to enable an option
         use the option name as array key and <constant xmlns="http://docbook.org/ns/docbook">TRUE</constant> or
         <parameter>1</parameter> as value.
         <itemizedlist>
          <listitem>
           <para>
            <parameter>$options['force'] = 1</parameter> -
            force installation
           </para>
          </listitem>                  
          <listitem>
           <para>
            <parameter>$options['register-only'] = 1</parameter> -
            update registry but don't install files
           </para>
          </listitem>           
          <listitem>
           <para>
            <parameter>$options['upgrade'] = 1</parameter> -
            upgrade existing install 
           </para>
          </listitem>           
          <listitem>
           <para>
            <parameter>$options['soft'] = 1</parameter> -
            fail silently
           </para>
          </listitem>                     
         </itemizedlist>         
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-installer.install.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>
    <para>
     <parameter>array</parameter> package info if successful
    </para>
   </refsection>

   <refsection xml:id="core.ppm.pear-installer.install.throws">
    <title xmlns="http://docbook.org/ns/docbook">Throws</title>
    <para>
     <table><title>Possible PEAR_Error values</title>
            
      <tgroup cols="4">

       <thead>
        <row>
         <entry>Error code</entry>
         <entry>Error value</entry>        
         <entry>Meaning</entry>        
         <entry>Solution</entry>        
        </row>
       </thead>
       <tbody>
        <row>
         <entry/>
         <entry><quote/></entry>
         <entry/>
         <entry/>
        </row>       
       </tbody>
      </tgroup>
     </table>
    </para>    
   </refsection>

   <refsection xml:id="core.ppm.pear-installer.install.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


</section>

 
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-packagefile"><info><title>PEAR</title></info>
 
 <refentry xml:id="core.ppm.pear-packagefile-summary">
  <refnamediv>
   <refname>
    Class Summary
    <classname>PEAR_PackageFile</classname>
   </refname>
   <refpurpose>Abstraction for the package.xml package description file</refpurpose>
  </refnamediv>
  <refsection><info><title>Abstraction for the package.xml package description file</title></info>
   
   <para>
    Parse and retrieve a package.xml object from various sources.
   </para>
  </refsection>
  <refsection><info><title>
    Class Trees for
    <classname>PEAR_PackageFile</classname>
   </title></info>
   
   <para>
    <itemizedlist>
     <listitem>
      <para>PEAR_PackageFile</para>
     </listitem>
    </itemizedlist>
   </para>
  </refsection>
 </refentry>
 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-packagefile.pear-packagefile">
 <refnamediv>
  <refname>
   constructor
   <function>PEAR_PackageFile::PEAR_PackageFile</function>
  </refname>
  <refpurpose>PEAR_PackageFile</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/PackageFile.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     void      constructor
     <function>PEAR_PackageFile::PEAR_PackageFile</function>
    </funcdef>
    <paramdef choice="req">
     PEAR_Config
     <parameter>&amp;$config</parameter>
    </paramdef>
    <paramdef choice="opt">
     bool
     <parameter>$debug</parameter>
      <initializer>false</initializer>
    </paramdef>
    <paramdef choice="opt">
     string
     <parameter>$tmpdir</parameter>
     <initializer>false</initializer>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-packagefile.pear-packagefile.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Prepare for parsing one or more package.xml files.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-packagefile.pear-packagefile.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <link linkend="core.ppm.pear-config"><classname>PEAR_Config</classname></link>
      <parameter>&amp;$config</parameter>
     </term>
     <listitem>
      <para>
       The configuration to use for parsing and channel registry (needed for
       channel-specific validators).
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">boolean</type>
      <parameter>$debug</parameter>
     </term>
     <listitem>
      <para>
       The debug logging level (this is usually the value of the <literal>verbose</literal>
       configuration variable).
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$tmpdir</parameter>
     </term>
     <listitem>
      <para>
       The temporary directory to extract files in.  By default, a new temporary
       directory is created using
       <link linkend="core.pear.system.mktemp"><function>System::mktemp</function></link>.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-packagefile.pear-packagefile.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-packagefile.pear-packagefile.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-packagefile.factory">
 <refnamediv>
  <refname>
   <function>PEAR_PackageFile::factory</function>
  </refname>
  <refpurpose>factory</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/PackageFile.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     PEAR_PackageFile_v1|PEAR_PackageFile_v2&amp;
     <function>PEAR_PackageFile::factory</function>
    </funcdef>
    <paramdef choice="req">
     string
     <parameter>$version</parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-packagefile.factory.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Retrieve a raw <classname>PEAR_PackageFile_vX</classname> object where X is either
   1 or 2.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-packagefile.factory.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$version</parameter>
     </term>
     <listitem>
      <para>
       The package.xml version represented (1 or 2)
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-packagefile.factory.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-packagefile.factory.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-packagefile.fromanyfile">
 <refnamediv>
  <refname>
   <function>PEAR_PackageFile::fromAnyFile</function>
  </refname>
  <refpurpose>Returns package information from different sources</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/PackageFile.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     string&amp;
     <function>PEAR_PackageFile::fromAnyFile</function>
    </funcdef>
    <paramdef choice="req">
     string
     <parameter>$info</parameter>
    </paramdef>
    <paramdef choice="req">
     int
     <parameter>$state</parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-packagefile.fromanyfile.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>This method is able to extract information about a package  from a .tgz archive or from a XML package definition file.</para>
 </refsection>
 <refsection xml:id="core.ppm.pear-packagefile.fromanyfile.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$info</parameter>
     </term>
     <listitem>
      <para>path to a file containing a package.xml (package archive or package.xml)</para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">integer</type>
      <parameter>$state</parameter>
     </term>
     <listitem>
      <para>package state (one of 
      <link linkend="core.ppm.pear-validate.constants"><literal>PEAR_VALIDATE_*</literal></link> constants)</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-packagefile.fromanyfile.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-packagefile.fromanyfile.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function should be called
statically.</simpara>
</refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-packagefile.fromarray">
 <refnamediv>
  <refname>
   <function>PEAR_PackageFile::fromArray</function>
  </refname>
  <refpurpose>Return a packagefile object from its toArray() method</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/PackageFile.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     PEAR_PackageFile_v1|PEAR_PackageFile_v2&amp;
     <function>PEAR_PackageFile::fromArray</function>
    </funcdef>
    <paramdef choice="req">
     array
     <parameter>$arr</parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-packagefile.fromarray.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <warning>
   <para>
    WARNING: no validation is performed, the array is assumed to be valid,  always parse from xml if you want validation.
   </para>
  </warning>
 </refsection>
 <refsection xml:id="core.ppm.pear-packagefile.fromarray.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">array</type>
      <parameter>$arr</parameter>
     </term>
     <listitem>
      <para>
       Contents of a previously parsed package.xml object.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-packagefile.fromarray.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-packagefile.fromarray.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-packagefile.frompackagefile">
 <refnamediv>
  <refname>
   <function>PEAR_PackageFile::fromPackageFile</function>
  </refname>
  <refpurpose>
   Returns information about a package file.  Expects the name of  a package.xml
   file as input.
</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/PackageFile.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     array&amp;
     <function>PEAR_PackageFile::fromPackageFile</function>
    </funcdef>
    <paramdef choice="req">
     string
     <parameter>$descfile</parameter>
    </paramdef>
    <paramdef choice="req">
     int
     <parameter>$state</parameter>
    </paramdef>
    <paramdef choice="opt">
     string|false
     <parameter>$archive</parameter>
     <initializer>false</initializer>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-packagefile.frompackagefile.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   parse and return a package.xml object from a package.xml file, or a
   <link linkend="core.pear.pear-error"><classname>PEAR_Error</classname></link> object
   upon error.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-packagefile.frompackagefile.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$descfile</parameter>
     </term>
     <listitem>
      <para>name of package.xml file</para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">integer</type>
      <parameter>$state</parameter>
     </term>
     <listitem>
      <para>package state (one of 
      <link linkend="core.ppm.pear-validate.constants"><literal>PEAR_VALIDATE_*</literal></link> constants)</para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>|<constant xmlns="http://docbook.org/ns/docbook">FALSE</constant>
      <parameter>$archive</parameter>
     </term>
     <listitem>
      <para>
       full path to the full package .tgz file containing the package.xml, or
       false for none.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-packagefile.frompackagefile.returns">
  <title xmlns="http://docbook.org/ns/docbook">Return value</title>
  <para>
   <emphasis>returns</emphasis>
   array with package information
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-packagefile.frompackagefile.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-packagefile.frompackagefile.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function should be called
statically.</simpara>
</refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-packagefile.fromtgzfile">
 <refnamediv>
  <refname>
   <function>PEAR_PackageFile::fromTgzFile</function>
  </refname>
  <refpurpose>fromTgzFile</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/PackageFile.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     PEAR_PackageFile_v1|PEAR_PackageFile_v2|PEAR_Error&amp;
     <function>PEAR_PackageFile::fromTgzFile</function>
    </funcdef>
    <paramdef choice="req">
     string
     <parameter>$file</parameter>
    </paramdef>
    <paramdef choice="req">
     int
     <parameter>$state</parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-packagefile.fromtgzfile.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   parse and return a package.xml object from a packaged archive, or a
   <link linkend="core.pear.pear-error"><classname>PEAR_Error</classname></link> object
   upon error.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-packagefile.fromtgzfile.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$file</parameter>
     </term>
     <listitem>
      <para>name of packaged .tgz or .tar to extract and parse package.xml from</para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">integer</type>
      <parameter>$state</parameter>
     </term>
     <listitem>
      <para>
       package state (one of
       <link linkend="core.ppm.pear-validate.constants"><literal>PEAR_VALIDATE_*</literal></link>
       constants)
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-packagefile.fromtgzfile.returns">
  <title xmlns="http://docbook.org/ns/docbook">Return value</title>
  <para>
   <emphasis>returns</emphasis>
   success of parsing
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-packagefile.fromtgzfile.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-packagefile.fromtgzfile.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-packagefile.fromxmlstring">
 <refnamediv>
  <refname>
   <function>PEAR_PackageFile::fromXmlString</function>
  </refname>
  <refpurpose>fromXmlString</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/PackageFile.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     PEAR_PackageFile_v1|PEAR_PackageFile_v2|PEAR_Error&amp;
     <function>PEAR_PackageFile::fromXmlString</function>
    </funcdef>
    <paramdef choice="req">
     string
     <parameter>$data</parameter>
    </paramdef>
    <paramdef choice="req">
     int
     <parameter>$state</parameter>
    </paramdef>
    <paramdef choice="req">
     string
     <parameter>$file</parameter>
    </paramdef>
    <paramdef choice="opt">
     string|false
     <parameter>$archive</parameter>
     <initializer>false</initializer>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-packagefile.fromxmlstring.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   parse and return a package.xml object, or a
   <link linkend="core.pear.pear-error"><classname>PEAR_Error</classname></link> object
   upon error.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-packagefile.fromxmlstring.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$data</parameter>
     </term>
     <listitem>
      <para>contents of package.xml file</para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">integer</type>
      <parameter>$state</parameter>
     </term>
     <listitem>
      <para>package state (one of 
      <link linkend="core.ppm.pear-validate.constants"><literal>PEAR_VALIDATE_*</literal></link> constants)</para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$file</parameter>
     </term>
     <listitem>
      <para>full path to the package.xml file (and the files it references)</para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>|<constant xmlns="http://docbook.org/ns/docbook">FALSE</constant>
      <parameter>$archive</parameter>
     </term>
     <listitem>
      <para>
       full path to the full package .tgz file containing the package.xml, or
       false for none.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-packagefile.fromxmlstring.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-packagefile.fromxmlstring.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-packagefile.parserfactory">
 <refnamediv>
  <refname>
   <function>PEAR_PackageFile::parserFactory</function>
  </refname>
  <refpurpose>parserFactory</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/PackageFile.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     PEAR_PackageFile_Parser_v1|PEAR_PackageFile_Parser_v2&amp;
     <function>PEAR_PackageFile::parserFactory</function>
    </funcdef>
    <paramdef choice="req">
     string
     <parameter>$version</parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-packagefile.parserfactory.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Return a package.xml parsing object appropriate for the selected package.xml
   version.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-packagefile.parserfactory.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$version</parameter>
     </term>
     <listitem>
      <para>
       The package.xml version represented (1 or 2)
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-packagefile.parserfactory.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-packagefile.parserfactory.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-packagefile.rawreturn">
 <refnamediv>
  <refname>
   <function>PEAR_PackageFile::rawReturn</function>
  </refname>
  <refpurpose>Turn off validation - return a parsed package.xml without checking it for errors</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/PackageFile.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     void
     <function>PEAR_PackageFile::rawReturn</function>
    </funcdef>
    <paramdef choice="req"/>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-packagefile.rawreturn.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>This is used by the package-validate command</para>
 </refsection>
 <refsection xml:id="core.ppm.pear-packagefile.rawreturn.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-packagefile.rawreturn.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-packagefile.setlogger">
 <refnamediv>
  <refname>
   <function>PEAR_PackageFile::setLogger</function>
  </refname>
  <refpurpose>setLogger</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/PackageFile.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     void
     <function>PEAR_PackageFile::setLogger</function>
    </funcdef>
    <paramdef choice="req">
     PEAR_Common
     <parameter>&amp;$l</parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-packagefile.setlogger.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   set a logging class that matches the signature of <classname>PEAR_Common</classname>'s
   <link linkend="core.ppm.pear-common.log"><function>log</function></link> method.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-packagefile.setlogger.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <link linkend="core.ppm.pear-common"><classname>PEAR_Common</classname></link>
      <parameter>&amp;$l</parameter>
     </term>
     <listitem>
      <para>
       The PEAR_Common object.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-packagefile.setlogger.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-packagefile.setlogger.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-packagefile.constants">
 <refnamediv>
  <refname>Package PEAR Constants</refname>
  <refpurpose>Constants defined in and used by PEAR</refpurpose>
 </refnamediv>
 <refsection xml:id="core.ppm.pear-packagefile.constants.details"><info><title>All Constants</title></info>
  
  <refsection xml:id="core.ppm.pear-packagefile.constants.details.packagefile---php"><info><title>Constants defined in PackageFile.php</title></info>
   
   <para>
    <table><title>Constants defined in PackageFile.php</title>
     
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Name</entry>
        <entry>Value</entry>
        <entry>Line Number</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>PEAR_PACKAGEFILE_ERROR_INVALID_PACKAGEVERSION</entry>
        <entry>2</entry>
        <entry>35</entry>
       </row>
       <row>
        <entry>PEAR_PACKAGEFILE_ERROR_NO_PACKAGEVERSION</entry>
        <entry>1</entry>
        <entry>30</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </para>
  </refsection>
 </refsection>
</refentry>

</section>

 
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-packager"><info><title>PEAR_Packager</title></info>
 
 <para>
  Administration class used to make a PEAR release tarball.
 </para>
 <para>
  Class Trees for <classname>PEAR_Packager</classname>
 </para>
 <para>
  <itemizedlist>
   <listitem>
    <para>
     PEAR_Common
     <itemizedlist>
      <listitem>
       <simpara>
        PEAR_Packager
       </simpara>
      </listitem>
     </itemizedlist>
    </para>
   </listitem>
  </itemizedlist>
 </para>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-packager.pear-packager">
   <refnamediv>
    <refname><function>PEAR_Packager::PEAR_Packager</function></refname>
    <refpurpose>constructor</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/Packager.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>void       <function>PEAR_Packager:: PEAR_Packager</function></funcdef>
<void/>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-packager.pear-packager.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>
      constructor
     </para>
    </refsection>

   <refsection xml:id="core.ppm.pear-packager.pear-packager.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-packager.package">
   <refnamediv>
    <refname><function>PEAR_Packager::package</function></refname>
    <refpurpose>Create Package archive</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
             require_once 'PEAR/Packager.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>string <function>PEAR_Packager::package</function></funcdef>
      <paramdef choice="opt">string <parameter>$pkgfile</parameter>
       <initializer>null</initializer>
      </paramdef>
      <paramdef choice="opt">boolean <parameter>$compress</parameter>
       <initializer>true</initializer>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-packager.package.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>
      Creates a Package archive from package definition file and
      package files
     </para>
    </refsection>
   <refsection xml:id="core.ppm.pear-packager.package.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
         <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$pkgfile</parameter>
       </term>      
       <listitem>
        <para>
         path to package definition file   
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">boolean</type>
         <parameter>$compress</parameter>
       </term>      
       <listitem>
        <para>
         if <constant xmlns="http://docbook.org/ns/docbook">TRUE</constant> package archive will be compessed using
         gzip
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>

   <refsection xml:id="core.ppm.pear-packager.package.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>
    <para>
     <parameter>string</parameter> - 
     name of the created package archive
    </para>
   </refsection>

   <refsection xml:id="core.ppm.pear-packager.package.throws">
    <title xmlns="http://docbook.org/ns/docbook">Throws</title>
    <para>
     <table><title>Possible PEAR_Error values</title>
            
      <tgroup cols="4">

       <thead>
        <row>
         <entry>Error code</entry>
         <entry>Error value</entry>        
         <entry>Meaning</entry>        
         <entry>Solution</entry>        
        </row>
       </thead>
       <tbody>
        <row>
         <entry/>
         <entry><quote/></entry>
         <entry/>
         <entry/>
        </row>       
       </tbody>
      </tgroup>
     </table>
    </para>    
   </refsection>

   <refsection xml:id="core.ppm.pear-packager.package.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>



</section>

 
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-registry"><info><title>PEAR_Registry</title></info>
 
 <para>
  Administration class used to maintain 
  the installed package database.
 </para>
 <para>
  Class Trees for <classname>PEAR_Registry</classname>
 </para>
 <para>
  <itemizedlist>
   <listitem>
    <para>
     PEAR
     <itemizedlist>
      <listitem>
       <simpara>
        PEAR_Registry
       </simpara>
      </listitem>
     </itemizedlist>
    </para>
   </listitem>
  </itemizedlist>
 </para>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-registry.pear-registry">
   <refnamediv>
    <refname><function>PEAR_Registry::PEAR_Registry</function></refname>
    <refpurpose>constructor</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/Registry.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>void <function>PEAR_Registry::PEAR_Registry</function></funcdef>
      <paramdef choice="opt">string <parameter>$pear_install_dir = PEAR_INSTALL_DIR</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-registry.pear-registry.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>constructor</para>
    </refsection>
   <refsection xml:id="core.ppm.pear-registry.pear-registry.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$pear_install_dir</parameter>
       </term>      
       <listitem>
        <para>
         PEAR install directory (for .php files)
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>

   <refsection xml:id="core.ppm.pear-registry.pear-registry.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-registry.addpackage">
   <refnamediv>
    <refname><function>PEAR_Registry::addPackage</function></refname>
    <refpurpose>Registers a package to the registry</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/Registry.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>boolean <function>PEAR_Registry::addPackage</function></funcdef>
      <paramdef choice="req">string <parameter>$package</parameter></paramdef>
      <paramdef choice="req">array <parameter>$info</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-registry.addpackage.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>
      Adds a Package entry to the registry
     </para>
    </refsection>
   <refsection xml:id="core.ppm.pear-registry.addpackage.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$package</parameter>
       </term>      
       <listitem>
        <para>
         Package name        
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">array</type>
         <parameter>$info</parameter>
       </term>      
       <listitem>
        <para>
         additional information for the package entry
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-registry.addpackage.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>
    <para>
     <parameter>boolean</parameter> -
     <constant xmlns="http://docbook.org/ns/docbook">FALSE</constant> if Package is already registered;
     
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-registry.addpackage.throws">
    <title xmlns="http://docbook.org/ns/docbook">Throws</title>
    <para>
     <table><title>Possible PEAR_Error values</title>
            
      <tgroup cols="4">

       <thead>
        <row>
         <entry>Error code</entry>
         <entry>Error value</entry>        
         <entry>Meaning</entry>        
         <entry>Solution</entry>        
        </row>
       </thead>
       <tbody>
        <row>
         <entry/>
         <entry><quote/></entry>
         <entry/>
         <entry/>
        </row>       
       </tbody>
      </tgroup>
     </table>
    </para>    
   </refsection>

   <refsection xml:id="core.ppm.pear-registry.addpackage.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-registry.checkfilemap">
   <refnamediv>
    <refname><function>PEAR_Registry::checkFileMap</function></refname>
    <refpurpose>Test whether a file belongs to a package</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/Registry.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>string <function>PEAR_Registry::checkFileMap</function></funcdef>
      <paramdef choice="req">string <parameter>$path</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-registry.checkfilemap.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>Test whether a file belongs to a package.</para>
    </refsection>
   <refsection xml:id="core.ppm.pear-registry.checkfilemap.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$path</parameter>
       </term>      
       <listitem>
        <para>
         file path, absolute or relative to the pear install dir
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-registry.checkfilemap.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>

    <para>
     <parameter>string</parameter> - 
     name of the package the file belongs to, or an empty 
     string if the file does not belong to an installed package
    </para>
   </refsection>

   <refsection xml:id="core.ppm.pear-registry.checkfilemap.throws">
    <title xmlns="http://docbook.org/ns/docbook">Throws</title>
    <para>
     <table><title>Possible PEAR_Error values</title>
            
      <tgroup cols="4">

       <thead>
        <row>
         <entry>Error code</entry>
         <entry>Error value</entry>        
         <entry>Meaning</entry>        
         <entry>Solution</entry>        
        </row>
       </thead>
       <tbody>
        <row>
         <entry/>
         <entry><quote/></entry>
         <entry/>
         <entry/>
        </row>       
       </tbody>
      </tgroup>
     </table>
    </para>    
   </refsection>

   <refsection xml:id="core.ppm.pear-registry.checkfilemap.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-registry.deletepackage">
   <refnamediv>
    <refname><function>PEAR_Registry::deletePackage</function></refname>
    <refpurpose>Remove Package from registry</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/Registry.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>boolean <function>PEAR_Registry::deletePackage</function></funcdef>
      <paramdef choice="req">string <parameter>$package</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-registry.deletepackage.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>
      Removes a Package entry from the registry.
     </para>
    </refsection>
   <refsection xml:id="core.ppm.pear-registry.deletepackage.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$package</parameter>
       </term>      
       <listitem>
        <para>
         Package name
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>
   
   <refsection xml:id="core.ppm.pear-registry.deletepackage.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>
    <para>
     <parameter>boolean</parameter> - 
     Returns <constant xmlns="http://docbook.org/ns/docbook">TRUE</constant> on success, <constant xmlns="http://docbook.org/ns/docbook">FALSE</constant> on failure.
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-registry.deletepackage.throws">
    <title xmlns="http://docbook.org/ns/docbook">Throws</title>
    <para>
     <table><title>Possible PEAR_Error values</title>
            
      <tgroup cols="4">

       <thead>
        <row>
         <entry>Error code</entry>
         <entry>Error value</entry>        
         <entry>Meaning</entry>        
         <entry>Solution</entry>        
        </row>
       </thead>
       <tbody>
        <row>
         <entry/>
         <entry><quote/></entry>
         <entry/>
         <entry/>
        </row>       
       </tbody>
      </tgroup>
     </table>
    </para>    
   </refsection>

   <refsection xml:id="core.ppm.pear-registry.deletepackage.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-registry.listpackages">
   <refnamediv>
    <refname><function>PEAR_Registry::listPackages</function></refname>
    <refpurpose>List all registered Packages</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/Registry.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>array <function>PEAR_Registry::listPackages</function></funcdef>
<void/>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-registry.listpackages.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>
      List all Packages registered in the registry.
     </para>
    </refsection>
    
    <refsection xml:id="core.ppm.pear-registry.listpackages.return">
     <title xmlns="http://docbook.org/ns/docbook">Return value</title>
    <para>
     <parameter>array</parameter> -
     list of package names
    </para>
   </refsection>

   <refsection xml:id="core.ppm.pear-registry.listpackages.throws">
    <title xmlns="http://docbook.org/ns/docbook">Throws</title>
    <para>
     <table><title>Possible PEAR_Error values</title>
            
      <tgroup cols="4">

       <thead>
        <row>
         <entry>Error code</entry>
         <entry>Error value</entry>        
         <entry>Meaning</entry>        
         <entry>Solution</entry>        
        </row>
       </thead>
       <tbody>
        <row>
         <entry/>
         <entry><quote/></entry>
         <entry/>
         <entry/>
        </row>       
       </tbody>
      </tgroup>
     </table>
    </para>    
   </refsection>

   <refsection xml:id="core.ppm.pear-registry.listpackages.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-registry.packageexists">
   <refnamediv>
    <refname><function>PEAR_Registry::packageExists</function></refname>
    <refpurpose>Check for Package</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/Registry.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>boolean <function>PEAR_Registry::packageExists</function></funcdef>
      <paramdef choice="req">string <parameter>$package</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-registry.packageexists.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>
      Checks wether a Package is registered in the registry or not.
     </para>
    </refsection>
   <refsection xml:id="core.ppm.pear-registry.packageexists.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$package</parameter>
       </term>      
       <listitem>
        <para>
         Package name
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>
   
   <refsection xml:id="core.ppm.pear-registry.packageexists.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>

    <para>
     <parameter>boolean</parameter> -
     <constant xmlns="http://docbook.org/ns/docbook">TRUE</constant> if package is registered
    </para>
   </refsection>

   <refsection xml:id="core.ppm.pear-registry.packageexists.throws">
    <title xmlns="http://docbook.org/ns/docbook">Throws</title>
    <para>
     <table><title>Possible PEAR_Error values</title>
            
      <tgroup cols="4">

       <thead>
        <row>
         <entry>Error code</entry>
         <entry>Error value</entry>        
         <entry>Meaning</entry>        
         <entry>Solution</entry>        
        </row>
       </thead>
       <tbody>
        <row>
         <entry/>
         <entry><quote/></entry>
         <entry/>
         <entry/>
        </row>       
       </tbody>
      </tgroup>
     </table>
    </para>    
   </refsection>

   <refsection xml:id="core.ppm.pear-registry.packageexists.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-registry.packageinfo">
   <refnamediv>
    <refname><function>PEAR_Registry::packageInfo</function></refname>
    <refpurpose>Get Package information</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/Registry.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>mixed <function>PEAR_Registry::packageInfo</function></funcdef>
      <paramdef choice="opt">string <parameter>$package</parameter>
       <initializer>null</initializer>
      </paramdef>
      <paramdef choice="opt">string <parameter>$key</parameter>
       <initializer>null</initializer>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-registry.packageinfo.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>
      Returns (specific) information stored in the registry about a Package.
     </para>
    </refsection>
   <refsection xml:id="core.ppm.pear-registry.packageinfo.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$package</parameter>
       </term>      
       <listitem>
        <para>
         Package name
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$key</parameter>
       </term>      
       <listitem>
        <para>
         the name of a specific information to get
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-registry.packageinfo.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>

    <para>
     <parameter>mixed</parameter> -
     an array with all information, or a key specific information,
     if <parameter>$key</parameter> was used; <constant xmlns="http://docbook.org/ns/docbook">NULL</constant> if Package
     or specific information does not exist
    </para>
   </refsection>

   <refsection xml:id="core.ppm.pear-registry.packageinfo.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-registry.rebuilddepsfile">
   <refnamediv>
    <refname><function>PEAR_Registry::rebuildDepsFile</function></refname>
    <refpurpose>Rebuild dependencies file</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
             require_once 'PEAR/Registry.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>void <function>PEAR_Registry::rebuildDepsFile</function></funcdef>
<void/>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-registry.rebuilddepsfile.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>
      Rebuilds the dependencies file of the registry. Use this
      function if had trouble while installing Packages or a 
      damaged registry.
     </para>
    </refsection>

   <refsection xml:id="core.ppm.pear-registry.rebuilddepsfile.throws">
    <title xmlns="http://docbook.org/ns/docbook">Throws</title>
    <para>
     <table><title>Possible PEAR_Error values</title>
            
      <tgroup cols="4">

       <thead>
        <row>
         <entry>Error code</entry>
         <entry>Error value</entry>        
         <entry>Meaning</entry>        
         <entry>Solution</entry>        
        </row>
       </thead>
       <tbody>
        <row>
         <entry/>
         <entry><quote/></entry>
         <entry/>
         <entry/>
        </row>       
       </tbody>
      </tgroup>
     </table>
    </para>    
   </refsection>

   <refsection xml:id="core.ppm.pear-registry.rebuilddepsfile.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-registry.rebuildfilemap">
   <refnamediv>
    <refname><function>PEAR_Registry::rebuildFileMap</function></refname>
    <refpurpose>Rebuild file map</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/Registry.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>void <function>PEAR_Registry::rebuildFileMap</function></funcdef>
<void/>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-registry.rebuildfilemap.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>
      Rebuilds the registry filemap. Use this
      function if had trouble while installing Packages or a 
      damaged registry. 
     </para>
    </refsection>

   <refsection xml:id="core.ppm.pear-registry.rebuildfilemap.throws">
    <title xmlns="http://docbook.org/ns/docbook">Throws</title>
    <para>
     <table><title>Possible PEAR_Error values</title>
            
      <tgroup cols="4">

       <thead>
        <row>
         <entry>Error code</entry>
         <entry>Error value</entry>        
         <entry>Meaning</entry>        
         <entry>Solution</entry>        
        </row>
       </thead>
       <tbody>
        <row>
         <entry/>
         <entry><quote/></entry>
         <entry/>
         <entry/>
        </row>       
       </tbody>
      </tgroup>
     </table>
    </para>    
   </refsection>

   <refsection xml:id="core.ppm.pear-registry.rebuildfilemap.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-registry.removepackagedep">
   <refnamediv>
    <refname><function>PEAR_Registry::removePackageDep</function></refname>
    <refpurpose>Remove dependency information of a Package</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/Registry.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>mixed <function>PEAR_Registry::removePackageDep</function></funcdef>
      <paramdef choice="req">string <parameter>$package</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-registry.removepackagedep.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>
      Removes the dependency information of a Package from
      the registry.
     </para>
    </refsection>
   <refsection xml:id="core.ppm.pear-registry.removepackagedep.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$package</parameter>
       </term>
       <listitem>
        <para>
         Package name
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-registry.removepackagedep.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>
    <para>
     <type xmlns="http://docbook.org/ns/docbook">mixed</type> -
     <constant xmlns="http://docbook.org/ns/docbook">TRUE</constant> if successful; or
     an array with a list of Packages depending on this Package
    </para>
   </refsection>

   <refsection xml:id="core.ppm.pear-registry.removepackagedep.throws">
    <title xmlns="http://docbook.org/ns/docbook">Throws</title>
    <para>
     <table><title>Possible PEAR_Error values</title>
      
      <tgroup cols="4">

       <thead>
        <row>
         <entry>Error code</entry>
         <entry>Error value</entry>
         <entry>Meaning</entry>
         <entry>Solution</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry/>
         <entry><quote/></entry>
         <entry/>
         <entry/>
        </row>
       </tbody>
      </tgroup>
     </table>
    </para>
   </refsection>

   <refsection xml:id="core.ppm.pear-registry.removepackagedep.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-registry.setpackagedep">
   <refnamediv>
    <refname><function>PEAR_Registry::setPackageDep</function></refname>
    <refpurpose>Update or insert dependencies of a Package</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/Registry.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>mixed       <function>PEAR_Registry::setPackageDep</function></funcdef>
      <paramdef choice="req">string <parameter>$package</parameter></paramdef>
      <paramdef choice="req">string <parameter>$new_version</parameter></paramdef>
      <paramdef choice="opt">array <parameter>$rel_deps = array()</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-registry.setpackagedep.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>
      Update or insert a the dependencies of a package, 
      prechecking that the package won't break any 
      dependency in the process. (Dependencies of 
      type <parameter>'pkg'</parameter> only.
     </para>
    </refsection>
   <refsection xml:id="core.ppm.pear-registry.setpackagedep.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$package</parameter>
       </term>      
       <listitem>
        <para>
         Package name        
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$new_version</parameter>
       </term>      
       <listitem>
        <para>
         Version of the Package
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">array</type>
         <parameter>$rel_deps</parameter>
       </term>      
       <listitem>
        <para>
         Package dependencies        
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-registry.setpackagedep.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>

    <para>
     <parameter>mixed</parameter> -
     <constant xmlns="http://docbook.org/ns/docbook">TRUE</constant> if no dependencies found; or 
     array with names of missing or outdated Packages
    </para>
   </refsection>

   <refsection xml:id="core.ppm.pear-registry.setpackagedep.throws">
    <title xmlns="http://docbook.org/ns/docbook">Throws</title>
    <para>
     <table><title>Possible PEAR_Error values</title>
            
      <tgroup cols="4">

       <thead>
        <row>
         <entry>Error code</entry>
         <entry>Error value</entry>        
         <entry>Meaning</entry>        
         <entry>Solution</entry>        
        </row>
       </thead>
       <tbody>
        <row>
         <entry/>
         <entry><quote/></entry>
         <entry/>
         <entry/>
        </row>       
       </tbody>
      </tgroup>
     </table>
    </para>    
   </refsection>

   <refsection xml:id="core.ppm.pear-registry.setpackagedep.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-registry.updatepackage">
   <refnamediv>
    <refname><function>PEAR_Registry::updatePackage</function></refname>
    <refpurpose>Update Package information</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/Registry.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>boolean <function>PEAR_Registry::updatePackage</function></funcdef>
      <paramdef choice="req">string <parameter>$package</parameter></paramdef>
      <paramdef choice="req">array <parameter>$info</parameter></paramdef>
      <paramdef choice="opt">bool <parameter>$merge</parameter>
       <initializer>true</initializer>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-registry.updatepackage.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>
     Updates the existing information of a Package
     in the registry.
    </para>
    </refsection>
   <refsection xml:id="core.ppm.pear-registry.updatepackage.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$package</parameter>
       </term>      
       <listitem>
        <para>
         Package name
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">array</type>
         <parameter>$info</parameter>
       </term>      
       <listitem>
        <para>
         information to update
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">mixed</type>
         <parameter>$merge</parameter>
       </term>      
       <listitem>
        <para>
         if <constant xmlns="http://docbook.org/ns/docbook">FALSE</constant> the old informations will be deleted completly
         an replaced with the new; if <constant xmlns="http://docbook.org/ns/docbook">TRUE</constant> update only - unchanged
         values will remain.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-registry.updatepackage.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>

    <para>
     <parameter>boolean</parameter> -
     Returns <constant xmlns="http://docbook.org/ns/docbook">TRUE</constant> on success, <constant xmlns="http://docbook.org/ns/docbook">FALSE</constant> on failure.
    </para>
   </refsection>

   <refsection xml:id="core.ppm.pear-registry.updatepackage.throws">
    <title xmlns="http://docbook.org/ns/docbook">Throws</title>
    <para>
     <table><title>Possible PEAR_Error values</title>
            
      <tgroup cols="4">

       <thead>
        <row>
         <entry>Error code</entry>
         <entry>Error value</entry>        
         <entry>Meaning</entry>        
         <entry>Solution</entry>        
        </row>
       </thead>
       <tbody>
        <row>
         <entry/>
         <entry><quote/></entry>
         <entry/>
         <entry/>
        </row>       
       </tbody>
      </tgroup>
     </table>
    </para>    
   </refsection>

   <refsection xml:id="core.ppm.pear-registry.updatepackage.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


</section>

 
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-remote"><info><title>PEAR_Remote</title></info>
 

 <para>
  This is a class for doing remote operations against a
  PEAR Package Server.
 </para>
 <para>
  Class Trees for <function>PEAR_Remote</function>
 </para>
 <para>
  <itemizedlist>
   <listitem>
    <para>
     PEAR  
     <itemizedlist>
      <listitem>
       <simpara>
        PEAR_Remote
       </simpara>
      </listitem>
     </itemizedlist>
    </para>
   </listitem>
  </itemizedlist>
 </para>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-remote.pear-remote">
   <refnamediv>
    <refname><function>PEAR_Remote::PEAR_Remote</function></refname>
    <refpurpose>constructor</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/Remote.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>void <function>PEAR_Remote::PEAR_Remote</function></funcdef>
      <paramdef choice="req">object <parameter>&amp;$config</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-remote.pear-remote.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>
      constructor
     </para>
    </refsection>
   <refsection xml:id="core.ppm.pear-remote.pear-remote.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">object</type>
         <parameter>&amp;$config</parameter>
       </term>      
       <listitem>
        <para>
         an instance of <classname>PEAR_Config</classname>         
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>

   <refsection xml:id="core.ppm.pear-remote.pear-remote.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-remote.call">
   <refnamediv>
    <refname><function>PEAR_Remote::call</function></refname>
    <refpurpose>Execute a server function</refpurpose>
   </refnamediv>
   <refsynopsisdiv>
    <funcsynopsis>
     <funcsynopsisinfo>
      require_once 'PEAR/Remote.php';
     </funcsynopsisinfo>
     <funcprototype>
      <funcdef>mixed <function>PEAR_Remote::call</function></funcdef>
      <paramdef choice="req">string <parameter>$method</parameter></paramdef>
      <paramdef choice="opt">mixed <parameter>$args,...</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    </refsynopsisdiv>
    <refsection xml:id="core.ppm.pear-remote.call.desc">
     <title xmlns="http://docbook.org/ns/docbook">Description</title>
     <para>
      Sends a remote procedure call to a package server
      and returns the result.
     </para>
    </refsection>
   <refsection xml:id="core.ppm.pear-remote.call.param">
    <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">string</type>
         <parameter>$method</parameter>
       </term>      
       <listitem>
        <para>
         Name of the server method
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>
        <type xmlns="http://docbook.org/ns/docbook">mixed</type>
        <parameter>$args,...</parameter>
       </term>      
       <listitem>
        <para>
         server method specific parameters
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </refsection>
   <refsection xml:id="core.ppm.pear-remote.call.return">
    <title xmlns="http://docbook.org/ns/docbook">Return value</title>
    <para>
     <parameter>mixed</parameter> -
     result of the executed server method
    </para>
   </refsection>

   <refsection xml:id="core.ppm.pear-remote.call.throws">
    <title xmlns="http://docbook.org/ns/docbook">Throws</title>
    <para>
     <table><title>Possible PEAR_Error values</title>
            
      <tgroup cols="4">

       <thead>
        <row>
         <entry>Error code</entry>
         <entry>Error value</entry>        
         <entry>Meaning</entry>        
         <entry>Solution</entry>                
        </row>
       </thead>
       <tbody>
        <row>
         <entry/>
         <entry><quote/></entry>
         <entry/>
         <entry/>
        </row>       
       </tbody>
      </tgroup>
     </table>
    </para>    
   </refsection>

   <refsection xml:id="core.ppm.pear-remote.call.note">
    <title xmlns="http://docbook.org/ns/docbook">Note</title>
    <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
   </refsection>
</refentry>



</section>

 
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-rest"><info><title>PEAR_REST</title></info>
 
 <refentry xml:id="core.ppm.pear-rest.pear-rest-summary">
  <refnamediv>
   <refname>
    Class Summary
    <classname>PEAR_REST</classname>
   </refname>
   <refpurpose>
    Intelligently retrieve data, following hyperlinks if necessary, and
    re-directing
   </refpurpose>
  </refnamediv>
  <refsection><info><title>
    Intelligently retrieve data, following hyperlinks if necessary, and
    re-directing (since PEAR 1.4.0)
   </title></info>
   
   <para>as well</para>
  </refsection>
  <refsection><info><title>
    Class Trees for
    <classname>PEAR_REST</classname>
   </title></info>
   
   <para>
    <itemizedlist>
     <listitem>
      <para>PEAR_REST</para>
     </listitem>
    </itemizedlist>
   </para>
  </refsection>
 </refentry>
 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-rest.pear-rest">
 <refnamediv>
  <refname>
   constructor
   <function>PEAR_REST::PEAR_REST</function>
  </refname>
  <refpurpose>PEAR_REST</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/REST.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     void constructor
     <function>PEAR_REST::PEAR_REST</function>
    </funcdef>
    <paramdef choice="req">
     PEAR_Config
     <parameter>&amp;$config</parameter>
    </paramdef>
    <paramdef choice="opt">
     array
     <parameter>
      $options = array()
     </parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-rest.pear-rest.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para xmlns="http://docbook.org/ns/docbook">This package is not documented yet.</para>
</refsection>
 <refsection xml:id="core.ppm.pear-rest.pear-rest.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      PEAR_Config
      <parameter>&amp;$config</parameter>
     </term>
     <listitem>
      <para>
       Configuration object
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">array</type>
      <parameter>$options</parameter>
     </term>
     <listitem>
      <para>
       options passed to commands like install/download.  The only option that affects
       PEAR_REST is <literal>offline</literal>, which causes all retrievals to look in
       the local cache without trying to retrieve a remote resource.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-rest.pear-rest.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-rest.downloadhttp">
 <refnamediv>
  <refname>
   <function>PEAR_REST::downloadHttp</function>
  </refname>
  <refpurpose>
   Efficiently Download a file through HTTP.  Returns downloaded file as a
   string in-memory  This is best used for small files
</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/REST.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     string|array
     <function>PEAR_REST::downloadHttp</function>
    </funcdef>
    <paramdef choice="req">
     string
     <parameter>$url</parameter>
    </paramdef>
    <paramdef choice="opt">
     false|string|array
     <parameter>
      $lastmodified = null
     </parameter>
    </paramdef>
    <paramdef choice="opt">
     false|array
     <parameter>
      $accept = false
     </parameter>
    </paramdef>
    <paramdef choice="req">
     string
     <parameter>$save_dir</parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-rest.downloadhttp.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>If an HTTP proxy has been configured (http_proxy PEAR_Config  setting), the proxy will be used.</para>
 </refsection>
 <refsection xml:id="core.ppm.pear-rest.downloadhttp.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$url</parameter>
     </term>
     <listitem>
      <para>the URL to download</para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <constant xmlns="http://docbook.org/ns/docbook">FALSE</constant>|<type xmlns="http://docbook.org/ns/docbook">string</type>|<type xmlns="http://docbook.org/ns/docbook">array</type>
      <parameter>$lastmodified</parameter>
     </term>
     <listitem>
      <para>
       header values to check against for caching use
       <constant xmlns="http://docbook.org/ns/docbook">FALSE</constant> to return the header values from this download
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <constant xmlns="http://docbook.org/ns/docbook">FALSE</constant>|<type xmlns="http://docbook.org/ns/docbook">array</type>
      <parameter>$accept</parameter>
     </term>
     <listitem>
      <para>
       Accept headers to send.  This should be a list of MIME types like
       <literal>text/xml</literal>, <literal>frog/legs</literal>, etc.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$save_dir</parameter>
     </term>
     <listitem>
      <para>directory to save file in</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-rest.downloadhttp.returns">
  <title xmlns="http://docbook.org/ns/docbook">Return value</title>
  <para>
   <emphasis>returns</emphasis>
   Returns the contents of the downloaded file or a PEAR                        error on failure.  If the error is caused by                        socket-related errors, the error object will                        have the fsockopen error code available through                        getCode().  If caching is requested, then return the header                        values.
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-rest.downloadhttp.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-rest.downloadhttp.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-rest.getcache">
 <refnamediv>
  <refname>
   <function>PEAR_REST::getCache</function>
  </refname>
  <refpurpose>getCache</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/REST.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     mixed|false
     <function>PEAR_REST::getCache</function>
    </funcdef>
    <paramdef choice="req">
     string
     <parameter>$url</parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-rest.getcache.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Retrieve the cache contents for a remote resource, or a PEAR_Error if the resource
   was not cached.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-rest.getcache.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$url</parameter>
     </term>
     <listitem>
      <para>
       REST resource URL
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-rest.getcache.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   PEAR_Error object returned on error.
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-rest.getcache.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-rest.getcacheid">
 <refnamediv>
  <refname>
   <function>PEAR_REST::getCacheId</function>
  </refname>
  <refpurpose>getCacheId</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/REST.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     array|false
     <function>PEAR_REST::getCacheId</function>
    </funcdef>
    <paramdef choice="req">
     string
     <parameter>$url</parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-rest.getcacheid.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Retrieve the HTTP caching information for a REST resource, or <constant xmlns="http://docbook.org/ns/docbook">FALSE</constant> if no cache is found.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-rest.getcacheid.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$url</parameter>
     </term>
     <listitem>
      <para>
       REST resource URL
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-rest.getcacheid.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-rest.getcacheid.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-rest.retrievecachefirst">
 <refnamediv>
  <refname>
   <function>PEAR_REST::retrieveCacheFirst</function>
  </refname>
  <refpurpose>Retrieve REST data, but always retrieve the local cache if it is available.</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/REST.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     string|array
     <function>PEAR_REST::retrieveCacheFirst</function>
    </funcdef>
    <paramdef choice="req">
     string
     <parameter>$url</parameter>
    </paramdef>
    <paramdef choice="opt">
     array|false
     <parameter>
      $accept = false
     </parameter>
    </paramdef>
    <paramdef choice="opt">
     boolean
     <parameter>
      $forcestring = false
     </parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-rest.retrievecachefirst.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>This is useful for elements that should never change, such as information on a particular  release</para>
 </refsection>
 <refsection xml:id="core.ppm.pear-rest.retrievecachefirst.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$url</parameter>
     </term>
     <listitem>
      <para>full URL to this resource</para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">array</type>|<constant xmlns="http://docbook.org/ns/docbook">FALSE</constant>
      <parameter>$accept</parameter>
     </term>
     <listitem>
      <para>contents of the accept-encoding header</para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">boolean</type>
      <parameter>$forcestring</parameter>
     </term>
     <listitem>
      <para>
       if <constant xmlns="http://docbook.org/ns/docbook">TRUE</constant>, xml will be returned as a string, otherwise, xml will be
       parsed using PEAR_XMLParser
</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-rest.retrievecachefirst.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-rest.retrievecachefirst.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-rest.retrievedata">
 <refnamediv>
  <refname>
   <function>PEAR_REST::retrieveData</function>
  </refname>
  <refpurpose>Retrieve a remote REST resource</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/REST.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     string|array
     <function>PEAR_REST::retrieveData</function>
    </funcdef>
    <paramdef choice="req">
     string
     <parameter>$url</parameter>
    </paramdef>
    <paramdef choice="opt">
     array|false
     <parameter>
      $accept = false
     </parameter>
    </paramdef>
    <paramdef choice="opt">
     bool
     <parameter>
      $forcestring = false
     </parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-rest.retrievedata.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   retrieve the contents of a remote resource.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-rest.retrievedata.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$url</parameter>
     </term>
     <listitem>
      <para>full URL to this resource</para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type>array|false</type>
      <parameter>$accept</parameter>
     </term>
     <listitem>
      <para>contents of the accept-encoding header</para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">boolean</type>
      <parameter>$forcestring</parameter>
     </term>
     <listitem>
      <para>
       if <constant xmlns="http://docbook.org/ns/docbook">TRUE</constant>, xml will be returned as a string, otherwise, xml will be
       parsed using PEAR_XMLParser
</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-rest.retrievedata.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   <classname>PEAR_Error</classname> objects are returned on error.
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-rest.retrievedata.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-rest.savecache">
 <refnamediv>
  <refname>
   <function>PEAR_REST::saveCache</function>
  </refname>
  <refpurpose>Save the value retrieved from a remote REST resource in the local cache.</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/REST.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     void
     <function>PEAR_REST::saveCache</function>
    </funcdef>
    <paramdef choice="req">
     string
     <parameter>$url</parameter>
    </paramdef>
    <paramdef choice="req">
     mixed
     <parameter>$contents</parameter>
    </paramdef>
    <paramdef choice="req">
     array
     <parameter>$lastmodified</parameter>
    </paramdef>
    <paramdef choice="opt">
     bool
     <parameter>
      $nochange = false
     </parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-rest.savecache.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Use this to save a resource after retrieving.  Since the <literal>cache_ttl</literal>
   configuration variable is used in determining when to check the remote server, and
   HTTP caching is used as well, it is possible for this scenario to arise:
  </para>
  <para>
   <orderedlist>
    <listitem>
     <para>
      retrieve REST resource
     </para>
    </listitem>
    <listitem>
     <para>
      cache the resource
     </para>
    </listitem>
    <listitem>
     <para>
      a few days later, retrieve the REST resource again
     </para>
    </listitem>
    <listitem>
     <para>
      HTTP caching returns 304 not modified
     </para>
    </listitem>
   </orderedlist>
  </para>
  <para>
   In this situation, it doesn't make much sense to save the resource contents
   redundantly.  Instead, the last access time can be saved in the cache id by passing
   true into the last parameter.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-rest.savecache.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$url</parameter>
     </term>
     <listitem>
      <para>
       The REST resource's URL
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">mixed</type>
      <parameter>$contents</parameter>
     </term>
     <listitem>
      <para>
       Contents retrieved from the REST resource (ignored if the last parameter is true)
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">array</type>
      <parameter>$lastmodified</parameter>
     </term>
     <listitem>
      <para>
       The ETag and LastModified headers retrieved from the remote server, used for
       HTTP caching.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">mixed</type>
      <parameter>$nochange</parameter>
     </term>
     <listitem>
      <para>
       If false, the cache is saved normally.  If true, only the <parameter>$lastmodified</parameter>
       parameter is saved in the cache id file, registering an HTTP cache hit.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-rest.savecache.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-rest.savecache.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-rest.uselocalcache">
 <refnamediv>
  <refname>
   <function>PEAR_REST::useLocalCache</function>
  </refname>
  <refpurpose>useLocalCache</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/REST.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     mixed
     <function>PEAR_REST::useLocalCache</function>
    </funcdef>
    <paramdef choice="req">
     bool
     <parameter>$url</parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-rest.uselocalcache.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Retrieve the contents of the local cached copy of a remote URL.  <constant xmlns="http://docbook.org/ns/docbook">FALSE</constant> is returned if
   there are any problems, under the assumption that REST contents will always be larger
   than a simple boolean due to HTTP overhead.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-rest.uselocalcache.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$url</parameter>
     </term>
     <listitem>
      <para>
       The URL to retrieve data for.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-rest.uselocalcache.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-rest.uselocalcache.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

</section>

 
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-runtest"><info><title>PEAR</title></info>
 
 <refentry xml:id="core.ppm.pear-runtest-summary">
  <refnamediv>
   <refname>
    Class Summary
    <classname>PEAR_RunTest</classname>
   </refname>
   <refpurpose>Simplified version of PHP's test suite</refpurpose>
  </refnamediv>
  <refsection><info><title>Simplified version of PHP's test suite</title></info>
   
   <para>Try it with:</para>
   <para>
    <screen>
     <![CDATA[
$ php -r 'include "../PEAR/RunTest.php"; $t=new PEAR_RunTest; \
  $o=$t->run("./pear_system.phpt");print_r($o);'
     ]]>
    </screen>
   </para>
  </refsection>
  <refsection><info><title>
    Class Trees for
    <classname>PEAR_RunTest</classname>
   </title></info>
   
   <para>
    <itemizedlist>
     <listitem>
      <para>PEAR_RunTest</para>
     </listitem>
    </itemizedlist>
   </para>
  </refsection>
 </refentry>
 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-runtest.pear-runtest">
 <refnamediv>
  <refname>
   constructor
   <function>PEAR_RunTest::PEAR_RunTest</function>
  </refname>
  <refpurpose>Instantiate a PEAR_RunTest object.</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/RunTest.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     void      constructor
     <function>PEAR_RunTest::PEAR_RunTest</function>
    </funcdef>
    <paramdef choice="opt">
     PEAR_Common|null
     <parameter>$logger</parameter>
     <initializer>null</initializer>
    </paramdef>
    <paramdef choice="opt">
     array
     <parameter>
      $options = array()
     </parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-runtest.pear-runtest.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   If no logger is specified, a new PEAR_Common object will be instantiated and used to
   print output to the screen.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-runtest.pear-runtest.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <link linkend="core.ppm.pear-common"><classname>PEAR_Common</classname></link>|<constant xmlns="http://docbook.org/ns/docbook">NULL</constant>
      <parameter>$logger</parameter>
     </term>
     <listitem>
      <para>
       A class that contains a <function>log</function> method matching the signature of
       <classname>PEAR_Common</classname>.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">array</type>
      <parameter>$options</parameter>
     </term>
     <listitem>
      <para>
       Currently supported options are <literal>simple</literal> and <literal>quiet</literal>.
       The <literal>simple</literal> option causes tests to simply print the title of the
       test and not the full path to the test file.  The <literal>quiet</literal> option
       causes output of only failed tests.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-runtest.pear-runtest.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-runtest.pear-runtest.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-runtest.generate-diff">
 <refnamediv>
  <refname>
   <function>PEAR_RunTest::generate_diff</function>
  </refname>
  <refpurpose>generate_diff</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/RunTest.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     void
     <function>PEAR_RunTest::generate_diff</function>
    </funcdef>
    <paramdef choice="req">
     string
     <parameter>$wanted</parameter>
    </paramdef>
    <paramdef choice="req">
     string
     <parameter>$output</parameter>
    </paramdef>
    <paramdef choice="req">
     array|false
     <parameter>$return_value</parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-runtest.generate-diff.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Returns differences by line between the expected output (<parameter>$wanted</parameter>)
   and the actual output (<parameter>$output</parameter>).  In addition, the value
   returned from the script can also be tested.  The test should be performed outside
   <function>generate_diff</function>.  If the return value is as expected, pass in
   <constant xmlns="http://docbook.org/ns/docbook">FALSE</constant>, otherwise pass in an array where the first element is the expected return
   value and the second is the actual return value.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-runtest.generate-diff.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$wanted</parameter>
     </term>
     <listitem>
      <para>
       Expected output
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$output</parameter>
     </term>
     <listitem>
      <para>
       Actual output
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">array</type>|<constant xmlns="http://docbook.org/ns/docbook">FALSE</constant>
      <parameter>$return_value</parameter>
     </term>
     <listitem>
      <para>
       False if return value was correct, otherwise an array of format:
      </para>
      <para>
       <programlisting role="php">
        <![CDATA[
<?php
array(
    1, // expected return
    2, // actual return value
);
?>
        ]]>
       </programlisting>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-runtest.generate-diff.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-runtest.generate-diff.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-runtest.run">
 <refnamediv>
  <refname>
   <function>PEAR_RunTest::run</function>
  </refname>
  <refpurpose>run</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/RunTest.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     string|PEAR_Error
     <function>PEAR_RunTest::run</function>
    </funcdef>
    <paramdef choice="req">
     string
     <parameter>$file</parameter>
    </paramdef>
    <paramdef choice="opt">
     string
     <parameter>
      $ini_settings = ''
     </parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-runtest.run.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Run a unit test.  The return value is one of:
  </para>
  <para>
   <itemizedlist>
    <listitem>
     <para>
      <literal>PASSED</literal>
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>SKIPPED</literal>
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>WARNED</literal>
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>FAILED</literal>
     </para>
    </listitem>
   </itemizedlist>
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-runtest.run.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$file</parameter>
     </term>
     <listitem>
      <para>
       Full path to the test file to run.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$ini_settings</parameter>
     </term>
     <listitem>
      <para>
       Additional customized settings to pass on the command-line to the PHP
       instance used for testing.  For example, requesting disabling use of php.ini
       or a testing php.ini can be specified.  For a full list of possible settings,
       type:
      </para>
      <para>
       <screen>
        <![CDATA[
$ php -h
        ]]>
       </screen>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-runtest.run.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-runtest.run.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

</section>

 
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-validate"><info><title>PEAR_Validate</title></info>
 
 <refentry xml:id="core.ppm.pear-validate-summary">
  <refnamediv>
   <refname>
    Class Summary
    <classname>PEAR_Validate</classname>
   </refname>
   <refpurpose>
    Validation class for package.xml - channel-level advanced validation
   </refpurpose>
  </refnamediv>
  <refsection><info><title>
    Validation class for package.xml - channel-level advanced validation
   </title></info>
   
   <para xmlns="http://docbook.org/ns/docbook">This package is not documented yet.</para>
  </refsection>
  <refsection><info><title>
    Class Trees for
    <classname>PEAR_Validate</classname>
   </title></info>
   
   <para>
    <itemizedlist>
     <listitem>
      <para>PEAR_Validate</para>
     </listitem>
    </itemizedlist>
   </para>
  </refsection>
 </refentry>
 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-validate.-addfailure">
 <refnamediv>
  <refname>
   <function>PEAR_Validate::_addFailure</function>
  </refname>
  <refpurpose>_addFailure</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/Validate.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     void
     <function>PEAR_Validate::_addFailure</function>
    </funcdef>
    <paramdef choice="req">
     string
     <parameter>$field</parameter>
    </paramdef>
    <paramdef choice="req">
     string
     <parameter>$reason</parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-validate.-addfailure.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   add a validation warning from one of the channel validation functions.  Use this
   for a non-fatal warning of a potential problem situation.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-validate.-addfailure.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$field</parameter>
     </term>
     <listitem>
      <para>
       The package.xml section being validated (such as <literal>version</literal> or
       <literal>dependencies</literal>)
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$reason</parameter>
     </term>
     <listitem>
      <para>
       A human-readable reason that validation failed.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-validate.-addfailure.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-validate.-addfailure.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-validate.-addwarning">
 <refnamediv>
  <refname>
   <function>PEAR_Validate::_addWarning</function>
  </refname>
  <refpurpose>_addWarning</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/Validate.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     void
     <function>PEAR_Validate::_addWarning</function>
    </funcdef>
    <paramdef choice="req">
     string
     <parameter>$field</parameter>
    </paramdef>
    <paramdef choice="req">
     string
     <parameter>$reason</parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-validate.-addwarning.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   add a validation warning from one of the channel validation functions.  Use this
   for a non-fatal warning of a potential problem situation.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-validate.-addwarning.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$field</parameter>
     </term>
     <listitem>
      <para>
       The package.xml section being validated (such as <literal>version</literal> or
       <literal>dependencies</literal>)
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$reason</parameter>
     </term>
     <listitem>
      <para>
       A human-readable reason that validation failed.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-validate.-addwarning.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-validate.-addwarning.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-validate.getfailures">
 <refnamediv>
  <refname>
   <function>PEAR_Validate::getFailures</function>
  </refname>
  <refpurpose>getFailures</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/Validate.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     void
     <function>PEAR_Validate::getFailures</function>
    </funcdef>
    <paramdef choice="req"/>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-validate.getfailures.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Returns a list of failures recorded by the last validation attempt.  The list is in
   format:
  </para>
  <para>
   <programlisting role="php">
    <![CDATA[
<?php
array(
    'error' =>
        array(
            array('field' => 'name', 'name must contain only letters, numbers or underscore'),
        ),
    'warning' =>
        array(
            array('field' => 'version', 'version should be less than 2.0'),
        )
);
?>
    ]]>
   </programlisting>
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-validate.getfailures.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-validate.getfailures.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-validate.getvalidstates">
 <refnamediv>
  <refname>
   <function>PEAR_Validate::getValidStates</function>
  </refname>
  <refpurpose>Get a list of valid stability levels</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/Validate.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     array
     <function>PEAR_Validate::getValidStates</function>
    </funcdef>
    <paramdef choice="req"/>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-validate.getvalidstates.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Utility function for future extensibility of the list of valid stability levels.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-validate.getvalidstates.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-validate.getvalidstates.final"><info><title>Final</title></info>
  
  <para>
   <emphasis>final</emphasis> - this method must not be overridden
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-validate.getvalidstates.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function should be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-validate.setpackagefile">
 <refnamediv>
  <refname>
   <function>PEAR_Validate::setPackageFile</function>
  </refname>
  <refpurpose>setPackageFile</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/Validate.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     void
     <function>PEAR_Validate::setPackageFile</function>
    </funcdef>
    <paramdef choice="req">
     PEAR_PackageFile_v1|PEAR_PackageFile_v2
     <parameter>&amp;$pf</parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-validate.setpackagefile.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Sets the packagefile object that will be used to retrieve data for validation.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-validate.setpackagefile.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type>PEAR_PackageFile_v1|PEAR_PackageFile_v2</type>
      <parameter>&amp;$pf</parameter>
     </term>
     <listitem>
      <para/>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-validate.setpackagefile.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-validate.setpackagefile.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-validate.validate">
 <refnamediv>
  <refname>
   <function>PEAR_Validate::validate</function>
  </refname>
  <refpurpose>validate</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/Validate.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     void
     <function>PEAR_Validate::validate</function>
    </funcdef>
    <paramdef choice="opt">
     int
     <parameter>$state</parameter>
     <initializer>null</initializer>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-validate.validate.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Validate the package.xml passed into
   <link linkend="core.ppm.pear-validate.setpackagefile"><function>setPackageFile</function></link>.
   The parameter passed in is the installer state that should be used, and is one of
   <literal>PEAR_VALIDATE_INSTALLING</literal>, <literal>PEAR_VALIDATE_DOWNLOADING</literal>,
   <literal>PEAR_VALIDATE_NORMAL</literal>, <literal>PEAR_VALIDATE_UNINSTALLING</literal>,
   or <literal>PEAR_VALIDATE_PACKAGING</literal>.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-validate.validate.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">integer</type>
      <parameter>$state</parameter>
     </term>
     <listitem>
      <para>one of the PEAR_VALIDATE_* constants</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-validate.validate.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-validate.validate.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-validate.validatechangelog">
 <refnamediv>
  <refname>
   <function>PEAR_Validate::validateChangelog</function>
  </refname>
  <refpurpose>validateChangelog</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/Validate.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     void
     <function>PEAR_Validate::validateChangelog</function>
    </funcdef>
    <paramdef choice="req"/>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-validate.validatechangelog.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Override this in a channel-specific validator to validate the contents of the
   &lt;changelog&gt; tag.
  </para>
  <para>
   Errors should be reported using
   <link linkend="core.ppm.pear-validate.-addfailure"><function>_addFailure</function></link>
   method, and non-fatal errors (warnings) should be reported using the
   <link linkend="core.ppm.pear-validate.-addwarning"><function>_addWarning</function></link>
   method.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-validate.validatechangelog.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-validate.validatechangelog.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-validate.validatedate">
 <refnamediv>
  <refname>
   <function>PEAR_Validate::validateDate</function>
  </refname>
  <refpurpose>validateDate</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/Validate.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     void
     <function>PEAR_Validate::validateDate</function>
    </funcdef>
    <paramdef choice="req"/>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-validate.validatedate.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Override this in a channel-specific validator to validate the contents of the &lt;date&gt;
   tag.
  </para>
  <para>
   Errors should be reported using
   <link linkend="core.ppm.pear-validate.-addfailure"><function>_addFailure</function></link>
   method, and non-fatal errors (warnings) should be reported using the
   <link linkend="core.ppm.pear-validate.-addwarning"><function>_addWarning</function></link>
   method.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-validate.validatedate.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-validate.validatedate.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-validate.validatedependencies">
 <refnamediv>
  <refname>
   <function>PEAR_Validate::validateDependencies</function>
  </refname>
  <refpurpose>for package.xml 2.0 only - channels can't use package.xml 1.0</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/Validate.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     void
     <function>PEAR_Validate::validateDependencies</function>
    </funcdef>
    <paramdef choice="req"/>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-validate.validatedependencies.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Override this in a channel-specific validator to validate the &lt;dependencies&gt; tag
   of a package.xml 2.0-based release.
  </para>
  <para>
   Errors should be reported using
   <link linkend="core.ppm.pear-validate.-addfailure"><function>_addFailure</function></link>
   method, and non-fatal errors (warnings) should be reported using the
   <link linkend="core.ppm.pear-validate.-addwarning"><function>_addWarning</function></link>
   method.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-validate.validatedependencies.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-validate.validatedependencies.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-validate.validatedeps">
 <refnamediv>
  <refname>
   <function>PEAR_Validate::validateDeps</function>
  </refname>
  <refpurpose>validateDeps</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/Validate.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     void
     <function>PEAR_Validate::validateDeps</function>
    </funcdef>
    <paramdef choice="req"/>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-validate.validatedeps.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Override this in a channel-specific validator to validate the contents of
   &lt;deps&gt; in a package.xml 1.0-based release.
  </para>
  <para>
   Errors should be reported using
   <link linkend="core.ppm.pear-validate.-addfailure"><function>_addFailure</function></link>
   method, and non-fatal errors (warnings) should be reported using the
   <link linkend="core.ppm.pear-validate.-addwarning"><function>_addWarning</function></link>
   method.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-validate.validatedeps.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-validate.validatedeps.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-validate.validatedescription">
 <refnamediv>
  <refname>
   <function>PEAR_Validate::validateDescription</function>
  </refname>
  <refpurpose>validateDescription</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/Validate.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     void
     <function>PEAR_Validate::validateDescription</function>
    </funcdef>
    <paramdef choice="req"/>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-validate.validatedescription.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Override this in a channel-specific validator to validate the contents of the
   &lt;description&gt; tag.
  </para>
  <para>
   Errors should be reported using
   <link linkend="core.ppm.pear-validate.-addfailure"><function>_addFailure</function></link>
   method, and non-fatal errors (warnings) should be reported using the
   <link linkend="core.ppm.pear-validate.-addwarning"><function>_addWarning</function></link>
   method.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-validate.validatedescription.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-validate.validatedescription.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-validate.validatefilelist">
 <refnamediv>
  <refname>
   <function>PEAR_Validate::validateFilelist</function>
  </refname>
  <refpurpose>validateFilelist</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/Validate.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     void
     <function>PEAR_Validate::validateFilelist</function>
    </funcdef>
    <paramdef choice="req"/>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-validate.validatefilelist.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Override this in a channel-specific validator to validate the contents of the
   &lt;filelist&gt; tag in a package.xml 1.0-based release.
  </para>
  <para>
   Errors should be reported using
   <link linkend="core.ppm.pear-validate.-addfailure"><function>_addFailure</function></link>
   method, and non-fatal errors (warnings) should be reported using the
   <link linkend="core.ppm.pear-validate.-addwarning"><function>_addWarning</function></link>
   method.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-validate.validatefilelist.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-validate.validatefilelist.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-validate.validatelicense">
 <refnamediv>
  <refname>
   <function>PEAR_Validate::validateLicense</function>
  </refname>
  <refpurpose>validateLicense</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/Validate.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     void
     <function>PEAR_Validate::validateLicense</function>
    </funcdef>
    <paramdef choice="req"/>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-validate.validatelicense.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Override this method in a channel-specific validator to validate the contents
   of the &lt;license&gt; tag.
  </para>
  <para>
   Errors should be reported using
   <link linkend="core.ppm.pear-validate.-addfailure"><function>_addFailure</function></link>
   method, and non-fatal errors (warnings) should be reported using the
   <link linkend="core.ppm.pear-validate.-addwarning"><function>_addWarning</function></link>
   method.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-validate.validatelicense.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-validate.validatelicense.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-validate.validatemainfilelist">
 <refnamediv>
  <refname>
   <function>PEAR_Validate::validateMainFilelist</function>
  </refname>
  <refpurpose>for package.xml 2.0 only</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/Validate.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     void
     <function>PEAR_Validate::validateMainFilelist</function>
    </funcdef>
    <paramdef choice="req"/>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-validate.validatemainfilelist.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Override this in a channel-specific validator to validate the contents of
   the &lt;contents&gt; tag in package.xml 2.0-based releases.
  </para>
  <para>
   Errors should be reported using
   <link linkend="core.ppm.pear-validate.-addfailure"><function>_addFailure</function></link>
   method, and non-fatal errors (warnings) should be reported using the
   <link linkend="core.ppm.pear-validate.-addwarning"><function>_addWarning</function></link>
   method.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-validate.validatemainfilelist.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-validate.validatemainfilelist.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-validate.validatemaintainers">
 <refnamediv>
  <refname>
   <function>PEAR_Validate::validateMaintainers</function>
  </refname>
  <refpurpose>validateMaintainers</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/Validate.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     void
     <function>PEAR_Validate::validateMaintainers</function>
    </funcdef>
    <paramdef choice="req"/>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-validate.validatemaintainers.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Override this in a channel-specific validator to validate the contents of
   &lt;maintainers&gt; in a package.xml 1.0-based release.
  </para>
  <para>
   Errors should be reported using
   <link linkend="core.ppm.pear-validate.-addfailure"><function>_addFailure</function></link>
   method, and non-fatal errors (warnings) should be reported using the
   <link linkend="core.ppm.pear-validate.-addwarning"><function>_addWarning</function></link>
   method.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-validate.validatemaintainers.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-validate.validatemaintainers.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-validate.validatenotes">
 <refnamediv>
  <refname>
   <function>PEAR_Validate::validateNotes</function>
  </refname>
  <refpurpose>validateNotes</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/Validate.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     void
     <function>PEAR_Validate::validateNotes</function>
    </funcdef>
    <paramdef choice="req"/>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-validate.validatenotes.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Override this in a channel-specific validator to validate the contents of
   release notes in a &lt;notes&gt; tag.
  </para>
  <para>
   Errors should be reported using
   <link linkend="core.ppm.pear-validate.-addfailure"><function>_addFailure</function></link>
   method, and non-fatal errors (warnings) should be reported using the
   <link linkend="core.ppm.pear-validate.-addwarning"><function>_addWarning</function></link>
   method.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-validate.validatenotes.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-validate.validatenotes.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-validate.validatepackagename">
 <refnamediv>
  <refname>
   <function>PEAR_Validate::validatePackageName</function>
  </refname>
  <refpurpose>validatePackageName</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/Validate.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     void
     <function>PEAR_Validate::validatePackageName</function>
    </funcdef>
    <paramdef choice="req"/>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-validate.validatepackagename.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Override this in a channel-specific validator to validate a package name.
  </para>
  <para>
   Errors should be reported using
   <link linkend="core.ppm.pear-validate.-addfailure"><function>_addFailure</function></link>
   method, and non-fatal errors (warnings) should be reported using the
   <link linkend="core.ppm.pear-validate.-addwarning"><function>_addWarning</function></link>
   method.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-validate.validatepackagename.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-validate.validatepackagename.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-validate.validatereleasefilelist">
 <refnamediv>
  <refname>
   <function>PEAR_Validate::validateReleaseFilelist</function>
  </refname>
  <refpurpose>for package.xml 2.0 only</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/Validate.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     void
     <function>PEAR_Validate::validateReleaseFilelist</function>
    </funcdef>
    <paramdef choice="req"/>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-validate.validatereleasefilelist.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Use this to validate the contents of a &lt;filelist&gt; tag in a
   package.xml 2.0-based package.
  </para>
  <para>
   Errors should be reported using
   <link linkend="core.ppm.pear-validate.-addfailure"><function>_addFailure</function></link>
   method, and non-fatal errors (warnings) should be reported using the
   <link linkend="core.ppm.pear-validate.-addwarning"><function>_addWarning</function></link>
   method.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-validate.validatereleasefilelist.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-validate.validatereleasefilelist.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-validate.validatestability">
 <refnamediv>
  <refname>
   <function>PEAR_Validate::validateStability</function>
  </refname>
  <refpurpose>validateStability</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/Validate.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     void
     <function>PEAR_Validate::validateStability</function>
    </funcdef>
    <paramdef choice="req"/>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-validate.validatestability.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Override this in a channel-specific validator to validate the &lt;stability&gt;
   tag of a package.xml 2.0-based release.
  </para>
  <para>
   Errors should be reported using
   <link linkend="core.ppm.pear-validate.-addfailure"><function>_addFailure</function></link>
   method, and non-fatal errors (warnings) should be reported using the
   <link linkend="core.ppm.pear-validate.-addwarning"><function>_addWarning</function></link>
   method.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-validate.validatestability.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-validate.validatestability.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-validate.validatestate">
 <refnamediv>
  <refname>
   <function>PEAR_Validate::validateState</function>
  </refname>
  <refpurpose>validateState</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/Validate.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     void
     <function>PEAR_Validate::validateState</function>
    </funcdef>
    <paramdef choice="req"/>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-validate.validatestate.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Override this in a channel-specific validator to validate the contents
   of a &lt;state&gt; tag in a package.xml 1.0-based release.
  </para>
  <para>
   Errors should be reported using
   <link linkend="core.ppm.pear-validate.-addfailure"><function>_addFailure</function></link>
   method, and non-fatal errors (warnings) should be reported using the
   <link linkend="core.ppm.pear-validate.-addwarning"><function>_addWarning</function></link>
   method.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-validate.validatestate.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-validate.validatestate.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-validate.validatesummary">
 <refnamediv>
  <refname>
   <function>PEAR_Validate::validateSummary</function>
  </refname>
  <refpurpose>validateSummary</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/Validate.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     void
     <function>PEAR_Validate::validateSummary</function>
    </funcdef>
    <paramdef choice="req"/>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-validate.validatesummary.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>Override this in a channel-specific validator to validate the &lt;summary&gt; tag.</para>
  <para>
   Errors should be reported using
   <link linkend="core.ppm.pear-validate.-addfailure"><function>_addFailure</function></link>
   method, and non-fatal errors (warnings) should be reported using the
   <link linkend="core.ppm.pear-validate.-addwarning"><function>_addWarning</function></link>
   method.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-validate.validatesummary.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-validate.validatesummary.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-validate.validatetime">
 <refnamediv>
  <refname>
   <function>PEAR_Validate::validateTime</function>
  </refname>
  <refpurpose>validateTime</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/Validate.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     void
     <function>PEAR_Validate::validateTime</function>
    </funcdef>
    <paramdef choice="req"/>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-validate.validatetime.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Override this method to validate the &lt;time&gt; tag in a channel-specific validator.
  </para>
  <para>
   Errors should be reported using
   <link linkend="core.ppm.pear-validate.-addfailure"><function>_addFailure</function></link>
   method, and non-fatal errors (warnings) should be reported using the
   <link linkend="core.ppm.pear-validate.-addwarning"><function>_addWarning</function></link>
   method.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-validate.validatetime.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-validate.validatetime.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-validate.validateversion">
 <refnamediv>
  <refname>
   <function>PEAR_Validate::validateVersion</function>
  </refname>
  <refpurpose>protected function to validate a version</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/Validate.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     void
     <function>PEAR_Validate::validateVersion</function>
    </funcdef>
    <paramdef choice="req"/>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-validate.validateversion.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Override this function in a channel validator in order to apply a different
   version validation scheme.  An example of this use is in the <classname>PEAR_Validate_PECL</classname>
   class, which overrides <function>validateVersion</function> to be less strict than
   the default <function>PEAR_Validate::validateVersion</function>.
  </para>
  <para>
   Errors should be reported using
   <link linkend="core.ppm.pear-validate.-addfailure"><function>_addFailure</function></link>
   method, and non-fatal errors (warnings) should be reported using the
   <link linkend="core.ppm.pear-validate.-addwarning"><function>_addWarning</function></link>
   method.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-validate.validateversion.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-validate.validateversion.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-validate.validgroupname">
 <refnamediv>
  <refname>
   <function>PEAR_Validate::validGroupName</function>
  </refname>
  <refpurpose>
   This validates a dependency group name, and dependency group names must conform  to the PEAR
   naming convention, so the method is final and static.
</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/Validate.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     void
     <function>PEAR_Validate::validGroupName</function>
    </funcdef>
    <paramdef choice="req">
     string
     <parameter>$name</parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-validate.validgroupname.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Dependency groups are documented <link linkend="guide.developers.package2.dependencies">here</link>
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-validate.validgroupname.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$name</parameter>
     </term>
     <listitem>
      <para>
       Dependency group name to validate
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-validate.validgroupname.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-validate.validgroupname.final"><info><title>Final</title></info>
  
  <para>
   <emphasis>final</emphasis> - this method should not be overridden.
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-validate.validgroupname.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function should be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-validate.validpackagename">
 <refnamediv>
  <refname>
   <function>PEAR_Validate::validPackageName</function>
  </refname>
  <refpurpose>utility method to validate a package name string</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/Validate.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     void
     <function>PEAR_Validate::validPackageName</function>
    </funcdef>
    <paramdef choice="req">
     string
     <parameter>$name</parameter>
    </paramdef>
    <paramdef choice="opt">
     string
     <parameter>$validatepackagename</parameter>
     <initializer>false</initializer>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-validate.validpackagename.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Validate a package name string.  The second parameter should be the name of the
   channel validation package, as defined by channel.xml for the current channel.
   If the package name being validated is the same as the validation package (case-insensitive),
   then it will be validated using the default rules for PEAR packages.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-validate.validpackagename.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$name</parameter>
     </term>
     <listitem>
      <para>package name to validate</para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$validatepackagename</parameter>
     </term>
     <listitem>
      <para>name of channel-specific validation package</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-validate.validpackagename.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-validate.validpackagename.final"><info><title>Final</title></info>
  
  <para>
   <emphasis>final</emphasis> - this method should not be overridden.
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-validate.validpackagename.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-validate.validstate">
 <refnamediv>
  <refname>
   <function>PEAR_Validate::validState</function>
  </refname>
  <refpurpose>Determine whether $state represents a valid stability level</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/Validate.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     bool
     <function>PEAR_Validate::validState</function>
    </funcdef>
    <paramdef choice="req">
     string
     <parameter>$state</parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-validate.validstate.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   This utility method can be used to determine whether a string is a valid state.
   Currently, states must be one of <literal>snapshot</literal>, <literal>devel</literal>,
   <literal>alpha</literal>, <literal>beta</literal>, and <literal>stable</literal>.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-validate.validstate.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$state</parameter>
     </term>
     <listitem>
      <para>
       State string to validate.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-validate.validstate.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-validate.validstate.final"><info><title>Final</title></info>
  
  <para>
   <emphasis>final</emphasis> - this method should not be overridden.
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-validate.validstate.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function should be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-validate.validversion">
 <refnamediv>
  <refname>
   <function>PEAR_Validate::validVersion</function>
  </refname>
  <refpurpose>
   Determine whether a version is a properly formatted version number that can
   be used by <function>version_compare</function>
</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/Validate.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     bool
     <function>PEAR_Validate::validVersion</function>
    </funcdef>
    <paramdef choice="req">
     string
     <parameter>$ver</parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-validate.validversion.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Use this method to test the validity of a version number string.  All
   versions must be testable with PHP's <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.php.net/version_compare"><function>version_compare</function></link>.
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-validate.validversion.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$ver</parameter>
     </term>
     <listitem>
      <para>
       Version string
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-validate.validversion.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-validate.validversion.final"><info><title>Final</title></info>
  
  <para>
   <emphasis>final</emphasis> - this method should not be overridden.
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-validate.validversion.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function should be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-validate.-validpackagename">
 <refnamediv>
  <refname>
   <function>PEAR_Validate::_validPackageName</function>
  </refname>
  <refpurpose>Override this method to handle validation of normal package names</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/Validate.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     bool
     <function>PEAR_Validate::_validPackageName</function>
    </funcdef>
    <paramdef choice="req">
     string
     <parameter>$name</parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-validate.-validpackagename.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   This protected method can be used to change the normal package validation scheme.
   By default, all packages must begin with a letter and contain only letters, numbers
   and underscores.  Using this method, it is possible to change this entirely to enforce
   another scheme.
  </para>
  <para>
   For instance, enforcing java-style com.blah.package package names can be done simply by this code:
  </para>
  <para>
   <programlisting role="php">
    <![CDATA[
<?php
require_once 'PEAR/Validate.php';
class MyChannel_Validate extends PEAR_Validate
{
    function _validPackageName($name)
    {
        return preg_match('/[a-zA-Z][a-zA-Z0-9_]*(\.[a-zA-Z0-9_]+)*/', $name);
    }
}
?>
    ]]>
   </programlisting>
  </para>
  <para>
   Then, by using a <link linkend="core.ppm.pear-channelfile.setvalidationpackage">customized channel validation package</link>,
   the installer will enforce java-style package names for your channel.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-validate.-validpackagename.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$name</parameter>
     </term>
     <listitem>
      <para>
       package name string to test for validity.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-validate.-validpackagename.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-validate.-validpackagename.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-validate.constants">
 <refnamediv>
  <refname>Package PEAR Constants</refname>
  <refpurpose>Constants defined in and used by PEAR</refpurpose>
 </refnamediv>
 <refsection xml:id="core.ppm.pear-validate.constants.details"><info><title>All Constants</title></info>
  
  <refsection xml:id="core.ppm.pear-validate.constants.details.validate---php"><info><title>Constants defined in Validate.php</title></info>
   
   <para>
    <table><title>Constants defined in Validate.php</title>
     
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Name</entry>
        <entry>Value</entry>
        <entry>Line Number</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>PEAR_VALIDATE_DOWNLOADING</entry>
        <entry>4</entry>
        <entry>28</entry>
       </row>
       <row>
        <entry>PEAR_VALIDATE_INSTALLING</entry>
        <entry>1</entry>
        <entry>25</entry>
       </row>
       <row>
        <entry>PEAR_VALIDATE_NORMAL</entry>
        <entry>3</entry>
        <entry>27</entry>
       </row>
       <row>
        <entry>PEAR_VALIDATE_PACKAGING</entry>
        <entry>7</entry>
        <entry>29</entry>
       </row>
       <row>
        <entry>PEAR_VALIDATE_UNINSTALLING</entry>
        <entry>2</entry>
        <entry>26</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </para>
  </refsection>
 </refsection>
</refentry>

</section>

 
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-xmlparser"><info><title>PEAR</title></info>
 
 <refentry xml:id="core.ppm.pear-xmlparser-summary">
  <refnamediv>
   <refname>
    Class Summary
    <classname>PEAR_XMLParser</classname>
   </refname>
   <refpurpose>Parser for any xml file</refpurpose>
  </refnamediv>
  <refsection><info><title>Parser for any xml file</title></info>
   
   <para xmlns="http://docbook.org/ns/docbook">This package is not documented yet.</para>
  </refsection>
  <refsection><info><title>
    Class Trees for
    <classname>PEAR_XMLParser</classname>
   </title></info>
   
   <para>
    <itemizedlist>
     <listitem>
      <para>PEAR_XMLParser</para>
     </listitem>
    </itemizedlist>
   </para>
  </refsection>
 </refentry>
 
<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-xmlparser.getdata">
 <refnamediv>
  <refname>
   <function>PEAR_XMLParser::getData</function>
  </refname>
  <refpurpose>getData</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/XMLParser.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     array
     <function>PEAR_XMLParser::getData</function>
    </funcdef>
    <paramdef choice="req"/>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-xmlparser.getdata.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Return the array representation of XML as parsed by
   <link linkend="core.ppm.pear-xmlparser.parse"><function>parse</function></link>.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-xmlparser.getdata.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-xmlparser.getdata.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-xmlparser.parse">
 <refnamediv>
  <refname>
   <function>PEAR_XMLParser::parse</function>
  </refname>
  <refpurpose>parse</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/XMLParser.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     <replaceable>true|PEAR_Error</replaceable>
     <function>PEAR_XMLParser::parse</function>
    </funcdef>
    <paramdef choice="req">
     string
     <parameter>$data</parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-xmlparser.parse.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   Return an array that matches the XML parsed.  This code is lifted from
   Stephan Schmidt's <classname>XML_Unserializer</classname>
   class in the XML_Serializer package.  As such, tags are represented by an associative
   array.  Multiple tags are represented with a 0-based array of tag contents, and
   attributes are represented by an array index named <literal>attribs</literal>.
   If attributes are present, the array index <literal>_contents</literal> is used to
   hold the contents of the xml tag.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-xmlparser.parse.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$data</parameter>
     </term>
     <listitem>
      <para>xml content</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-xmlparser.parse.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-xmlparser.parse.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>


<refentry xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.ppm.pear-xmlparser.preprocessstupidsaxon">
 <refnamediv>
  <refname>
   <function>PEAR_XMLParser::preProcessStupidSaxon</function>
  </refname>
  <refpurpose>pre-process xml to weed out characters/entities that would kill parsing</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <funcsynopsis>
   <funcsynopsisinfo>require_once '/XMLParser.php';</funcsynopsisinfo>
   <funcprototype>
    <funcdef>
     string
     <function>PEAR_XMLParser::preProcessStupidSaxon</function>
    </funcdef>
    <paramdef choice="req">
     string
     <parameter>$data</parameter>
    </paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsection xml:id="core.ppm.pear-xmlparser.preprocessstupidsaxon.desc">
  <title xmlns="http://docbook.org/ns/docbook">Description</title>
  <para>
   This method examines xml data prior to parsing and replaces all entities
   like &amp;agrave; with their equivalent (&amp;#224; in this case).  It also
   scans the file for any non-ascii characters like  and replaces them with
   their entity equivalent (&amp;#224).
  </para>
  <para>
   This prevents saxon in PHP 4 and PHP 5 from choking on non-ISO-8859-1 characters.
  </para>
</refsection>
 <refsection xml:id="core.ppm.pear-xmlparser.preprocessstupidsaxon.param">
  <title xmlns="http://docbook.org/ns/docbook">Parameter</title>
  <para>
   <variablelist>
    <varlistentry>
     <term>
      <type xmlns="http://docbook.org/ns/docbook">string</type>
      <parameter>$data</parameter>
     </term>
     <listitem>
      <para>
       The xml data.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-xmlparser.preprocessstupidsaxon.throws">
  <title xmlns="http://docbook.org/ns/docbook">Throws</title>
  <para>
   <emphasis>throws</emphasis>
   no exceptions thrown
  </para>
 </refsection>
 <refsection xml:id="core.ppm.pear-xmlparser.preprocessstupidsaxon.note">
  <title xmlns="http://docbook.org/ns/docbook">Note</title>
  <simpara xmlns="http://docbook.org/ns/docbook">This function can not be called
statically.</simpara>
</refsection>
</refentry>

</section>


</chapter>

  </part>

 </book>

 <book xml:id="channels">
  <title>Channels: distributing your packages</title>
  
<chapter xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="channels.whatarethey">
  <info>
   <title>channel.xml, REST, XML-RPC</title>
   <author><personname><firstname>Gregory</firstname><surname>Beaver</surname></personname></author>
   <date>2009-06-25</date>
  </info>

  <para>
   What is a PEAR Channel?  PEAR Channels make it possible to take advantage of
   the strengths of the PEAR Installer and Pyrus for your own personal packages.
   A channel is simply a website that provides packages for download and a few
   extra meta-information files.
  </para>
  <para>
   A familiar example of a channel is
   <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://pear.php.net">pear.php.net</link>.
   This channel was the first channel, and defines the standards to which other
   channels must adhere.  Each channel has a channel.xml
   file in its document root (such as <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://pear.php.net/channel.xml">
   http://pear.php.net/channel.xml</link>) and a series of files utilizing the
   <literal>REST</literal> (Representational State Transfer) paradigm to describe
   the packages available for installation and download.  The <literal>pear.php.net</literal>
   channel's <literal>REST</literal> files can be viewed at <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://pear.php.net/rest">
   http://pear.php.net/rest</link>.
  </para>

  
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.rest">
    
    <title>PEAR channel server REST interface</title>



 <para>
  This manual section describes how the REST interface of
  a PEAR channel server works, as well as the files and their
  formats look like.
 </para>

 
<section xmlns="http://docbook.org/ns/docbook" xmlns:phd="http://www.php.net/ns/phd" version="lillet" xml:id="core.rest.directorystructure" phd:chunk="true">
 <info>
  <title>Directory structure</title>
  <titleabbrev>Which files a channel server provides</titleabbrev>
 </info>
  
  

  <para>
   A REST channel server simply delivers files in a certain directory
   structure. The content of those files is static. Their location is relative
   to the URLs given in the <filename>channel.xml</filename>
   <literal>baseurl</literal> tags.
  </para>

  <note>
   <para>
    All files are static - you do <emphasis>not</emphasis> need a scripting
    language installed on your server.
   </para>
  </note>

  <para>
   The following table lists all known files, a tiny description as well
   as the version they appeared in first.
  </para>

  <table><title>Directory- and file structure</title>
    

    <tgroup cols="5">
      <thead>
        <row>
          <entry>Level 0</entry>

          <entry>Level 1</entry>

          <entry>Level 2</entry>

          <entry>Description</entry>

          <entry>REST version</entry>
        </row>
      </thead>

      <tbody>
        <row>
          <entry><filename>c/</filename></entry>

          <entry/>

          <entry/>

          <entry><emphasis>Categories</emphasis></entry>

          <entry>1.0</entry>
        </row>

        <row>
          <entry/>

          <entry><link linkend="core.rest.fileformats.c-categoriesxml"><filename>categories.xml</filename></link></entry>

          <entry/>

          <entry>List of all categories</entry>

          <entry>1.1</entry>
        </row>

        <row>
          <entry/>

          <entry><filename>$CategoryName/</filename></entry>

          <entry/>

          <entry/>

          <entry>1.0</entry>
        </row>

        <row>
          <entry/>

          <entry/>

          <entry><filename><link linkend="core.rest.fileformats.c-category-infoxml">info.xml</link></filename></entry>

          <entry>Info about the category</entry>

          <entry>1.0</entry>
        </row>

        <row>
          <entry/>

          <entry/>

          <entry><filename><link linkend="core.rest.fileformats.c-category-packagesxml">packages.xml</link></filename></entry>

          <entry>List of packages in category</entry>

          <entry>1.0</entry>
        </row>

        <row>
          <entry/>

          <entry/>

          <entry><filename><link linkend="core.rest.fileformats.c-category-packagesinfoxml">packagesinfo.xml</link></filename></entry>

          <entry>Info about all packages</entry>

          <entry>1.1</entry>
        </row>

        <row>
          <entry/>

          <entry/>

          <entry/>

          <entry/>

          <entry/>
        </row>

        <row>
          <entry><filename>m/</filename></entry>

          <entry/>

          <entry/>

          <entry><emphasis>Maintainers</emphasis></entry>

          <entry>1.0</entry>
        </row>

        <row>
          <entry/>

          <entry><filename><link linkend="core.rest.fileformats.m-allmaintainersxml">allmaintainers.xml</link></filename></entry>

          <entry/>

          <entry>List of all maintainers</entry>

          <entry>1.1</entry>
        </row>

        <row>
          <entry/>

          <entry><filename>$maintainernick/</filename></entry>

          <entry/>

          <entry/>

          <entry>1.0</entry>
        </row>

        <row>
          <entry/>

          <entry/>

          <entry><filename><link linkend="core.rest.fileformats.m-maintainer-infoxml">info.xml</link></filename></entry>

          <entry>Info about the maintainer</entry>

          <entry>1.0</entry>
        </row>

        <row>
          <entry/>

          <entry/>

          <entry/>

          <entry/>

          <entry/>
        </row>

        <row>
          <entry><filename>p/</filename></entry>

          <entry/>

          <entry/>

          <entry><emphasis>Packages</emphasis></entry>

          <entry>1.0</entry>
        </row>

        <row>
          <entry/>

          <entry><filename><link linkend="core.rest.fileformats.p-packagesxml">packages.xml</link></filename></entry>

          <entry/>

          <entry>List of all packages</entry>

          <entry>1.0</entry>
        </row>

        <row>
          <entry/>

          <entry><filename>$packagename/</filename></entry>

          <entry/>

          <entry/>

          <entry>1.0</entry>
        </row>

        <row>
          <entry/>

          <entry/>

          <entry><filename><link linkend="core.rest.fileformats.p-package-infoxml">info.xml</link></filename></entry>

          <entry>General package information</entry>

          <entry>1.0</entry>
        </row>

        <row>
          <entry/>

          <entry/>

          <entry><filename><link linkend="core.rest.fileformats.p-package-maintainersxml">maintainers.xml</link></filename></entry>

          <entry>List of package maintainers</entry>

          <entry>1.0</entry>
        </row>

        <row>
          <entry/>

          <entry/>

          <entry><filename><link linkend="core.rest.fileformats.p-package-maintainers2xml">maintainers2.xml</link></filename></entry>

          <entry>List of developers and their roles</entry>

          <entry>1.2</entry>
        </row>

        <row>
          <entry/>

          <entry/>

          <entry/>

          <entry/>

          <entry/>
        </row>

        <row>
          <entry><filename>r/</filename></entry>

          <entry/>

          <entry/>

          <entry><emphasis>Releases</emphasis></entry>

          <entry>1.0</entry>
        </row>

        <row>
          <entry/>

          <entry><filename>$packagename/</filename></entry>

          <entry/>

          <entry/>

          <entry>1.0</entry>
        </row>

        <row>
          <entry/>

          <entry/>

          <entry><filename><link linkend="core.rest.fileformats.r-package-allreleasesxml">allreleases.xml</link></filename></entry>

          <entry>List of all releases</entry>

          <entry>1.0</entry>
        </row>

        <row>
          <entry/>

          <entry/>

          <entry><filename><link linkend="core.rest.fileformats.r-package-allreleases2xml">allreleases2.xml</link></filename></entry>

          <entry>List of all releases including minimum PHP version</entry>

          <entry>1.3</entry>
        </row>

        <row>
          <entry/>

          <entry/>

          <entry><filename><link linkend="core.rest.fileformats.r-package-latesttxt">latest.txt</link></filename></entry>

          <entry>Latest version number</entry>

          <entry>1.0</entry>
        </row>

        <row>
          <entry/>

          <entry/>

          <entry><link linkend="core.rest.fileformats.r-package-stabletxt"><filename>stable.txt</filename></link></entry>

          <entry>Latest stable version number</entry>

          <entry>1.0</entry>
        </row>

        <row>
          <entry/>

          <entry/>

          <entry><link linkend="core.rest.fileformats.r-package-betatxt"><filename>beta.txt</filename></link></entry>

          <entry>Latest beta version number</entry>

          <entry>1.0</entry>
        </row>

        <row>
          <entry/>

          <entry/>

          <entry><link linkend="core.rest.fileformats.r-package-alphatxt"><filename>alpha.txt</filename></link></entry>

          <entry>Latest alpha version number</entry>

          <entry>1.0</entry>
        </row>

        <row>
          <entry/>

          <entry/>

          <entry><link linkend="core.rest.fileformats.r-package-develtxt"><filename>devel.txt</filename></link></entry>

          <entry>Latest development version number</entry>

          <entry>1.0</entry>
        </row>

        <row>
          <entry/>

          <entry/>

          <entry><link linkend="core.rest.fileformats.r-package-012xml"><filename>0.1.2.xml</filename></link></entry>

          <entry>Short package info for version 0.1.2</entry>

          <entry>1.0</entry>
        </row>

        <row>
          <entry/>

          <entry/>

          <entry><link linkend="core.rest.fileformats.r-package-v2012xml"><filename>v2.0.1.2.xml</filename></link></entry>

          <entry>Short version of package.xml, version 2</entry>

          <entry>1.3</entry>
        </row>

        <row>
          <entry/>

          <entry/>

          <entry><link linkend="core.rest.fileformats.r-package-package012xml"><filename>package.0.1.2.xml</filename></link></entry>

          <entry>package.xml for version 0.1.2</entry>

          <entry>1.0</entry>
        </row>

        <row>
          <entry/>

          <entry/>

          <entry><link linkend="core.rest.fileformats.r-package-deps012txt"><filename>deps.0.1.2.txt</filename></link></entry>

          <entry>Serialized dependencies for version 0.1.2</entry>

          <entry>1.0</entry>
        </row>

        <row>
          <entry/>

          <entry/>

          <entry/>

          <entry/>

          <entry/>
        </row>
      </tbody>
    </tgroup>
  </table>
</section>

 
<section xmlns="http://docbook.org/ns/docbook" xmlns:phd="http://www.php.net/ns/phd" version="lillet" xml:id="core.rest.fileformats" phd:chunk="true">
 <info>
  <title>File formats</title>
  <titleabbrev>How the files look like</titleabbrev>
 </info>
 
 

 <para>
  Here you will find detailled description of the file formats used
  for the REST interface.
 </para>

 <note>
  <para>
   In file names that contain version numbers, we use <literal>0.1.2</literal>
   as example.
  </para>
 </note>

 <para>
  In general, the files try to be as small as possible so that only little
  bandwidth is required to fetch them. That's why all of the xml files
  (except the original <filename>package.xml</filename> have only tag names
  of one or two characters.
  Remember that operations like <command>pear list-all</command> download a
  large number of files, so every saved bit helps.
 </para>


<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.rest.fileformats.channelxml"><info><title>channel.xml</title></info>
 
 <synopsis>Information about the channel</synopsis>

 <para>
  This is the main file for a channel; nothing works without it.
  When discovering a channel, this file is retrieved.
  It defines the REST directory locations as well as mirrors.
 </para>

 <para>
  The channel <literal>&lt;name&gt;</literal> is a full qualified domain
  name and is used as part of the URL when e.g. updating the
  <filename>channel.xml</filename> file.
 </para>

 <para>
  PEAR provides aliases for channels as shortcuts in the daily work of your
  user's lifes. The <literal>&lt;suggestedalias&gt;</literal> should be
  a short and easy to write word. Benefit is that, instead of
  <screen><![CDATA[pear install pear.mynicelittlespaceon.example.org/package]]></screen>
  they just can type
  <screen><![CDATA[pear install nice/package]]></screen>
  if the alias was <literal>nice</literal>.
 </para>

 <!-- FIXME: more explanation about SSL and such -->


 <section xml:id="core.rest.fileformats.channelxml.location"><info><title>Location</title></info>
  
  <para>
   <filename>/channel.xml</filename>
  </para>
  <para>
   It needs to be in the root directory of the domain.
   While all other files can be located somewhere deep in a directory structure,
   <filename>channel.xml</filename> needs to be in <filename>/</filename>.
  </para>
 </section>


 <section xml:id="core.rest.fileformats.channelxml.example"><info><title>Example</title></info>
  
  <programlisting role="xml"><![CDATA[<?xml version="1.0" encoding="utf-8"?>
<channel version="1.0"
         xmlns="http://pear.php.net/channel-1.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://pear.php.net/channel-1.0
                             http://pear.php.net/dtd/channel-1.0.xsd"
>
 <name>pear.example.org</name><!-- URL, used to update channel.xml and such -->
 <suggestedalias>example</suggestedalias>
 <summary>Simple demo channel server</summary>
 <servers>
  <primary>
   <!-- you can ignore xmlrpc, it's deprecated anyway -->
   <xmlrpc>
    <function version="1.0">logintest</function>
    <function version="1.0">package.listLatestReleases</function>
    <function version="1.0">package.listAll</function>
    <function version="1.0">package.info</function>
    <function version="1.0">package.getDownloadURL</function>
    <function version="1.1">package.getDownloadURL</function>
    <function version="1.0">package.getDepDownloadURL</function>
    <function version="1.1">package.getDepDownloadURL</function>
    <function version="1.0">package.search</function>
    <function version="1.0">channel.listAll</function>
   </xmlrpc>
   <rest>
    <baseurl type="REST1.0">http://pear.example.org/rest/</baseurl>
    <baseurl type="REST1.1">http://pear.example.org/rest/</baseurl>
    <baseurl type="REST1.2">http://pear.example.org/rest/</baseurl>
    <baseurl type="REST1.3">http://pear.example.org/rest/</baseurl>
   </rest>
  </primary>

  <mirror host="us.pear.example.org">
   <rest>
    <baseurl type="REST1.0">http://us.pear.example.org/rest/</baseurl>
    <baseurl type="REST1.1">http://us.pear.example.org/rest/</baseurl>
    <baseurl type="REST1.2">http://us.pear.example.org/rest/</baseurl>
    <baseurl type="REST1.3">http://us.pear.example.org/rest/</baseurl>
   </rest>
  </mirror>

  <mirror host="de.pear.example.org" ssl="yes" port="3452">
   <rest>
    <baseurl type="REST1.0">https://de.pear.example.org:3452/rest/</baseurl>
    <baseurl type="REST1.1">https://de.pear.example.org:3452/rest/</baseurl>
    <baseurl type="REST1.2">https://de.pear.example.org:3452/rest/</baseurl>
    <baseurl type="REST1.3">https://de.pear.example.org:3452/rest/</baseurl>
   </rest>
  </mirror>

 </servers>
</channel>]]></programlisting>
 </section>

</section>


<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.rest.fileformats.c-categoriesxml"><info><title>categories.xml</title></info>
 
 <synopsis>List of all categories</synopsis>

 <para>
  Provides a names and links to for all categories known on the server.
  Links are URL-encoded.
 </para>

 <note>
  <para>
   Unlike all other files, the channel name is wrapped in a
   <literal>&lt;ch&gt;</literal> instead of a plain
   <literal>&lt;c&gt;</literal> tag.
  </para>
 </note>


 <section xml:id="core.rest.fileformats.c-categoriesxml.location"><info><title>Location</title></info>
  
  <para>
   <filename>c/categories.xml</filename>
  </para>
 </section>


 <section xml:id="core.rest.fileformats.c-categoriesxml.example"><info><title>Example</title></info>
  
  <programlisting role="xml"><![CDATA[<?xml version="1.0" encoding="utf-8" ?>
<a xmlns="http://pear.php.net/dtd/rest.allcategories"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:xlink="http://www.w3.org/1999/xlink"
   xsi:schemaLocation="http://pear.php.net/dtd/rest.allcategories
                       http://pear.php.net/dtd/rest.allcategories.xsd"
>
 <ch>pear.example.org</ch>
 <c xlink:href="/rest/c/Tools/info.xml">Tools</c>
 <c xlink:href="/rest/c/Garbage%2Band%2BStuff/info.xml">Garbage and Stuff</c>
</a>]]></programlisting>
 </section>

</section>


<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.rest.fileformats.c-category-infoxml"><info><title>info.xml (category)</title></info>
 
 <synopsis>Information about a category</synopsis>

 <para>
  Here, the category is explained in detail. The file lists
  the name (<literal>&lt;n&gt;</literal>),
  channel server (<literal>&lt;c&gt;</literal>),
  alias (<literal>&lt;a&gt;</literal>)
  and a longer description of the category (<literal>&lt;d&gt;</literal>).
 </para>


 <section xml:id="core.rest.fileformats.c-category-infoxml.location"><info><title>Location</title></info>
  
  <para>
   <filename>c/${categoryname}/info.xml</filename>
  </para>
  <note>
   <para>
    Category names may contain spaces and other special characters,
    so (x)links need to be url-encoded.
   </para>
  </note>
 </section>


 <section xml:id="core.rest.fileformats.c-category-infoxml.example"><info><title>Example</title></info>
  
  <programlisting role="xml"><![CDATA[<?xml version="1.0" encoding="utf-8" ?>
<c xmlns="http://pear.php.net/dtd/rest.category"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:xlink="http://www.w3.org/1999/xlink"
   xsi:schemaLocation="http://pear.php.net/dtd/rest.category
                       http://pear.php.net/dtd/rest.category.xsd"
>
 <n>Tools</n>
 <c>pear.example.org</c>
 <a>Tools and Utilities</a>
 <d>This category holds all sorts of packages that might help you when
  trying to dominate the world.</d>
</c>]]></programlisting>
 </section>

</section>


<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.rest.fileformats.c-category-packagesxml"><info><title>packages.xml (category)</title></info>
 
 <synopsis>List of all packages in category</synopsis>

 <para>
  The file simply contains a list of names and links to each
  package in the category.
 </para>


 <section xml:id="core.rest.fileformats.c-category-packagesxml.location"><info><title>Location</title></info>
  
  <para>
   <filename>c/${categoryname}/packages.xml</filename>
  </para>
  <note>
   <para>
    Category names may contain spaces and other special characters,
    so (x)links need to be url-encoded.
   </para>
  </note>
 </section>


 <section xml:id="core.rest.fileformats.c-category-packagesxml.example"><info><title>Example</title></info>
  
  <programlisting role="xml"><![CDATA[<?xml version="1.0" encoding="utf-8" ?>
<l xmlns="http://pear.php.net/dtd/rest.categorypackages"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:xlink="http://www.w3.org/1999/xlink"
   xsi:schemaLocation="http://pear.php.net/dtd/rest.categorypackages
                       http://pear.php.net/dtd/rest.categorypackages.xsd"
>
 <p xlink:href="/rest/p/earth">Earth</p>
 <p xlink:href="/rest/p/worlddominator">WorldDominator</p>
</l>]]></programlisting>
 </section>

</section>


<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.rest.fileformats.c-category-packagesinfoxml"><info><title>packagesinfo.xml</title></info>
 
 <synopsis>Extended information about all packages</synopsis>

 <para>
  <filename>packagesinfo.xml</filename> is a collection of information about
  packages in the category. It contains the contents of the package's
  <link linkend="core.rest.fileformats.p-package-infoxml"><filename>info.xml</filename></link>,
  release information from
  <link linkend="core.rest.fileformats.r-package-allreleasesxml"><filename>allreleases.xml</filename></link>
  and dependency information for each version.
 </para>

 <para>
  Every package information piece is wrapped in a <literal>&lt;pi&gt;</literal>
  tag.
 </para>


 <section xml:id="core.rest.fileformats.c-category-packagesinfoxml.location"><info><title>Location</title></info>
  
  <para>
   <filename>c/${categoryname}/packagesinfo.xml</filename>
  </para>
  <note>
   <para>
    Category names may contain spaces and other special characters,
    so (x)links need to be url-encoded.
   </para>
  </note>
 </section>


 <section xml:id="core.rest.fileformats.c-category-packagesinfoxml.usage"><info><title>Usage</title></info>
  
  <para>
    <!-- FIXME: check that -->
    Provides "summary" information in the <command>list-all</command> commmand.
  </para>
 </section>


 <section xml:id="core.rest.fileformats.c-category-packagesinfoxml.example"><info><title>Example</title></info>
  
  <programlisting role="xml"><![CDATA[<?xml version="1.0" encoding="utf-8" ?>
<f xmlns="http://pear.php.net/dtd/rest.categorypackageinfo"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:xlink="http://www.w3.org/1999/xlink"
   xsi:schemaLocation="http://pear.php.net/dtd/rest.categorypackageinfo
                       http://pear.php.net/dtd/rest.categorypackageinfo.xsd"
>
 <pi>
  <p>
   <n>WorldDominator</n>
   <c>pear.example.org</c>
   <!-- Full contents of p/${packagename}/info.xml follow -->
  </p>
  <a>
   <r><v>1.1.2</v><s>stable</s></r>
   <r><v>0.1.2</v><s>beta</s></r>
   <r><v>0.0.1</v><s>devel</s></r>
  </a>
  <deps>
   <v>0.1.2</v>
   <d><!-- serialized dependency information like deps.0.1.2.txt --></d>
  </deps>
  <deps>
   <v>0.0.1</v>
   <d><!-- serialized dependency information like deps.0.1.2.txt --></d>
  </deps>
 </pi>
</f>]]></programlisting>
 </section>

</section>


<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.rest.fileformats.m-allmaintainersxml"><info><title>allmaintainers.xml</title></info>
 
 <synopsis>Lists all maintainers</synopsis>

 <para>
  Simply lists names and links to all developers of any package
  on the server.
 </para>

 <para>
  FIXME: full names or just nicks?
  FIXME: lowercased nicks?
 </para>


 <section xml:id="core.rest.fileformats.m-allmaintainersxml.location"><info><title>Location</title></info>
  
  <para>
   <filename>m/allmaintainers.xml</filename>
  </para>
 </section>


 <section xml:id="core.rest.fileformats.m-allmaintainersxml.example"><info><title>Example</title></info>
  
  <programlisting role="xml"><![CDATA[<?xml version="1.0" encoding="utf-8" ?>
<m xmlns="http://pear.php.net/dtd/rest.allmaintainers"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:xlink="http://www.w3.org/1999/xlink"
   xsi:schemaLocation="http://pear.php.net/dtd/rest.allmaintainers
                       http://pear.php.net/dtd/rest.allmaintainers.xsd"
>
 <h xlink:href="/rest/m/pinky">pinky</h>
 <h xlink:href="/rest/m/thebrain">the brain</h>
</m>]]></programlisting>
 </section>

</section>


<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.rest.fileformats.m-maintainer-infoxml"><info><title>info.xml (maintainer)</title></info>
 
 <synopsis>Information about a maintainer</synopsis>

 <para>
  Contains maintainer information like handle
  (nickname, <literal>&lt;h&gt;</literal>),
  full name (<literal>&lt;n&gt;</literal>)
  and URL (<literal>&lt;u&gt;</literal>) to the developer's homepage.
 </para>


 <section xml:id="core.rest.fileformats.m-maintainer-infoxml.location"><info><title>Location</title></info>
  
  <para>
   <filename>m/${maintainernick}/info.xml</filename>
  </para>
  <para>
   FIXME: lowercasednick?
  </para>
 </section>


 <section xml:id="core.rest.fileformats.m-maintainer-infoxml.example"><info><title>Example</title></info>
  
  <programlisting role="xml"><![CDATA[<?xml version="1.0" encoding="utf-8" ?>
<m xmlns="http://pear.php.net/dtd/rest.maintainer"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:xlink="http://www.w3.org/1999/xlink"
   xsi:schemaLocation="http://pear.php.net/dtd/rest.maintainer
                       http://pear.php.net/dtd/rest.maintainer.xsd"
>
 <h>thebrain</h>
 <n>The Brain</n>
 <u>http://pinkyandthebrain.example.org</u>
</m>]]></programlisting>
 </section>

</section>


<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.rest.fileformats.p-packagesxml"><info><title>packages.xml (p)</title></info>
 
 <synopsis>List of all packages</synopsis>

 <para>
  This file lists all packages in this channel, together with the channel server
  name itself.
 </para>

 <para>
  Package names should not contain any spaces; the behavior of the installer
  in such cases is undefined.
 </para>


 <section xml:id="core.rest.fileformats.p-packagesxml.location"><info><title>Location</title></info>
  
  <para>
   <filename>p/packages.xml</filename>
  </para>
  <note>
   <para>
    The package name is lowercased.
   </para>
  </note>
 </section>


 <section xml:id="core.rest.fileformats.p-packagesxml.example"><info><title>Example</title></info>
  
  <programlisting role="xml"><![CDATA[<?xml version="1.0" encoding="utf-8" ?>
<a xmlns="http://pear.php.net/dtd/rest.allpackages"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:xlink="http://www.w3.org/1999/xlink"
   xsi:schemaLocation="http://pear.php.net/dtd/rest.allpackages
                       http://pear.php.net/dtd/rest.allpackages.xsd"
>
 <c>pear.example.org</c>
 <p>Earth</p>
 <p>WorldDominator</p>
</a>]]></programlisting>
 </section>

</section>


<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.rest.fileformats.p-package-infoxml"><info><title>info.xml (package)</title></info>
 
 <synopsis>Information about a package</synopsis>

 <para>
  This file contains general version-independent information
  about the package: License, category, summary, description
  and a link to the release directory.
 </para>


 <section xml:id="core.rest.fileformats.p-package-infoxml.location"><info><title>Location</title></info>
  
  <para>
   <filename>r/${packagename}/info.xml</filename>
  </para>
  <note>
   <para>
    The package name is lowercased.
   </para>
  </note>
 </section>


 <section xml:id="core.rest.fileformats.p-package-infoxml.usage"><info><title>Usage</title></info>
  
  <para>
   <command>remote-info</command> fetches this file and displays
   its information.
  </para>
 </section>


 <section xml:id="core.rest.fileformats.p-package-infoxml.example"><info><title>Example</title></info>
  
  <programlisting role="xml"><![CDATA[<?xml version="1.0" encoding="utf-8" ?>
<p xmlns="http://pear.php.net/dtd/rest.package"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:xlink="http://www.w3.org/1999/xlink"
   xsi:schemaLocation="http://pear.php.net/dtd/rest.package
                       http://pear.php.net/dtd/rest.package.xsd"
>
 <n>WorldDomination</n>
 <c>pear.example.org</c>
 <ca xlink:href="/rest/c/Tools">Tools</ca>
 <l>Dictatoric License</l>
 <s>Tool to dominate the world</s>
 <d>
  Helps you dominating the world by fulfilling various tasks:
  - Feed the cats
  - Lock the doors after 23:42
 </d>
 <r xlink:href="/rest/r/worlddomination"/>
</p>]]></programlisting>
 </section>

</section>


<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.rest.fileformats.p-package-maintainersxml"><info><title>maintainers.xml</title></info>
 
 <synopsis>Lists all developers on the package</synopsis>

 <para>
  All package developers are listed in this file, regardless if active
  or inactive.
 </para>

 <para>
  Each maintainer's handle (<literal>&lt;h&gt;</literal>) and
  activity state (<literal>&lt;a&gt;</literal>, <literal>0</literal>
  for inactive, <literal>1</literal> for active)
  is provided.
 </para>


 <section xml:id="core.rest.fileformats.p-package-maintainersxml.location"><info><title>Location</title></info>
  
  <para>
   <filename>r/${packagename}/maintainers.xml</filename>
  </para>
  <note>
   <para>
    The package name is lowercased.
   </para>
  </note>
 </section>


 <section xml:id="core.rest.fileformats.p-package-maintainersxml.example"><info><title>Example</title></info>
  
  <programlisting role="xml"><![CDATA[<?xml version="1.0" encoding="utf-8" ?>
<m xmlns="http://pear.php.net/dtd/rest.packagemaintainers"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:xlink="http://www.w3.org/1999/xlink"
   xsi:schemaLocation="http://pear.php.net/dtd/rest.packagemaintainers
                       http://pear.php.net/dtd/rest.packagemaintainers.xsd"
>
 <p>WorldDominator</p>
 <c>pear.example.org</c>
 <m>
  <h>pinky</h>
  <a>1</a>
 </m>
 <m>
  <h>thebrain</h>
  <a>1</a>
 </m>
 <m>
  <h>deadcow</h>
  <a>0</a>
 </m>
</m>]]></programlisting>
 </section>

</section>


<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.rest.fileformats.p-package-maintainers2xml"><info><title>maintainers2.xml</title></info>
 
 <synopsis>Lists package developers</synopsis>

 <para>
  Same as
  <link linkend="core.rest.fileformats.p-package-maintainersxml"><filename>maintainers.xml</filename></link>,
  except that the developer's role is written down, too.
 </para>
 <para>
  Valid
  <link linkend="guide.developers.package2.developers">role names</link>
  are <literal>lead</literal>, <literal>developer</literal>,
  <literal>contributor</literal> and <literal>helper</literal>.
 </para>


 <section xml:id="core.rest.fileformats.p-package-maintainers2xml.location"><info><title>Location</title></info>
  
  <para>
   <filename>r/${packagename}/maintainers2.xml</filename>
  </para>
  <note>
   <para>
    The package name is lowercased.
   </para>
  </note>
 </section>


 <section xml:id="core.rest.fileformats.p-package-maintainers2xml.example"><info><title>Example</title></info>
  
  <programlisting role="xml"><![CDATA[<?xml version="1.0" encoding="utf-8" ?>
<m xmlns="http://pear.php.net/dtd/rest.packagemaintainers"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:xlink="http://www.w3.org/1999/xlink"
   xsi:schemaLocation="http://pear.php.net/dtd/rest.packagemaintainers
                       http://pear.php.net/dtd/rest.packagemaintainers.xsd"
>
 <p>WorldDominator</p>
 <c>pear.example.org</c>
 <m>
  <h>pinky</h>
  <a>1</a>
  <r>developer</r>
 </m>
 <m>
  <h>thebrain</h>
  <a>1</a>
  <r>lead</r>
 </m>
 <m>
  <h>deadcow</h>
  <a>0</a>
  <r>helper</r>
 </m>
</m>]]></programlisting>
 </section>

</section>


<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.rest.fileformats.r-package-allreleasesxml"><info><title>allreleases.xml</title></info>
 
 <synopsis>List of all package versions</synopsis>

 <para>
  This file lists all known versions of a package, together with
  its stability.
 </para>

 <para>
  Releases in this file are ordered, the latest version has to be first.
 </para>

 <section xml:id="core.rest.fileformats.r-package-allreleasesxml.location"><info><title>Location</title></info>
  
  <para>
   <filename>r/${packagename}/allreleases.xml</filename>
  </para>
  <note>
   <para>
    The package name is lowercased.
   </para>
  </note>
 </section>


 <section xml:id="core.rest.fileformats.r-package-allreleasesxml.example"><info><title>Example</title></info>
  
  <programlisting role="xml"><![CDATA[<?xml version="1.0" encoding="utf-8" ?>
<a xmlns="http://pear.php.net/dtd/rest.allreleases"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:xlink="http://www.w3.org/1999/xlink"
   xsi:schemaLocation="http://pear.php.net/dtd/rest.allreleases
                       http://pear.php.net/dtd/rest.allreleases.xsd"
>
 <p>WorldDominator</p>
 <c>pear.example.org</c>
 <r><v>0.8.1</v><s>beta</s></r>
 <r><v>0.0.2</v><s>alpha</s></r>
</a>]]></programlisting>
 </section>

</section>


<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.rest.fileformats.r-package-allreleases2xml"><info><title>allreleases2.xml</title></info>
 
 <synopsis>List of all package versions with PHP version</synopsis>

 <para>
  Same as <filename>allreleases.xml</filename>, but with information
  about the minimum version of PHP required.
 </para>


 <section xml:id="core.rest.fileformats.r-package-allreleases2xml.location"><info><title>Location</title></info>
  
  <para>
   <filename>r/${packagename}/allreleases2.xml</filename>
  </para>
  <note>
   <para>
    The package name is lowercased.
   </para>
  </note>
 </section>


 <section xml:id="core.rest.fileformats.r-package-allreleases2xml.example"><info><title>Example</title></info>
  
  <programlisting role="xml"><![CDATA[<?xml version="1.0" encoding="utf-8" ?>
<a xmlns="http://pear.php.net/dtd/rest.allreleases2"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:xlink="http://www.w3.org/1999/xlink"
   xsi:schemaLocation="http://pear.php.net/dtd/rest.allreleases2
                       http://pear.php.net/dtd/rest.allreleases2.xsd"
>
 <p>WorldDominator</p>
 <c>pear.example.org</c>
 <r><v>0.8.1</v><s>beta</s><m>4.4.2</m></r>
 <r><v>0.0.2</v><s>alpha</s><m>5.2.3</m></r>
</a>]]></programlisting>
 </section>

</section>


<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.rest.fileformats.r-package-latesttxt"><info><title>latest.txt</title></info>
 
 <synopsis>The latest package version</synopsis>

 <para>
  The only content of this file is the version number of the latest
  version in pure plain text. The stability state does not matter;
  the highest version number is written down here.
 </para>


 <section xml:id="core.rest.fileformats.r-package-latesttxt.location"><info><title>Location</title></info>
  
  <para>
   <filename>r/${packagename}/latest.txt</filename>
  </para>
  <note>
   <para>
    The package name is lowercased.
   </para>
  </note>
  <para>
   This file does not exist when no release has been made yet.
  </para>
 </section>


 <section xml:id="core.rest.fileformats.r-package-latesttxt.example"><info><title>Example</title></info>
  

  <para>
   A package has a stable version <literal>1.0.0</literal>, two beta versions
   <literal>0.9.8</literal> and <literal>1.0.9</literal> and a development
   version <literal>1.0.1</literal>. The highest version number is
   <literal>1.0.9</literal>, and this is put in <filename>latest.txt</filename>.
  </para>

  <programlisting role="text"><![CDATA[1.0.9]]></programlisting>
 </section>

</section>


<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.rest.fileformats.r-package-stabletxt"><info><title>stable.txt</title></info>
 
 <synopsis>The latest stable version</synopsis>

 <para>
  The only content of this file is the version number of the latest
  stable version in pure plain text.
 </para>


 <section xml:id="core.rest.fileformats.r-package-stabletxt.location"><info><title>Location</title></info>
  
  <para>
   <filename>r/${packagename}/stable.txt</filename>
  </para>
  <note>
   <para>
    The package name is lowercased.
   </para>
  </note>
  <para>
   This file does not exist when no stable release exists.
  </para>
 </section>


 <section xml:id="core.rest.fileformats.r-package-stabletxt.example"><info><title>Example</title></info>
  
  <programlisting role="text"><![CDATA[0.1.2]]></programlisting>
 </section>

</section>


<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.rest.fileformats.r-package-betatxt"><info><title>beta.txt</title></info>
 
 <synopsis>The latest beta version</synopsis>

 <para>
  The only content of this file is the version number of the latest
  beta version in pure plain text.
 </para>


 <section xml:id="core.rest.fileformats.r-package-betatxt.location"><info><title>Location</title></info>
  
  <para>
   <filename>r/${packagename}/beta.txt</filename>
  </para>
  <note>
   <para>
    The package name is lowercased.
   </para>
  </note>
  <para>
   This file does not exist when the package has no beta version.
  </para>
 </section>


 <section xml:id="core.rest.fileformats.r-package-betatxt.example"><info><title>Example</title></info>
  
  <programlisting role="text"><![CDATA[0.1.2]]></programlisting>
 </section>

</section>


<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.rest.fileformats.r-package-alphatxt"><info><title>alpha.txt</title></info>
 
 <synopsis>The latest alpha version</synopsis>

 <para>
  The only content of this file is the version number of the latest
  alpha version in pure plain text.
 </para>


 <section xml:id="core.rest.fileformats.r-package-alphatxt.location"><info><title>Location</title></info>
  
  <para>
   <filename>r/${packagename}/alpha.txt</filename>
  </para>
  <note>
   <para>
    The package name is lowercased.
   </para>
  </note>
  <para>
   This file does not exist when no alpha release exists.
  </para>
 </section>


 <section xml:id="core.rest.fileformats.r-package-alphatxt.example"><info><title>Example</title></info>
  
  <programlisting role="text"><![CDATA[0.1.2]]></programlisting>
 </section>

</section>


<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.rest.fileformats.r-package-develtxt"><info><title>devel.txt</title></info>
 
 <synopsis>The latest development version</synopsis>

 <para>
  The only content of this file is the version number of the latest
  development version in pure plain text.
 </para>


 <section xml:id="core.rest.fileformats.r-package-develtxt.location"><info><title>Location</title></info>
  
  <para>
   <filename>r/${packagename}/devel.txt</filename>
  </para>
  <note>
   <para>
    The package name is lowercased.
   </para>
  </note>
  <para>
   This file does not exist when no development release exists.
  </para>
 </section>


 <section xml:id="core.rest.fileformats.r-package-develtxt.example"><info><title>Example</title></info>
  
  <programlisting role="text"><![CDATA[0.1.2]]></programlisting>
 </section>

</section>


<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.rest.fileformats.r-package-012xml"><info><title>0.1.2.xml (release)</title></info>
 
 <synopsis>Short xml file about the release</synopsis>

 <para>
  This file is a special size-optimized version of
  the full <filename>package.xml</filename> with only necessary information.
 </para>

 <para>
  As in <filename>package.xml</filename>, the tag order is important
  and may not be shuffled.
 </para>


 <section xml:id="core.rest.fileformats.r-package-012xml.location"><info><title>Location</title></info>
  
  <para>
   <filename>r/${packagename}/0.1.2.xml</filename>
  </para>
  <note>
   <para>
    The package name is lowercased.
   </para>
  </note>
 </section>


 <section xml:id="core.rest.fileformats.r-package-012xml.example"><info><title>Example</title></info>
  
  <programlisting role="xml"><![CDATA[<?xml version="1.0" encoding="utf-8" ?>
<r xmlns="http://pear.php.net/dtd/rest.release"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:xlink="http://www.w3.org/1999/xlink"
   xsi:schemaLocation="http://pear.php.net/dtd/rest.release
                       http://pear.php.net/dtd/rest.release.xsd"
>
 <p xlink:href="/rest/p/worlddominator">WorldDominator</p>
 <c>pear.example.org</c>
 <v>0.1.2</v>
 <st>beta</st>
 <l>Dictatoric License</l>
 <m>thebrain</m>
 <s>Tool to dominate the world</s>
 <d>Helps you dominating the world by fulfilling various tasks:
  - Feed the cats
  - Lock the doors after 23:42</d>
 <da>2007-12-24 23:42:00</da>
 <n>* Fix atomic X-mas bug [thebrain]</n>
 <f>19588</f>
 <g>http://pear.example/get/WorldDominator-0.1.2</g>
 <x xlink:href="package.0.1.2.xml"/>
</r>]]></programlisting>
 </section>


 <section xml:id="core.rest.fileformats.r-package-012xml.tags"><info><title>Tags</title></info>
  
  <table><title>Tag description</title>
   
   <tgroup cols="2">
    <thead>
     <row>
      <entry>Tag name</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><literal>&lt;p&gt;</literal></entry>
      <entry>
       Package name inclusive absolute path to the package directory
      </entry>
     </row>

     <row>
      <entry><literal>&lt;c&gt;</literal></entry>
      <entry>Channel server name</entry>
     </row>

     <row>
      <entry><literal>&lt;v&gt;</literal></entry>
      <entry>Release version</entry>
     </row>

     <row>
      <entry><literal>&lt;st&gt;</literal></entry>
      <entry>
       Stability state
       (e.g. <literal>stable</literal>, <literal>beta</literal> etc.)
      </entry>
     </row>

     <row>
      <entry><literal>&lt;l&gt;</literal></entry>
      <entry>License name</entry>
     </row>

     <row>
      <entry><literal>&lt;m&gt;</literal></entry>
      <entry>Handle/nickname of the releasing developer</entry>
     </row>

     <row>
      <entry><literal>&lt;s&gt;</literal></entry>
      <entry>Summary</entry>
     </row>

     <row>
      <entry><literal>&lt;d&gt;</literal></entry>
      <entry>Description, multiline</entry>
     </row>

     <row>
      <entry><literal>&lt;da&gt;</literal></entry>
      <entry>Date and time of release</entry>
     </row>

     <row>
      <entry><literal>&lt;n&gt;</literal></entry>
      <entry>Release notes</entry>
     </row>

     <row>
      <entry><literal>&lt;f&gt;</literal></entry>
      <entry>File size of the tgz in bytes</entry>
     </row>

     <row>
      <entry><literal>&lt;g&gt;</literal></entry>
      <entry>Full URL to the release archive</entry>
     </row>

     <row>
      <entry><literal>&lt;x&gt;</literal></entry>
      <entry>
       Link to the version's
       <link linkend="core.rest.fileformats.r-package-package012xml">
        <filename>package.xml</filename>
       </link>
       file.
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>
 </section>

</section>


<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.rest.fileformats.r-package-v2012xml"><info><title>v2.0.1.2.xml</title></info>
 
 <synopsis>Short xml file about the release, version 2</synopsis>

 <para>
  Same as
  <link linkend="core.rest.fileformats.r-package-012xml">
   <filename>0.1.2.xml</filename>
  </link>,
  but with additional API and minimum PHP version.
 </para>


 <section xml:id="core.rest.fileformats.r-package-v2012xml.location"><info><title>Location</title></info>
  
  <para>
   <filename>r/${packagename}/v2.0.1.2.xml</filename>
  </para>
  <note>
   <para>
    The package name is lowercased.
   </para>
  </note>
 </section>


 <section xml:id="core.rest.fileformats.r-package-v2012xml.example"><info><title>Example</title></info>
  
  <programlisting role="xml"><![CDATA[<?xml version="1.0" encoding="utf-8" ?>
<r xmlns="http://pear.php.net/dtd/rest.release2"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:xlink="http://www.w3.org/1999/xlink"
   xsi:schemaLocation="http://pear.php.net/dtd/rest.release2
                       http://pear.php.net/dtd/rest.release2.xsd"
>
 <p xlink:href="/rest/p/worlddominator">WorldDominator</p>
 <c>pear.example.org</c>
 <v>0.1.2</v>
 <a>0.1.2</a>
 <mp>5.2.3</mp>
 <st>beta</st>
 <l>Dictatoric License</l>
 <m>thebrain</m>
 <s>Tool to dominate the world</s>
 <d>Helps you dominating the world by fulfilling various tasks:
  - Feed the cats
  - Lock the doors after 23:42</d>
 <da>2007-12-24 23:42:00</da>
 <n>* Fix atomic X-mas bug [thebrain]</n>
 <f>19588</f>
 <g>http://pear.example/get/WorldDominator-0.1.2</g>
 <x xlink:href="package.0.1.2.xml"/>
</r>]]></programlisting>
 </section>


 <section xml:id="core.rest.fileformats.r-package-v2012xml.tags"><info><title>Tags</title></info>
  

  <para>
   New tags compared to <filename>0.1.2.xml</filename>.
  </para>

  <table><title>Tag description</title>
   
   <tgroup cols="2">
    <thead>
     <row>
      <entry>Tag name</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>

     <row>
      <entry><literal>&lt;a&gt;</literal></entry>
      <entry>API version</entry>
     </row>

     <row>
      <entry><literal>&lt;mp&gt;</literal></entry>
      <entry>Minimum PHP version</entry>
     </row>

    </tbody>
   </tgroup>
  </table>
 </section>

</section>


<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.rest.fileformats.r-package-package012xml"><info><title>package.0.1.2.xml</title></info>
 
 <synopsis>Full package.xml</synopsis>

 <para>
  Full <filename>package.xml</filename> for the release. May be version 1
  or version 2 of the <filename>package.xml</filename> format.
  The highest version should be made available if the package contains
  both.
 </para>


 <section xml:id="core.rest.fileformats.r-package-package012xml.location"><info><title>Location</title></info>
  
  <para>
   <filename>r/${packagename}/package.0.1.2.xml</filename>
  </para>
  <note>
   <para>
    The package name is lowercased.
   </para>
  </note>
 </section>


</section>


<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.rest.fileformats.r-package-deps012txt"><info><title>deps.0.1.2.txt</title></info>
 
 <synopsis>Serialized dependency information</synopsis>

 <para>
  The file contains an array of dependency information, serialized with
  PHP's
  <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.php.net/serialize"><function>serialize</function></link>
  function.
 </para>

 <section xml:id="core.rest.fileformats.r-package-deps012txt.location"><info><title>Location</title></info>
  
  <para>
   <filename>r/${packagename}/deps.0.1.2.txt</filename>
  </para>
  <note>
   <para>
    The package name is lowercased.
   </para>
  </note>
 </section>


 <section xml:id="core.rest.fileformats.r-package-deps012txt.example"><info><title>Example of an dependency array, unserialized and in xml</title></info>
  
  <programlisting role="xml"><![CDATA[array(2) {
  ["required"]=>
  array(2) {
    ["php"]=>
    array(1) {
      ["min"]=>
      string(5) "5.2.3"
    }
    ["pearinstaller"]=>
    array(1) {
      ["min"]=>
      string(7) "1.7.1"
    }
  }
  ["optional"]=>
  array(1) {
    ["package"]=>
    array(2) {
      ["name"]=>
      string(4) "Toolbox"
      ["channel"]=>
      string(12) "pear.example.org"
      ["min"] =>
      string(7) "1.3.0"
    }
  }
}]]></programlisting>

  <programlisting role="xml"><![CDATA[
<dependencies>
  <required>
   <php>
    <min>5.2.3</min>
   </php>
   <pearinstaller>
    <min>1.7.1</min>
   </pearinstaller>
  </required>
  <optional>
   <package>
    <name>Toolbox</name>
    <channel>pear.example.org</channel>
    <min>1.3.0</min>
   </package>
  </optional>
 </dependencies>
]]></programlisting>
 </section>

</section>



</section>

 
<section xmlns="http://docbook.org/ns/docbook" xmlns:phd="http://www.php.net/ns/phd" version="lillet" xml:id="core.rest.history" phd:chunk="true">
 <info>
  <title>REST version history</title>
  <titleabbrev>Changes between PEAR REST interface versions</titleabbrev>
 </info>
  
  

  <para>
   This page lists the known REST versions and their changes they introduced.
  </para>


  <section xml:id="core.rest.history.rest10"><info><title>REST 1.0</title></info>
   

   <para>
    This was the initial and first supported version of the REST interface.
   </para>
  </section>


  <section xml:id="core.rest.history.rest11"><info><title>REST 1.1</title></info>
   

   <para>
    This version added files to allow spidering channels without
    requiring the server to have directory listings enabled.
    These files are:
   </para>

   <itemizedlist>
    <listitem>
     <para>
      <link linkend="core.rest.fileformats.c-categoriesxml">
       <filename>c/categories.xml</filename>
      </link>
     </para>
    </listitem>

    <listitem>
     <para>
      <link linkend="core.rest.fileformats.c-category-packagesinfoxml">
       <filename>c/$categoryname/packagesinfo.xml</filename>
      </link>
     </para>
    </listitem>

    <listitem>
     <para>
      <link linkend="core.rest.fileformats.m-allmaintainersxml">
       <filename>m/allmaintainers.xml</filename>
      </link>
     </para>
    </listitem>
   </itemizedlist>
  </section>


  <section xml:id="core.rest.history.rest12"><info><title>REST 1.2</title></info>
   

   <para>
    Now the developer's roles are listed in the package's
    maintainer list.
   </para>
   <itemizedlist>
    <listitem>
     <para>
      <link linkend="core.rest.fileformats.p-package-maintainers2xml">
       <filename>p/${packagename}/maintainers2.xml</filename>
      </link>
     </para>
    </listitem>
   </itemizedlist>
  </section>


  <section xml:id="core.rest.history.rest13"><info><title>REST 1.3</title></info>
   

   <para>
    This version makes it possible to resolve PHP version incompatibilities
    by downloading the releases list only.
    <filename>allreleases2.xml</filename> lists the minimum PHP version
    for each package release, thus the package name does not need to be
    changed when upgrading the package's minimum PHP version.
   </para>

   <itemizedlist>
    <listitem>
     <para>
      <link linkend="core.rest.fileformats.r-package-allreleases2xml">
       <filename>r/${packagename}/allreleases2.xml</filename>
      </link>
     </para>
    </listitem>

    <listitem>
     <para>
      <link linkend="core.rest.fileformats.r-package-v2012xml">
       <filename>r/${packagename}/v2.0.1.2.xml</filename>
      </link>
     </para>
    </listitem>

   </itemizedlist>
  </section>

 </section>

 
<section xmlns="http://docbook.org/ns/docbook" xmlns:phd="http://www.php.net/ns/phd" version="lillet" xml:id="core.rest.usecases" phd:chunk="true">
 <info>
  <title>Use cases</title>
  <titleabbrev>What do do when releasing a new package</titleabbrev>
 </info>
 
 

 <para>
  This section shows common actions on a channel server and what
  to do then.
 </para>

 <para>
  The idea and initial cases have been taken from
  Jean-Lou Dupont's
  "<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://docs.google.com/present/view?id=dgstxrxv_6f48xbz">PEAR Channel on Google Code</link>"
  presentation.
 </para>



<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.rest.usecases.addcategory"><info><title>Adding a new category</title></info>
 

 <para>
  When creating a fresh category on your channel server, the following
  steps are necessary:
 </para>

 <orderedlist>
  <listitem>
   <para>
     Create <filename>c/${CategoryName}</filename> directory.
   </para>
  </listitem>

  <listitem>
   <para>
    Create the following files:
    <itemizedlist>
     <listitem>
      <para>
       <link linkend="core.rest.fileformats.c-category-infoxml">
        <filename>c/${CategoryName}/info.xml</filename>
       </link>
      </para>
     </listitem>

     <listitem>
      <para>
       <link linkend="core.rest.fileformats.c-category-packagesxml">
        <filename>c/${CategoryName}/packages.xml</filename>
       </link>
      </para>
     </listitem>

     <listitem>
      <para>
       <link linkend="core.rest.fileformats.c-category-packagesinfoxml">
        <filename>c/${CategoryName}/packagesinfo.xml</filename>
       </link>
      </para>
     </listitem>
    </itemizedlist>
   </para>
  </listitem>

  <listitem>
   <para>
    Update
    <link linkend="core.rest.fileformats.c-categoriesxml">
     <filename>c/categories.xml</filename>
    </link>.
   </para>
  </listitem>
 </orderedlist>

</section>


<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.rest.usecases.addpackage"><info><title>Adding a new package</title></info>
 

 <para>
  A new package shall be published on the server, and here are the steps
  you need to do:
 </para>

 <orderedlist>
  <listitem>
   <para>
     Check if the package category already exists, or
     a <link linkend="core.rest.usecases.addcategory">new category</link>
     needs to be created.
   </para>
  </listitem>

  <listitem>
   <para>
    Create the package directory <filename>p/${packagename}/</filename>.
   </para>
  </listitem>

  <listitem>
   <para>
    Create those files:
    <itemizedlist>
     <listitem>
      <para>
       <link linkend="core.rest.fileformats.p-package-infoxml">
        <filename>r/${packagename}/info.xml</filename>
       </link>
      </para>
     </listitem>

     <listitem>
      <para>
       <link linkend="core.rest.fileformats.p-package-maintainersxml">
        <filename>r/${packagename}/maintainers.xml</filename>
       </link>
      </para>
     </listitem>

     <listitem>
      <para>
       <link linkend="core.rest.fileformats.p-package-maintainers2xml">
        <filename>r/${packagename}/maintainers2.xml</filename>
       </link>
      </para>
     </listitem>
    </itemizedlist>
   </para>
  </listitem>

  <listitem>
   <para>
    Update the category files:
    <itemizedlist>
     <listitem>
      <para>
       <link linkend="core.rest.fileformats.c-category-packagesxml">
        <filename>c/${CategoryName}/packages.xml</filename>
       </link>
      </para>
     </listitem>

     <listitem>
      <para>
       <link linkend="core.rest.fileformats.c-category-packagesinfoxml">
        <filename>c/${CategoryName}/packagesinfo.xml</filename>
       </link>
      </para>
     </listitem>
    </itemizedlist>
   </para>
  </listitem>
 </orderedlist>


</section>


<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="core.rest.usecases.addrelease"><info><title>Adding a release</title></info>
 

 <para>
  The time has come to release a new version of an existing package.
  Those are the steps to do:
 </para>

 <orderedlist>
  <listitem>
   <para>
    Publish the release's <filename>package.xml</filename> as
    <link linkend="core.rest.fileformats.r-package-package012xml">
     <filename>r/${packagename}/package.0.1.2.xml</filename>
    </link>.
   </para>
  </listitem>

  <listitem>
   <para>
    Create the version specific
    <link linkend="core.rest.fileformats.r-package-012xml">
     <filename>r/${packagename}/0.1.2.xml</filename>
    </link>.
   </para>
  </listitem>

  <listitem>
   <para>
    Update state files if appropriate:
    <link linkend="core.rest.fileformats.r-package-latesttxt">
     <filename>r/${packagename}/latest.txt</filename>
    </link>,
    <link linkend="core.rest.fileformats.r-package-stabletxt">
     <filename>stable.txt</filename>
    </link>,
    <link linkend="core.rest.fileformats.r-package-betatxt">
     <filename>beta.txt</filename>
    </link>,
    <link linkend="core.rest.fileformats.r-package-alphatxt">
     <filename>alpha.txt</filename>
    </link>,
    <link linkend="core.rest.fileformats.r-package-develtxt">
     <filename>devel.txt</filename>
    </link>.
   </para>
  </listitem>

  <listitem>
   <para>
    Generate
    <link linkend="core.rest.fileformats.r-package-deps012txt">
     <filename>r/${packagename}/deps.0.1.2.xml</filename>
    </link>.
   </para>
  </listitem>

  <listitem>
   <para>
    Update
    <link linkend="core.rest.fileformats.r-package-allreleasesxml">
     <filename>r/${packagename}/allreleases.xml</filename>
    </link>
    and
    <link linkend="core.rest.fileformats.r-package-allreleases2xml">
     <filename>r/${packagename}/allreleases2.xml</filename>
    </link>.
   </para>
  </listitem>

  <listitem>
   <para>
    Place package archives (<literal>tar</literal> and <literal>tgz</literal>)
    at the place specified in
    <link linkend="core.rest.fileformats.r-package-012xml">
     <filename>r/${packagename}/0.1.2.xml</filename>
    </link>.
   </para>
  </listitem>

 </orderedlist>

</section>


</section>

 
<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:phd="http://www.php.net/ns/phd" version="lillet" xml:id="core.rest.channelserversoftware" phd:chunk="true">
 <info>
  <title>Channel server software</title>
 </info>

 <para>
  While you can use this documentation to build you own channel server,
  it is possibly easier for you to either get your package
  into PEAR itself, or setup your own channel server.
  The reference implementation of a PEAR channel server is the PEAR website
  itself, but it should not be used for your own server.
 </para>

 <para>
  If you seek for an easy-to-setup software,
  try <classname>Chiara_PEAR_Server</classname> which resides on its own
  channel <link xlink:href="http://pear.chiaraquartet.net">http://pear.chiaraquartet.net</link>.
 </para>

 <para>
  Another project is <link linkend="channels.scs.intro">SimpleChannelServer</link>,
  which is available as a plugin for Pyrus, or a standalone phar
  <link xlink:href="https://github.com/pear2/PEAR2_SimpleChannelServer/blob/master/pearscs.phar?raw=true">pearscs.phar</link>.
  View the <link linkend="channels.scs.intro">online documentation</link>,
  or the source <link xlink:href="https://github.com/pear2/PEAR2_SimpleChannelServer">in SVN</link>.
 </para>

</section>


 <!-- FIXME: faq
- how do I find the latest version of a package? (incl. stable/beta/..)
- where do I get the download URL from?
- URL calculation
- can a package have multiple categories?

<bbieber> cweiske: the only thing I can think of off-hand is omission of the /get/ directories - and including both .tar/.tgz (are both necessary anymore?)
<cweiske> i think they are
<cweiske> since you need to decide if you can work with compression or not
<cweiske> if you got no gzip lib, you need the tar only
<cweiske> otherwise you can save bandwith and load the gz
<bbieber> slide 16 has some info on the archive file... which could have the info.
<bbieber> cweiske: ah yes.
<cweiske> btw, I found no docs where the /get/ dirs are located
<cweiske> they are referenced in the package xyz info
<cweiske> but nothing more
 -->

</section>

 </chapter>

  
<chapter xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="channels.scs">
  <info>
   <title>Creating your own channel with Pyrus and PEAR2_SimpleChannelServer</title>
   <author><personname><firstname>Brett</firstname><surname>Bieber</surname></personname></author>
   <date>2009-07-01</date>
  </info>

  <para>
   Documentation is a work in progress.
  </para>

 
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="channels.scs.intro">
 <info><title>Introduction to PEAR2_SimpleChannelServer</title></info>

 <para>
   The SimpleChannelServer package allows developers to create a 
   PEAR compatible channel server to distribute packages. This channel server
   is simple in that it only works with the local filesystem to create the 
   necessary files for package distribution.
 </para>
 <note>
  <para>
   At a minimum, the ability to post files to the webspace where your channel
   will be hosted.
  </para>
 </note>
 <para>
   It is possible to host your PEAR channel on webspace such as Google
   Code, just use the webpath to the svn directory as your channel name,
   and be sure to set the correct svn:mime-type on the xml files.
 </para>
 <para>
    To get started, simply download the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://github.com/pear2/PEAR2_SimpleChannelServer/raw/master/pearscs.phar">pearscs.phar</link>
    file to your local filesystem, and execute the <literal>pearscs.phar</literal> 
    file with the <literal>create</literal> command. Then, build the rest of
    the channel using the <link linkend="channels.scs.commands">other SimpleChannelServer commands</link>.
 </para>
</section>

 
<section xmlns="http://docbook.org/ns/docbook" xmlns:phd="http://www.php.net/ns/phd" version="lillet" xml:id="channels.scs.commands">
 <info><title>Commands Available In PEAR2_SimpleChannelServer</title></info>
 
 <!-- this thing does not work whatsoever. -->
  <phd:toc phd:toc-depth="3" phd:element="channels.scs.commands"/>
  <simpara>
   Commands available for the pearscs command-line script.
  </simpara>
  
  
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="channels.scs.commands.create">
 <info><title>create - creates a PEAR channel</title></info>
 <para>
    The <literal>create</literal> command creates a PEAR channel on the
    local filesystem, including the channel.xml file and the get and rest
    directories. This command assumes you are currently at the web root
    for the channel you wish to create, unless you pass the path to where the
    channel.xml file will be created. The local root can be a subdirectory
    off of your webserver, but you should be in that subdirectory when
    executing this command.
 </para>
 <para>
   <screen>
    pearscs create pear.example.com summary [alias] [./channel.xml]
   </screen>
 </para>
 <para>
   Required arguments are the channel name and channel summary.
   
   For example pear.example.com or can also be a subdirectory such as
   www.example.com/pear.
 </para>
 <para>
   The alias is a short name which can be used to refer to your PEAR channel.
   
   If one is not specified, SimpleChannelServer will attempt to create one for
   you.
   
 </para>
 <para>
  If the path to a channel.xml file is specified, the directory given will be
  used to create the channel.xml, get, and rest directories for the channel.
  If no path is specified, SimpleChannelServer will use the current directory.
 </para>
</section>

  
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="channels.scs.commands.release">
 <info><title>release - releases a PEAR package to the channel</title></info>
 <para>
    The <literal>release</literal> command releases a package to your PEAR
    channel.
 </para>
 <para>
   <screen>
    pearscs release MyPackage-1.0.0.tgz handle
   </screen>
 </para>
 <para>
   The file must be a valid PEAR package, and can be either the package.xml
   file, or a compressed and optionally signed .tgz file.
 </para>
 <para>
   The <literal>handle</literal> attribute should be a lead maintainer for the
   package, as who released this version will be stored within the channel's
   xml files.
 </para>
</section>

  
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="channels.scs.commands.update">
 <info><title>update - updates the xml files for the local channel</title></info>
 <para>
    The <literal>update</literal> command re-generates the xml files for all 
    releases.
 </para>
 <para>
   <screen>
   pearscs update [./channel.xml]
   </screen>
 </para>
 <para>
  This command updates the associated xml files for all releases present in the
  get directory.
 </para>
</section>
  
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="channels.scs.commands.addmaintainer">
 <info><title>add-maintainer - adds a maintainer</title></info>
 <para>
    The <literal>add-maintainer</literal> command adds a maintainer's handle
    to the list of channel maintainers.
 </para>
 <para>
   <screen>
   pearscs add-maintainer handle
   </screen>
 </para>
 <para>
  This command adds the handle of a maintainer to the local channel. It is not
  necessary to add maintainers before releasing a package, as they will
  automatically be added or updated.
 </para>
</section>
  
<section xmlns="http://docbook.org/ns/docbook" version="lillet" xml:id="channels.scs.commands.addcategory">
 <info><title>add-category - adds a package category</title></info>
 <para>
    The <literal>add-category</literal> command adds a category to the channel.
 </para>
 <para>
   <screen>
   pearscs add-cateogry category
   </screen>
 </para>
 <para>
  This command adds a category to the channel for grouping related packages.
 </para>
</section>
</section>

 </chapter>

 </book>
</set>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
